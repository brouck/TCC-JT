From 9ff31960008633a80b386483d30a6da5d17ed34f Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 23:25:30 +0000
Subject: [PATCH 0001/1934] Update version

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@150 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 9cd1e5c1a..534c66575 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -87,8 +87,9 @@ Various documentation is available:
 
 <section name="Releases">
 <p>
-<a href="http://sourceforge.net/project/showfiles.php?group_id=97367&amp;package_id=104212">Release 0.9</a>
-is the current latest release. It is reasonably stable, although some APIs will change for 1.0.
+<a href="http://sourceforge.net/project/showfiles.php?group_id=97367&amp;package_id=104212&amp;release_id=217327">Release 0.95</a>
+is the current latest release.
+It is reasonably stable, and we hope that the main APIs are now stable for 1.0.
 </p>
 </section>
 

From 4fbcc5a0758e4a2c16e71a2f0f4ef2f8bbf37afa Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 16 Feb 2004 00:09:07 +0000
Subject: [PATCH 0002/1934] Update version

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@151 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml   | 2 +-
 JodaTime/project.xml | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 13fb1155f..5e0545675 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -23,7 +23,7 @@
   <property name="component.title"         value="Joda date and time"/>
 
   <!-- The current version number of this component -->
-  <property name="component.version"       value="0.95"/>
+  <property name="component.version"       value="0.96"/>
 
   <!-- The current version number of this component -->
   <property name="component.fullname"      value="${component.name}-${component.version}"/>
diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index ea9393b0d..40e602474 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -5,14 +5,14 @@
   <id>joda-time</id>
   <name>Joda time</name>
   <groupId>joda-time</groupId>
-  <currentVersion>0.95</currentVersion>
+  <currentVersion>0.96</currentVersion>
   <organization>
     <name>Joda.org</name>
     <url>http://www.joda.org</url>
     <logo>/images/joda.png</logo>
   </organization>
   <inceptionYear>2002</inceptionYear>
-  <package>org.joda.time.*</package>
+  <package>org.joda.time</package>
   <logo>/images/jodatime.png</logo>
 
   <description>

From 563b398218618606ccf08ce0d60178ae5707eb00 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 16 Feb 2004 00:13:50 +0000
Subject: [PATCH 0003/1934] Update site docs

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@152 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.properties                   |  1 +
 JodaTime/src/java/org/joda/time/overview.html | 74 +++++++++++++++++++
 JodaTime/xdocs/index.xml                      |  2 +-
 JodaTime/xdocs/navigation.xml                 |  2 +-
 4 files changed, 77 insertions(+), 2 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/overview.html

diff --git a/JodaTime/project.properties b/JodaTime/project.properties
index 0387184dc..1e8dd195e 100644
--- a/JodaTime/project.properties
+++ b/JodaTime/project.properties
@@ -7,3 +7,4 @@ maven.checkstyle.properties=checkstyle.xml
 maven.junit.fork=true
 maven.xdoc.poweredby.image=maven-feather.png
 maven.javadoc.links=http://java.sun.com/products/j2se/1.4/docs/api
+maven.javadoc.overview=src/java/org/joda/time/overview.html
\ No newline at end of file
diff --git a/JodaTime/src/java/org/joda/time/overview.html b/JodaTime/src/java/org/joda/time/overview.html
new file mode 100644
index 000000000..017a1b743
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/overview.html
@@ -0,0 +1,74 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-2004 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
+<body>
+<p>
+Joda-Time is a library designed as a complete alternative to the JDK date
+and time classes. It includes date, duration and interval classes and has a
+pluggable API for various calendar systems.
+</p>
+<p>
+The library consists of quite a large number of classes, however most are
+internal to the implementation. All the key interfaces and classes are in the main
+package. The format package may be of interest for formatting, and the chrono package
+will be of interest for non ISO standard calendar systems.
+</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 534c66575..6f41e83b5 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -78,7 +78,7 @@ which is an Apache/BSD cloned licence.
 Various documentation is available:
 </p>
 <ul>
-<li>The javadoc for the <a href="apidocs-release/index.html">current release</a></li>
+<li>The javadoc for the <a href="api-0.95/index.html">current release</a></li>
 <li>The javadoc for the <a href="apidocs/index.html">latest CVS</a></li>
 <li>The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time/JodaTime">CVS repository</a></li>
 </ul>
diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
index 4f2db9533..dcf4368df 100644
--- a/JodaTime/xdocs/navigation.xml
+++ b/JodaTime/xdocs/navigation.xml
@@ -10,7 +10,7 @@
       <item name="Overview" href="/index.html"/>
       <item name="Users guide" href="/userguide.html"/>
       <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
-      <item name="Javadoc (Release)" href="/apidocs-release/index.html"/>
+      <item name="Javadoc (Release)" href="/api-0.95/index.html"/>
       <item name="Test results" href="/junit-report.html"/>
       <item name="Mailing lists" href="/mail-lists.html"/>
       <item name="Tasks" href="/tasks.html"/>

From 6ed3c27ce26882eddc7672e6cf74842e5b8a50ea Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 16 Feb 2004 05:56:38 +0000
Subject: [PATCH 0004/1934] Yet another minor comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@153 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeConstants.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index 16ee5dc3f..0e8cd2aaa 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -156,7 +156,7 @@
     public static final int MINUTES_PER_HOUR = 60;
     /** Seconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
-    /** Milliseconds in one hour (60) (ISO) */
+    /** Milliseconds in one hour (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;
 
     /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the

From c733e2ab5716f290f8236351ad12392fb51c3c65 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 16 Feb 2004 20:51:16 +0000
Subject: [PATCH 0005/1934] Update site docs

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@154 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 6f41e83b5..cd4c4c708 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -48,7 +48,7 @@ String monthInFrench = dt.monthOfYear().getAsText(Locale.FRENCH);
 String dateAsISO8601Format = dt.toString();
 </source>
 <p>
-And this is only a flavour of what is available, see the <a href="api-0.9/index.html">API</a>
+And this is only a flavour of what is available, see the <a href="api-0.95/index.html">API</a>
 or <a href="userguide.html">users guide</a> for more detail.
 </p>
 

From 354d0183ae68b14a371c521388496d9315aa4a74 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 23 Feb 2004 01:25:54 +0000
Subject: [PATCH 0006/1934] Add FAQ to website

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@155 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/faq.xml        | 113 ++++++++++++++++++++++++++++++++++
 JodaTime/xdocs/index.xml      |   3 +-
 JodaTime/xdocs/navigation.xml |   3 +-
 3 files changed, 117 insertions(+), 2 deletions(-)
 create mode 100644 JodaTime/xdocs/faq.xml

diff --git a/JodaTime/xdocs/faq.xml b/JodaTime/xdocs/faq.xml
new file mode 100644
index 000000000..a1fe9afb8
--- /dev/null
+++ b/JodaTime/xdocs/faq.xml
@@ -0,0 +1,113 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Joda FAQ</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Frequently Asked Questions">
+<p>
+Some common questions about Joda-Time are answered here.
+<ul>
+<li><a href="#iso">What is ISO8601?</a></li>
+<li><a href="#internalstorage">How are times calculated internally?</a></li>
+<li><a href="#long">Why limit to the number of milliseconds in a long?</a></li>
+<li><a href="#range">What date range is supported?</a></li>
+<li><a href="#submilli">What about sub-millisecond accuracy?</a></li>
+<li><a href="#joda">What is with the name 'joda'?</a></li>
+</ul>
+Question not answered? <a href="mailto:joda-interest@lists.sourceforge.net">Suggest another FAQ</a>
+</p>
+
+
+<a name="iso" />
+<subsection name="What is ISO8601?">
+<p>
+Historically, every country has found their own solution to measuring time.
+This has often been political and religious.
+To simplify the problem, especially in the realm of computer data transfer, the ISO8601 standard was founded.
+</p>
+<p>
+The ISO standard defines a framework for passing dates and times between computer systems in a standard way.
+The standard uses the proleptic Gregorian calendar.
+This makes it fully compatible with the calendar system used in most of the world after 1582.
+The standard warns that it may only be used to represent dates before 1582 'by mutual agreement'.
+</p>
+<p>
+The standard defines twelve months January to December numbered 1 to 12 and
+seven days Monday to Sunday, numbered 1 to 7.
+In addition it defines the first week of the year as the first week to have most of its days in the new year.
+This can result in the first week of a year starting in the previous year and the last week ending in the following year.
+</p>
+<p>
+The key point about ISO8601 is that it is a framework for dates not an absolute single definition.
+The most common form is YYYY-MM-DDTHH:MM:SS.SSSZ, in other words year-month-day letter 'T' hour:minute:second and fractions.
+</p>
+</subsection>
+
+
+<a name="internalstorage" />
+<subsection name="How are times calculated internally?">
+<p>
+All time values are calculated using a single long value representing milliseconds.
+The epoch of the definition is 1970-01-01T00:00:00.
+This is the same as the JDK time definition and usage.
+</p>
+</subsection>
+
+
+<a name="long" />
+<subsection name="Why limit to the number of milliseconds in a long?">
+<p>
+There are three main reasons for using a single long value to store the time.
+<ol>
+<li>Compatibility - being compatible with the JDK makes conversion simpler</li>
+<li>Performance - a primitive value enables fast calculations,
+whereas alternatives generally involve lots of expensive object creation</li>
+<li>Big enough - the range provided by a millisecond based solution is big enough for most needs</li>
+</ol>
+</p>
+</subsection>
+
+
+<a name="range" />
+<subsection name="What date range is supported?">
+<p>
+The range supported is -292,269,054 to 292,277,023.
+In other words, roughly +/- 290 million years to millisecond precision.
+</p>
+<p>
+If you want a date outside this range, ask yourself if you really want millisecond precision.
+In reality, dates this far in the past or future should only be stored as years - 
+anything else is meaningless.
+</p>
+</subsection>
+
+
+<a name="submilli" />
+<subsection name="What about sub-millisecond accuracy?">
+<p>
+Joda-Time does not support accuracy of times below millisecond.
+Physics defines time scales down to 5E-44 secs.
+The only way to accurately record these sorts of times is using the BigInteger class.
+This would severely compromise the performance of the whole API for a very limited use.
+</p>
+</subsection>
+
+
+<a name="joda" />
+<subsection name="What is with the name 'joda'?">
+<p>
+'Joda' is a short, four letter name, begining with 'j' whose domain name was free.
+It is not an acronym.
+</p>
+</subsection>
+
+
+</section>
+</body>
+</document>
diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index cd4c4c708..88a3e1c5f 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -33,7 +33,7 @@ This avoids any ambiguity across national boundaries.
 </p>
 
 <p>
-Additional calendar systems supported are Gregorian, Julian, GregorianJulian (GJ) and Buddhist.
+Additional calendar systems supported are Gregorian, Julian, GregorianJulian (GJ), Buddhist and Coptic.
 The design is flexible and pluggable, so adding additional calendar systems should be easy. 
 </p>
 
@@ -80,6 +80,7 @@ Various documentation is available:
 <ul>
 <li>The javadoc for the <a href="api-0.95/index.html">current release</a></li>
 <li>The javadoc for the <a href="apidocs/index.html">latest CVS</a></li>
+<li>A <a href="faq.html">FAQ</a> list</li>
 <li>The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time/JodaTime">CVS repository</a></li>
 </ul>
 
diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
index dcf4368df..e9085855d 100644
--- a/JodaTime/xdocs/navigation.xml
+++ b/JodaTime/xdocs/navigation.xml
@@ -9,8 +9,9 @@
     <menu name="Joda Time">
       <item name="Overview" href="/index.html"/>
       <item name="Users guide" href="/userguide.html"/>
-      <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
+      <item name="FAQ" href="/faq.html"/>
       <item name="Javadoc (Release)" href="/api-0.95/index.html"/>
+      <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
       <item name="Test results" href="/junit-report.html"/>
       <item name="Mailing lists" href="/mail-lists.html"/>
       <item name="Tasks" href="/tasks.html"/>

From 3ffd1a7f503ca4e24a5cb4b958f814b89d5aa6ae Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 24 Feb 2004 04:11:26 +0000
Subject: [PATCH 0007/1934] Added performance and threading.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@156 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/faq.xml | 49 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 48 insertions(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/faq.xml b/JodaTime/xdocs/faq.xml
index a1fe9afb8..c2a4d32a4 100644
--- a/JodaTime/xdocs/faq.xml
+++ b/JodaTime/xdocs/faq.xml
@@ -5,6 +5,7 @@
  <properties>
   <title>Joda FAQ</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+  <author email="broneill@users.sourceforge.net">Brian S O'Neill</author>
  </properties>
 
  <body>
@@ -18,6 +19,8 @@ Some common questions about Joda-Time are answered here.
 <li><a href="#long">Why limit to the number of milliseconds in a long?</a></li>
 <li><a href="#range">What date range is supported?</a></li>
 <li><a href="#submilli">What about sub-millisecond accuracy?</a></li>
+<li><a href="#performance">How well does it perform?</a></li>
+<li><a href="#threading">Does it support multi-threading?</a></li>
 <li><a href="#joda">What is with the name 'joda'?</a></li>
 </ul>
 Question not answered? <a href="mailto:joda-interest@lists.sourceforge.net">Suggest another FAQ</a>
@@ -99,10 +102,54 @@ This would severely compromise the performance of the whole API for a very limit
 </subsection>
 
 
+<a name="performance" />
+<subsection name="How well does it perform?">
+<p>
+Joda-Time is      designed for performance. Compared to java.util.Calendar,
+java.text.SimpleDateFormat, and java.util.TimeZone, nearly all equivalent
+operations in Java-Time are faster. The significant exceptions are operations
+to get or set an individual field.
+</p>
+<p>
+Calling "get" on java.util.Calendar is very fast because it doesn't do any
+work. Calendar calculates all fields in advance, even if many of those fields
+you won't need. Calendar's set method is fast because it defers calculations
+until later. Calling Calendar.get after calling Calendar.set forces all the
+field values to be re-calculated. Calling Joda's DateTime.get method after
+calling DateTime.set only performs the minimum amount of calculations, and the
+pair is faster than Calendar.
+</p>
+<p>
+Joda-Time also allocates very few temporary objects during operations, and
+performs almost no thread synchronization. In systems that are heavily
+multi-threaded or use a lot of memory, Calendar, SimpleDateFormat, and TimeZone
+can become bottlenecks. When the Joda-Time classes are used instead, the
+bottlenecks go away.
+</p>
+</subsection>
+
+
+<a name="threading" />
+<subsection name="Does it support multi-threading?">
+<p>
+Every public class in Joda-Time is documented as being thread-safe or not.
+Joda-Time makes heavy use of the immutability design pattern, and all immutable
+classes in Joda-Time are thread-safe. Many mutable classes whose instances are
+not likely to be shared are not thread-safe, and are documented as such.
+</p>
+<p>
+The most common multi-threading mistake made by Java programmers is in the use
+of SimpleDateFormat. Calling its format method on a shared instance by
+concurrent threads can produce bizarre results. All of Joda-Time's formatting
+classes are thread-safe and immutable.
+</p>
+</subsection>
+
+
 <a name="joda" />
 <subsection name="What is with the name 'joda'?">
 <p>
-'Joda' is a short, four letter name, begining with 'j' whose domain name was free.
+'Joda' is a short, four letter name, beginning with 'j' whose domain name was free.
 It is not an acronym.
 </p>
 </subsection>

From 3fcb482c6113559a9bd45cf1a44e71cb77544473 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 24 Feb 2004 16:15:54 +0000
Subject: [PATCH 0008/1934] Minor comment typo.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@157 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
index 24ec6b2d2..a5b8b44e2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -123,7 +123,7 @@
     /**
      * Constructor calls the assemble method, enabling subclasses to define its
      * supported fields. If a base chronology is supplied, the field set
-     * initially contains references to each base chronlogy field.
+     * initially contains references to each base chronology field.
      * <p>
      * Other methods in this class will delegate to the base chronology, if it
      * can be determined that the base chronology will produce the same results

From ea3536d60338ed3a48d9a44b0d4822af39366055 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 27 Feb 2004 16:43:24 +0000
Subject: [PATCH 0009/1934] Added leap second info.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@158 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/faq.xml | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/JodaTime/xdocs/faq.xml b/JodaTime/xdocs/faq.xml
index c2a4d32a4..44df96c37 100644
--- a/JodaTime/xdocs/faq.xml
+++ b/JodaTime/xdocs/faq.xml
@@ -21,6 +21,7 @@ Some common questions about Joda-Time are answered here.
 <li><a href="#submilli">What about sub-millisecond accuracy?</a></li>
 <li><a href="#performance">How well does it perform?</a></li>
 <li><a href="#threading">Does it support multi-threading?</a></li>
+<li><a href="#leapseconds">Are leap seconds supported?</a></li>
 <li><a href="#joda">What is with the name 'joda'?</a></li>
 </ul>
 Question not answered? <a href="mailto:joda-interest@lists.sourceforge.net">Suggest another FAQ</a>
@@ -146,6 +147,18 @@ classes are thread-safe and immutable.
 </subsection>
 
 
+<a name="leapseconds" />
+<subsection name="Are leap seconds supported?">
+<p>
+Joda-time does not support leap seconds. Leap seconds can be supported by
+     writing a new, specialized chronology, or by making a few enhancements to the
+existing ZonedChronology class. In either case, future versions of Joda-time
+will not enable leap seconds by default. Most applications have no need for it,
+and it might have additional performance costs.
+</p>
+</subsection>
+
+
 <a name="joda" />
 <subsection name="What is with the name 'joda'?">
 <p>

From 0433425ef67c56f0385665b124caaca8d929c27e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 28 Feb 2004 22:10:48 +0000
Subject: [PATCH 0010/1934] Preserve time zone when converting to Calendar.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@159 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/AbstractInstant.java  | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index bb4b54075..a5e12ad7f 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -465,7 +465,13 @@ public final Calendar toCalendar(Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        Calendar cal = Calendar.getInstance(locale);
+        DateTimeZone zone = getDateTimeZone();
+        Calendar cal;
+        if (zone == null) {
+            cal = Calendar.getInstance(locale);
+        } else {
+            cal = Calendar.getInstance(zone.toTimeZone(), locale);
+        }
         cal.setTime(toDate());
         return cal;
     }
@@ -476,7 +482,13 @@ public final Calendar toCalendar(Locale locale) {
      * @return a GregorianCalendar initialised with this datetime
      */
     public final GregorianCalendar toGregorianCalendar() {
-        GregorianCalendar cal = new GregorianCalendar();
+        DateTimeZone zone = getDateTimeZone();
+        GregorianCalendar cal;
+        if (zone == null) {
+            cal = new GregorianCalendar();
+        } else {
+            cal = new GregorianCalendar(zone.toTimeZone());
+        }
         cal.setTime(toDate());
         return cal;
     }

From 079da56f8e3846e7ed4f9e299b64792a8ae50a8a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 28 Feb 2004 23:21:08 +0000
Subject: [PATCH 0011/1934] Update website with more docs and better text for
 search engines

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@160 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/cal_gj.xml     | 45 +++++++++++++++++
 JodaTime/xdocs/cal_iso.xml    | 95 +++++++++++++++++++++++++++++++++++
 JodaTime/xdocs/faq.xml        |  2 +-
 JodaTime/xdocs/field.xml      |  2 +-
 JodaTime/xdocs/index.xml      | 31 ++++--------
 JodaTime/xdocs/navigation.xml | 13 ++++-
 JodaTime/xdocs/tasks.xml      |  2 +-
 JodaTime/xdocs/userguide.xml  |  6 +--
 8 files changed, 168 insertions(+), 28 deletions(-)
 create mode 100644 JodaTime/xdocs/cal_gj.xml
 create mode 100644 JodaTime/xdocs/cal_iso.xml

diff --git a/JodaTime/xdocs/cal_gj.xml b/JodaTime/xdocs/cal_gj.xml
new file mode 100644
index 000000000..84062ec6c
--- /dev/null
+++ b/JodaTime/xdocs/cal_gj.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Java date and time API - GregorianJulian (GJ) calendar system</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="GregorianJulian (GJ) calendar system">
+
+<p>
+Joda-Time provides a quality replacement for the Java date and time classes.
+The calendar system most commonly used for historical work is the GregorianJulian or GJ.
+This corresponds to the JDK <code>GregorianCalendar</code> class.
+</p>
+
+<p>
+The GregorianJulian calendar is a combination of two separate calendar systems.
+The switch from one to the other occurs at a configurable date.
+The default date is 1582-10-15, as defined by Pope Gregory XIII, working with the Council of Trent.
+</p>
+
+<p>
+The two calendar systems differ mainly in their accuracy of recording leap years.
+The Julian calendar defines a leap year as being once every four years.
+The Gregorian calendar adds two extra rules to state that years divisible by 100 are not leap, but those divisible by 400 are.
+</p>
+
+<p>
+Within Joda-Time this calendar system can be used by obtaining an instance of
+<a href="apidocs/org/joda/time/chrono/GJChronology.html">GJChronology</a>.
+This is then passed into the constructors of the main date and time classes.
+</p>
+<source>
+// setup date object for the Battle of Hastings in 1066
+Chronology chrono = GJChronology.getInstance();
+DateTime dt = new DateTime(1066, 10, 14, 10, 0, 0, 0, chrono);
+</source>
+
+</section>
+</body>
+</document>
diff --git a/JodaTime/xdocs/cal_iso.xml b/JodaTime/xdocs/cal_iso.xml
new file mode 100644
index 000000000..fab6ca8c2
--- /dev/null
+++ b/JodaTime/xdocs/cal_iso.xml
@@ -0,0 +1,95 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Java date and time API - ISO8601 calendar system</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="ISO8601 calendar system">
+
+<p>
+Joda-Time provides a quality replacement for the Java date and time classes.
+The default calendar system used internally is ISO8601.
+</p>
+
+<p>
+The ISO8601 standard was created by the International Organization for Standards based in Geneva.
+It aims to eliminate the risk of misinterpretting dates and times when representations
+are passed between systems and across national boundaries.
+We are unable to provide a direct link to the standard as it is a paid-for document.
+However some <a href="http://www.exit109.com/~ghealton/.dates.html#@Standards.ISO.8601.Commentary.Links">ISO8601 links</a> may be useful.
+</p>
+
+<p>
+The ISO8601 standard is based on the <i>proleptic Gregorian calendar</i>.
+This makes it fully compatible with the calendar system used in most countries today.
+The <i>proleptic</i> means that the Gregorian rules for leap years are applied for all time,
+thus the ISO8601 standard gives different results for dates before the year 1583.
+</p>
+
+<p>
+The standard sets out a framework within which dates and times can be represented.
+It offers many choices, however in reality there are three main date representations,
+year month day, year dayOfYear and year week dayOfWeek.
+</p>
+
+<subsection name="Month based">
+<p>
+yyyy-mm-dd<b>T</b>HH:MM:SS.SSS<br />
+This is the most common format of ISO8601 and separates the fields by dashes.
+The fields are:
+<ul>
+<li>four digit year</li>
+<li>two digit month, where 01 is Janurary and 12 is December</li>
+<li>two digit day of month, from 01 to 31</li>
+<li>two digit hour, from 00 to 23</li>
+<li>two digit minute, from 00 to 59</li>
+<li>two digit second, from 00 to 59</li>
+<li>three decimal places for milliseconds if required</li>
+</ul>
+This format is used in XML standards for passing dates and times.
+</p>
+</subsection>
+
+<subsection name="Day of Year based">
+<p>
+yyyy-ddd<b>T</b>HH:MM:SS.SSS<br />
+This format of ISO8601 has the following fields:
+<ul>
+<li>four digit year</li>
+<li>three digit day of year, from 01 to 366</li>
+<li>two digit hour, from 00 to 23</li>
+<li>two digit minute, from 00 to 59</li>
+<li>two digit second, from 00 to 59</li>
+<li>three decimal places for milliseconds if required</li>
+</ul>
+</p>
+</subsection>
+
+<subsection name="Week based">
+<p>
+yyyy-<b>W</b>ww-d<b>T</b>HH:MM:SS.SSS<br />
+This format of ISO8601 has the following fields:
+<ul>
+<li>four digit weekyear, see rules below</li>
+<li>two digit week of year, from 01 to 53</li>
+<li>one digit day of week, from 1 to 7 where 1 is Monday and 7 is Sunday</li>
+<li>two digit hour, from 00 to 23</li>
+<li>two digit minute, from 00 to 59</li>
+<li>two digit second, from 00 to 59</li>
+<li>three decimal places for milliseconds if required</li>
+</ul>
+Weeks are always complete, and the first week of a year is the one that includes the first Thursday of the year.
+This definition can mean that the first week of a year starts in the previous year, and the last week finishes in the next year.
+The weekyear field is defined to refer to the year that owns the week, which may differ from the actual year.
+</p>
+</subsection>
+
+
+</section>
+</body>
+</document>
diff --git a/JodaTime/xdocs/faq.xml b/JodaTime/xdocs/faq.xml
index 44df96c37..27a32cba0 100644
--- a/JodaTime/xdocs/faq.xml
+++ b/JodaTime/xdocs/faq.xml
@@ -3,7 +3,7 @@
 <document>
 
  <properties>
-  <title>Joda FAQ</title>
+  <title>Java date and time API - FAQ</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
   <author email="broneill@users.sourceforge.net">Brian S O'Neill</author>
  </properties>
diff --git a/JodaTime/xdocs/field.xml b/JodaTime/xdocs/field.xml
index 6b14ac5ad..47e6eb90a 100644
--- a/JodaTime/xdocs/field.xml
+++ b/JodaTime/xdocs/field.xml
@@ -3,7 +3,7 @@
 <document>
 
  <properties>
-  <title>Joda Time Fields</title>
+  <title>Java date and time API - Fields</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
  </properties>
 
diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 88a3e1c5f..d2c7a126b 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -3,38 +3,27 @@
 <document>
 
  <properties>
-  <title>Joda Time</title>
+  <title>Java date and time API - Home</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
  </properties>
 
  <body>
 
-<section name="Joda Time">
+<section name="Joda Time - Java date and time API">
 
 <p>
-<b>Joda-Time is an open-source project to provide a quality Java date and time API.</b>
+Joda-Time aims to provide a quality replacement for the Java <i>date</i> and <i>time</i> classes.
+The design allows for multiple <i>calendar</i> systems, while still providing simple API.
+The 'default' calendar is the <a href="cal_iso.html">ISO8601</a> standard which is used by XML.
+The Gregorian, Julian, Buddhist and Coptic systems are also included, and we welcome further additions.
+Supporting classes include time zone, duration, format and parsing.
 </p>
 
 <p>
-Date and Time handling is fundamental to many applications.
-However, the classes supplied in Java have always been weak.
-Date should have been immutable, like String.
-Instead, it has many deprecated methods.
+The decision to create a cleanroom date implementation to replace Java's is based on the flaws in the JDK code.
+Date should have been immutable, like String, instead it it is mutable and has many deprecated methods.
 Calendar makes accessing 'normal' dates difficult, due to the lack of simple methods.
-Calendar also has some strange performance characteristics. 
-</p>
-
-<p>
-The Joda Dates project seeks to provide an implementation of dates and times for the Java community.
-The 'default' calendar system implemented will be the ISO8601 standard.
-This specifies a framework for date and time independent of locale.
-Thus, in the standard, the first day of the week is Monday, and this has the index 1.
-This avoids any ambiguity across national boundaries.
-</p>
-
-<p>
-Additional calendar systems supported are Gregorian, Julian, GregorianJulian (GJ), Buddhist and Coptic.
-The design is flexible and pluggable, so adding additional calendar systems should be easy. 
+It also has some strange performance characteristics as it recalculates fields at unexpected moments.
 </p>
 
 <p>
diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
index e9085855d..c5895b61c 100644
--- a/JodaTime/xdocs/navigation.xml
+++ b/JodaTime/xdocs/navigation.xml
@@ -12,7 +12,7 @@
       <item name="FAQ" href="/faq.html"/>
       <item name="Javadoc (Release)" href="/api-0.95/index.html"/>
       <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
-      <item name="Test results" href="/junit-report.html"/>
+      <!--item name="Test results" href="/junit-report.html"/-->
       <item name="Mailing lists" href="/mail-lists.html"/>
       <item name="Tasks" href="/tasks.html"/>
       <item name="License" href="/license.html"/>
@@ -20,6 +20,17 @@
       <item name="Javadoc (CVS)" href="/apidocs/index.html"/>
     </menu>
     
+    <menu name="Chronologies">
+      <item name="ISO8601" href="/cal_iso.html"/>
+      <item name="GregorianJulian" href="/cal_gj.html"/>
+      <!--
+      <item name="Gregorian" href="/cal_gregorian.html"/>
+      <item name="Julian" href="/cal_julian.html"/>
+      <item name="Buddhist" href="/cal_buddhist.html"/>
+      <item name="Coptic" href="/cal_coptic.html"/>
+      -->
+    </menu>
+    
     <menu name="Joda">
       <item name="Joda home" href="http://joda.sourceforge.net"/>
       <item name="Beans" href="http://joda.sourceforge.net/beans.html"/>
diff --git a/JodaTime/xdocs/tasks.xml b/JodaTime/xdocs/tasks.xml
index 0c777a446..7a21be8b9 100644
--- a/JodaTime/xdocs/tasks.xml
+++ b/JodaTime/xdocs/tasks.xml
@@ -3,7 +3,7 @@
 <document>
 
  <properties>
-  <title>Joda Time - tasks outstanding</title>
+  <title>Java date and time API - Tasks outstanding</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
  </properties>
 
diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index 5bf9f1871..e28f61c7e 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -3,7 +3,7 @@
 <document>
 
  <properties>
-  <title>Users Guide</title>
+  <title>Java date and time API - Users guide</title>
   <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
  </properties>
 
@@ -31,8 +31,8 @@ to split the time, stored in milliseconds, into a recognisable fields like 'day
 The current chronologies supplied are:
 </p>
 <ul>
-<li>ISOChronology - Implements the ISO8601 standard, which is compatible with Gregorian in modern times.</li>
-<li>GJChronology - The Gregorian/Julian calendar system, for historical use.</li>
+<li><a href="cal_iso.html">ISOChronology</a> - Implements the ISO8601 standard, which is compatible with Gregorian in modern times.</li>
+<li><a href="cal_gj.html">GJChronology</a> - The Gregorian/Julian calendar system, for historical use.</li>
 <li>BuddhistChronology - Offset from Gregorian/Julian by 543 years.</li>
 <li>CopticChronology - Offset from Gregorian/Julian by 284 years.</li>
 </ul>

From b036d68c0828511274034c363c2a5c7a90c6bf06 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 5 Mar 2004 03:13:25 +0000
Subject: [PATCH 0012/1934] Minor comment typo.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@161 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDuration.java | 8 ++++----
 JodaTime/src/java/org/joda/time/ReadableDuration.java | 8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index 160e7878b..3273e71b5 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -405,7 +405,7 @@ private int updateTotalMillis() {
      * Adds this duration to the given instant, returning a new value.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
      * duration to
@@ -421,7 +421,7 @@ public final long addTo(long instant, int scalar) {
      * Adds this duration to the given instant, returning a new value.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
      * duration to
@@ -487,7 +487,7 @@ private static int scaleValue(int value, int scalar) {
      * Adds this duration to the given instant, returning a new Instant.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the instant to add the duration to
      * @param scalar  the number of times to add the duration, negative to subtract
@@ -503,7 +503,7 @@ public final ReadableInstant addTo(ReadableInstant instant, int scalar) {
      * Adds this duration into the given mutable instant.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the instant to update with the added duration
      * @param scalar  the number of times to add the duration, negative to subtract
diff --git a/JodaTime/src/java/org/joda/time/ReadableDuration.java b/JodaTime/src/java/org/joda/time/ReadableDuration.java
index 79336d716..5d182015f 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java
@@ -107,7 +107,7 @@
      * Adds this duration to the given instant, returning a new value.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
      * duration to
@@ -121,7 +121,7 @@
      * Adds this duration to the given instant, returning a new value.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
      * duration to
@@ -136,7 +136,7 @@
      * Adds this duration to the given instant, returning a new Instant.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the instant to add the duration to
      * @param scalar  the number of times to add the duration, negative to subtract
@@ -150,7 +150,7 @@
      * Adds this duration into the given mutable instant.
      * <p>
      * To add just once, pass in a scalar of one. To subtract once, pass
-     * in a scaler of minus one.
+     * in a scalar of minus one.
      *
      * @param instant  the instant to update with the added duration
      * @param scalar  the number of times to add the duration, negative to subtract

From 29ae347c15b45eca15a642f483a1f08a37c3f166 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 7 Mar 2004 05:16:44 +0000
Subject: [PATCH 0013/1934] Removed comments about exceptions which are no
 longer thrown.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@162 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDateTime.java | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index bc32ed491..e04dc7ba4 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -591,7 +591,6 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
      *
      * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
      * instant to
-     * @throws IllegalArgumentException if the value is invalid
      */
     protected void setMillis(long instant) {
         iMillis = instant;
@@ -625,7 +624,6 @@ protected void setMillis(Object instant) {
      * all lower subclasses are also immutable.
      * 
      * @param chronology  the chronology to use, null means ISOChronology in default zone
-     * @throws IllegalArgumentException if the value is invalid
      */
     protected void setChronology(Chronology chronology) {
         iChronology = selectChronology(chronology);
@@ -636,7 +634,6 @@ protected void setChronology(Chronology chronology) {
      * zone does not affect the millisecond value of this instant.
      *
      * @param zone  the time zone to use, null means default zone
-     * @throws IllegalArgumentException if the value is invalid
      * @see #moveDateTimeZone
      */
     protected void setDateTimeZone(DateTimeZone zone) {
@@ -656,7 +653,6 @@ protected void setDateTimeZone(DateTimeZone zone) {
      * relative to the new time zone.
      *
      * @param zone  the time zone to use, null means default zone
-     * @throws IllegalArgumentException if the value is invalid
      * @see #setDateTimeZone
      */
     protected void moveDateTimeZone(DateTimeZone zone) {

From d512ea4873cce39d2289940fe379aa63562a6ef3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 7 Mar 2004 05:17:34 +0000
Subject: [PATCH 0014/1934] Added withDateTimeZoneMoved method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@163 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInstant.java   | 57 +++++++++++++++++--
 JodaTime/src/java/org/joda/time/Instant.java  | 11 ++++
 .../java/org/joda/time/ReadableInstant.java   | 41 +++++++++----
 3 files changed, 93 insertions(+), 16 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index a5e12ad7f..d3d08ba42 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -86,7 +86,8 @@ protected AbstractInstant() {
     }
 
     /**
-     * Gets the time zone of the datetime from the chronology.
+     * Gets the time zone of the datetime from the chronology, or null if there
+     * isn't any chronology.
      * 
      * @return the DateTimeZone that the datetime is using
      */
@@ -119,7 +120,8 @@ public final int get(DateTimeField field) {
     }
 
     /**
-     * Gets a copy of this instant with a different time zone.
+     * Gets a copy of this instant with a different time zone, preserving the
+     * millisecond instant.
      * <p>
      * The returned object will be a new instance of the same implementation
      * type. Only the time zone of the chronology will change, the millis are
@@ -127,12 +129,55 @@ public final int get(DateTimeField field) {
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
+     * @see #withDateTimeZoneMoved
      */
     public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
-        Chronology newChronology = getChronology();
-        newChronology = newChronology == null ? ISOChronology.getInstance(newDateTimeZone)
-            : newChronology.withDateTimeZone(newDateTimeZone);
-        return withChronology(newChronology);
+        final Chronology originalChrono = getChronology();
+        if (originalChrono == null) {
+            // Without an original chronology, no new time zone can be
+            // set. Call withMillis to allow subclass to decide if a clone
+            // should be made or not.
+            return withMillis(getMillis());
+        }
+        return withChronology(originalChrono.withDateTimeZone(newDateTimeZone));
+    }
+
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * field values.
+     * <p>
+     * The returned object will be a new instance of the same implementation
+     * type. Moving the time zone alters the millisecond value of this instant
+     * such that it is relative to the new time zone. Immutable subclasses may
+     * return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withDateTimeZone
+     */
+    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone) {
+        final long originalMillis = getMillis();
+        final Chronology originalChrono = getChronology();
+        final DateTimeZone originalZone;
+        if (originalChrono == null || (originalZone = originalChrono.getDateTimeZone()) == null) {
+            // Without an original chronology or time zone, no new time zone
+            // can be set. Call withMillis to allow subclass to decide if a
+            // clone should be made or not.
+            return withMillis(originalMillis);
+        }
+
+        ReadableInstant newInstant = withChronology(originalChrono.withDateTimeZone(newDateTimeZone));
+        newDateTimeZone = newInstant.getDateTimeZone();
+
+        if (newDateTimeZone == null || newDateTimeZone == originalZone) {
+            // New time zone didn't stick or didn't change. Skip millis adjustment.
+            return newInstant;
+        }
+
+        long newMillis = originalMillis + originalZone.getOffset(originalMillis);
+        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);
+
+        return newInstant.withMillis(newMillis);
     }
 
     // Conversion
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index a61560983..219ea9a05 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -161,6 +161,17 @@ public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
         return this;
     }
 
+    /**
+     * Since Instant does not support time zones, this method always returns
+     * <code>this</code>.
+     *
+     * @param newDateTimeZone  ignored
+     * @return this
+     */
+    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone) {
+        return this;
+    }
+
     // Accessors
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index a0bbea231..cb8ab96ec 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -141,11 +141,13 @@
     
     //-----------------------------------------------------------------------
     /**
-     * Gets a copy of this instant with different millis.
+     * Gets a copy of this instant with different millis, preserving the
+     * chronology.
      * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology and time zone are kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be a new instance of the same implementation
+     * type. Only the millis will change, the chronology and time zone are
+     * kept. Immutable implementations may return <code>this</code> if
+     * appropriate.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
@@ -153,11 +155,12 @@
     ReadableInstant withMillis(long newMillis);
     
     /**
-     * Gets a copy of this instant with a different chronology.
+     * Gets a copy of this instant with a different chronology, preserving the
+     * millisecond instant.
      * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be a new instance of the same implementation
+     * type. Only the chronology will change, the millis are kept. Immutable
+     * implementations may return <code>this</code> if appropriate.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
@@ -165,17 +168,35 @@
     ReadableInstant withChronology(Chronology newChronology);
     
     /**
-     * Gets a copy of this instant with a different time zone.
+     * Gets a copy of this instant with a different time zone, preserving the
+     * millisecond instant.
      * <p>
      * The returned object will be a new instance of the same implementation
      * type. Only the time zone of the chronology will change, the millis are
-     * kept. Immutable subclasses may return <code>this</code> if appropriate.
+     * kept. Immutable implementations may return <code>this</code> if
+     * appropriate.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
+     * @see #withDateTimeZoneMoved
      */
     ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone);
 
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * field values.
+     * <p>
+     * The returned object will be a new instance of the same implementation
+     * type. Moving the time zone alters the millisecond value of this instant
+     * such that it is relative to the new time zone. Immutable implementations
+     * may return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withDateTimeZone
+     */
+    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone);
+
     //-----------------------------------------------------------------------
     /**
      * Get the value as a simple immutable <code>Instant</code> object.

From 2883a11ec022e12082e48bc3077f7a9462eea5fe Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 12 Mar 2004 00:32:56 +0000
Subject: [PATCH 0015/1934] Rename getDateTime method to appropriate name

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@164 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/property/DateOnlyFieldProperty.java   | 11 +++++------
 .../joda/time/property/TimeOnlyFieldProperty.java   | 13 ++++++-------
 2 files changed, 11 insertions(+), 13 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
index 284febf98..e781ee61b 100644
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -54,10 +54,9 @@
 package org.joda.time.property;
 
 import java.util.Locale;
+
 import org.joda.time.DateOnly;
 import org.joda.time.DateTimeField;
-// Import for @link support
-import org.joda.time.MutableDateOnly;
 import org.joda.time.ReadableInstant;
 
 /**
@@ -80,7 +79,7 @@
  * DateOnly date20 = date.year().addToCopy(20);
  * </pre>
  * Serious modification of dates (ie. more than just changing one or two fields)
- * should use the {@link MutableDateOnly} class.
+ * should use the {@link org.joda.time.MutableDateOnly MutableDateOnly} class.
  * <p>
  * DateOnlyFieldPropery itself is thread-safe and immutable, as well as the
  * DateOnly being operated on.
@@ -128,11 +127,11 @@ public ReadableInstant getInstant() {
     }
 
     /**
-     * Gets the instant being used.
+     * Gets the date being used.
      * 
-     * @return the instant
+     * @return the date
      */
-    public DateOnly getDateTime() {
+    public DateOnly getDateOnly() {
         return iInstant;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
index 484b50576..528dc1f05 100644
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -54,11 +54,10 @@
 package org.joda.time.property;
 
 import java.util.Locale;
-import org.joda.time.TimeOnly;
+
 import org.joda.time.DateTimeField;
-// Import for @link support
-import org.joda.time.MutableTimeOnly;
 import org.joda.time.ReadableInstant;
+import org.joda.time.TimeOnly;
 
 /**
  * TimeOnlyFieldProperty binds a TimeOnly to a DateTimeField allowing powerful
@@ -80,7 +79,7 @@
  * TimeOnly time20 = time.minuteOfHour().addToCopy(20);
  * </pre>
  * Serious modification of times (ie. more than just changing one or two fields)
- * should use the {@link MutableTimeOnly} class.
+ * should use the {@link org.joda.time.MutableTimeOnly MutableTimeOnly} class.
  * <p>
  * TimeOnlyFieldPropery itself is thread-safe and immutable, as well as the
  * TimeOnly being operated on.
@@ -128,11 +127,11 @@ public ReadableInstant getInstant() {
     }
 
     /**
-     * Gets the instant being used.
+     * Gets the time being used.
      * 
-     * @return the instant
+     * @return the time
      */
-    public TimeOnly getDateTime() {
+    public TimeOnly getTimeOnly() {
         return iInstant;
     }
 

From 64031d91ccb1621b1f828d0f22bf654f217e52d7 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 12 Mar 2004 00:33:36 +0000
Subject: [PATCH 0016/1934] Add getDateTime method

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@165 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/property/DateTimeFieldProperty.java  | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index aa29b8cab..7463576ec 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -54,10 +54,9 @@
 package org.joda.time.property;
 
 import java.util.Locale;
+
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
-// Import for @link support
-import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
 
 /**
@@ -80,7 +79,7 @@
  * DateTime dt20 = dt.year().addToCopy(20);
  * </pre>
  * Serious modification of dates (ie. more than just changing one or two fields)
- * should use the {@link MutableDateTime} class.
+ * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.
  * <p>
  * DateTimeFieldPropery itself is thread-safe and immutable, as well as the
  * DateTime being operated on.
@@ -129,6 +128,15 @@ public ReadableInstant getInstant() {
         return iInstant;
     }
 
+    /**
+     * Gets the datetime being used.
+     * 
+     * @return the datetime
+     */
+    public DateTime getDateTime() {
+        return iInstant;
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Adds to this field in a copy of this DateTime.

From 748e13746423050a95b0a52ad3a0c01bc0851d0b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:22:17 +0000
Subject: [PATCH 0017/1934] Uses millis duration type.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@166 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/convert/LongConverter.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index ebedfc3dc..b3f236dd0 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -127,7 +127,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getAverageYearMonthType();
+        return DurationType.getMillisType();
     }
 
     //-----------------------------------------------------------------------

From 9da9df678f8b5d496b9be30d3c28cbf7d09e0792 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:46:50 +0000
Subject: [PATCH 0018/1934] Rollback to average-year-month duration type.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@167 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/convert/LongConverter.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index b3f236dd0..ebedfc3dc 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -127,7 +127,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getMillisType();
+        return DurationType.getAverageYearMonthType();
     }
 
     //-----------------------------------------------------------------------

From 1d7f4443d864c2e01b65da9512755794702bafc5 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:49:07 +0000
Subject: [PATCH 0019/1934] Cache some common types.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@168 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DurationType.java   | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 81621fdb3..485977150 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -86,13 +86,23 @@
 public abstract class DurationType implements Serializable {
     static final long serialVersionUID = 2274324892792009998L;
 
-    // TODO: Many caching opportunities
+    private static final DurationType MILLIS_TYPE;
+    private static final DurationType AVERAGE_YEAR_MONTH_TYPE;
+    private static final DurationType PRECISE_YEAR_MONTH_TYPE;
+
+    static {
+        MILLIS_TYPE = new MillisType();
+        AVERAGE_YEAR_MONTH_TYPE = new AverageYearMonthType(ISOChronology.getInstanceUTC());
+        PRECISE_YEAR_MONTH_TYPE = new PreciseYearMonthType(ISOChronology.getInstanceUTC());
+    }
+
+    // TODO: Many more caching opportunities
 
     /**
      * Returns a DurationType of only a milliseconds field.
      */
     public static DurationType getMillisType() {
-        return new MillisType();
+        return MILLIS_TYPE;
     }
 
     /**
@@ -234,7 +244,7 @@ public static DurationType getYearWeekType(Chronology chrono) {
      * </ul>
      */
     public static DurationType getAverageYearMonthType() {
-        return new AverageYearMonthType(ISOChronology.getInstanceUTC());
+        return AVERAGE_YEAR_MONTH_TYPE;
     }
 
     /**
@@ -283,7 +293,7 @@ public static DurationType getAverageYearMonthType(Chronology chrono) {
      * </ul>
      */
     public static DurationType getPreciseYearMonthType() {
-        return new PreciseYearMonthType(ISOChronology.getInstanceUTC());
+        return PRECISE_YEAR_MONTH_TYPE;
     }
 
     /**

From 815bcef8f0a668d8799ed6ade6a00de617974ad0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:51:14 +0000
Subject: [PATCH 0020/1934] Added getDuration(DurationType)

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@169 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/ReadableInterval.java | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/ReadableInterval.java b/JodaTime/src/java/org/joda/time/ReadableInterval.java
index 8dda0e298..820fa6f63 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java
@@ -116,6 +116,14 @@
      */
     Duration getDuration();
 
+    /** 
+     * Gets the duration of this time interval.
+     *
+     * @param type the requested type of the duration
+     * @return the duration of the time interval
+     */
+    Duration getDuration(DurationType type);
+
     //-----------------------------------------------------------------------
     /**
      * Does this time interval contain the specified millisecond instant.

From 08552fe8aa63614fb389469c047a39c20c9079a8 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:53:37 +0000
Subject: [PATCH 0021/1934] Added getDuration(DurationType); default duration
 type is average-year-month.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@170 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInterval.java  | 48 +++++++++++++++----
 1 file changed, 38 insertions(+), 10 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index 05a155a98..acff4c4f3 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -287,19 +287,43 @@ public final long getDurationMillis() {
     /**
      * Gets the duration of this time interval.
      * <p>
-     * The duration returned will always be precise because it is relative to
-     * a known date.
+     * The duration returned will always be precise because it is relative to a
+     * known date. If this interval was not specified with a precise duration
+     * type, then the duration type defaults to ISO average-year-month type.
      *
      * @return the duration of the time interval
      */
     public final Duration getDuration() {
         if (iDuration == null) {
-            iDuration = new Duration(DurationType.getPreciseYearMonthType(),
-                                     getEndMillis() - getStartMillis());
+            return getDuration(null);
         }
         return iDuration;
     }
 
+    /** 
+     * Gets the duration of this time interval.
+     *
+     * @param type the requested type of the duration
+     * @return the duration of the time interval
+     */
+    public final Duration getDuration(DurationType type) {
+        if (type == null) {
+            type = DurationType.getAverageYearMonthType();
+        }
+        Duration duration = iDuration;
+        if (duration == null) {
+            if (type.isPrecise()) {
+                duration = new Duration(type, getEndMillis() - getStartMillis());
+                if (type.equals(DurationType.getAverageYearMonthType())) {
+                    iDuration = duration;
+                }
+            } else {
+                duration = new Duration(type, getStartInstant(), getEndInstant());
+            }
+        }
+        return duration;
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Does this time interval contain the specified millisecond instant.
@@ -501,9 +525,11 @@ public String toString() {
      *  millisecond instant from 1970-01-01T00:00:00Z
      */
     protected void setStartMillis(long millisInstant) {
-        iStartMillis = millisInstant;
-        iStartInstant = null;
-        iDuration = null;
+        if (millisInstant != iStartMillis) {
+            iStartMillis = millisInstant;
+            iStartInstant = null;
+            iDuration = null;
+        }
     }
 
     /** 
@@ -517,9 +543,11 @@ protected void setStartMillis(long millisInstant) {
      *  millisecond instant from 1970-01-01T00:00:00Z
      */
     protected void setEndMillis(long millisInstant) {
-        iEndMillis = millisInstant;
-        iEndInstant = null;
-        iDuration = null;
+        if (millisInstant != iEndMillis) {
+            iEndMillis = millisInstant;
+            iEndInstant = null;
+            iDuration = null;
+        }
     }
 
     /**

From d7a4f53548456f7266f4b6c25f4c284099adfe8a Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 28 Mar 2004 19:55:27 +0000
Subject: [PATCH 0022/1934] Remove public modifier on method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@171 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/ReadableInstant.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index cb8ab96ec..00406322e 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -195,7 +195,7 @@
      * @return a copy of this instant with a different time zone
      * @see #withDateTimeZone
      */
-    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone);
+    ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone);
 
     //-----------------------------------------------------------------------
     /**

From 165f427e20ecc390e6705c7649725a86bd39099d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 4 Apr 2004 23:24:24 +0000
Subject: [PATCH 0023/1934] Example usages of Joda-Time

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@172 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/Examples.java       | 112 ++++++++++++++++++
 1 file changed, 112 insertions(+)
 create mode 100644 JodaTime/src/example/org/joda/example/time/Examples.java

diff --git a/JodaTime/src/example/org/joda/example/time/Examples.java b/JodaTime/src/example/org/joda/example/time/Examples.java
new file mode 100644
index 000000000..bc8acfd5b
--- /dev/null
+++ b/JodaTime/src/example/org/joda/example/time/Examples.java
@@ -0,0 +1,112 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.example.time;
+
+import java.util.Locale;
+
+import org.joda.time.Instant;
+
+/**
+ * Example code demonstrating how to use Joda-Time.
+ *
+ * @author Stephen Colebourne
+ */
+public class Examples {
+
+    public static void main(String[] args) throws Exception {
+        try {
+            new Examples().run();
+        } catch (Throwable ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private void run() {
+        runInstant();
+    }
+    
+    private void runInstant() {
+        System.out.println("Instant");
+        System.out.println("=======");
+        System.out.println("Instant stores a point in the datetime continuum as millisecs from 1970-01-01T00:00:00Z");
+        System.out.println("                       in = new Instant()");
+        Instant in = new Instant();
+        System.out.println("Millisecond time:      in.getMillis():           " + in.getMillis());
+        System.out.println("ISO string version:    in.toString():            " + in.toString());
+        System.out.println("No chronology:         in.getChronology():       " + in.getChronology());
+        System.out.println("No time zone:          in.getDateTimeZone():     " + in.getDateTimeZone());
+        System.out.println("");
+        System.out.println("Convert to DateTime:   in.toDateTime():          " + in.toDateTime());
+        System.out.println("Convert to trusted:    in.toTrustedISODateTime():" + in.toTrustedISODateTime());
+        System.out.println("Convert to MutableDT:  in.toMutableDateTime():   " + in.toMutableDateTime());
+        System.out.println("Convert to DateOnly:   in.toDateOnly():          " + in.toDateOnly());
+        System.out.println("Convert to TimeOnly:   in.toTimeOnly():          " + in.toTimeOnly());
+        System.out.println("Convert to Date:       in.toDate():              " + in.toDate());
+        System.out.println("Convert to Calendar:   in.toCalendar(Locale.UK): " + in.toCalendar(Locale.UK).toString().substring(0, 46));
+        System.out.println("Convert to GregorianC: in.toGregorianCalendar(): " + in.toGregorianCalendar().toString().substring(0, 46));
+        System.out.println("");
+        System.out.println("                       in2 = new Instant(in.getMillis() + 10)");
+        Instant in2 = new Instant(in.getMillis() + 10);
+        System.out.println("Equals ms and chrono:  in.equals(in2):           " + in.equals(in2));
+        System.out.println("Compare millisecond:   in.compareTo(in2):        " + in.compareTo(in2));
+        System.out.println("Compare millisecond:   in.isEqual(in2):          " + in.isEqual(in2));
+        System.out.println("Compare millisecond:   in.isAfter(in2):          " + in.isAfter(in2));
+        System.out.println("Compare millisecond:   in.isBefore(in2):         " + in.isBefore(in2));
+        System.out.println("");
+        System.out.println("Change chrono IGNORED: in.withChronology(...):   " + in.withChronology(null));
+        System.out.println("Change zone IGNORED:   in.withDateTimeZone(...): " + in.withDateTimeZone(null));
+        System.out.println("Change zone IGNORED:   in.withDateTimeZoneMoved(...):" + in.withDateTimeZoneMoved(null));
+        System.out.println("Change millis:         in.withMillis(0):         " + in.withMillis(0L));
+    }
+}

From 5d784a86bb1be3be98cdca42740c3096768a18ec Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 12 Apr 2004 13:49:48 +0000
Subject: [PATCH 0024/1934] Add support for changing the current time

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@173 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDateTime.java  |   6 +-
 .../org/joda/time/AbstractPartialInstant.java |   2 +-
 .../src/java/org/joda/time/DateTimeUtils.java | 169 ++++++++++++++++++
 JodaTime/src/java/org/joda/time/Instant.java  |   2 +-
 .../org/joda/time/tz/DateTimeZoneBuilder.java |   3 +-
 5 files changed, 176 insertions(+), 6 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/DateTimeUtils.java

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index e04dc7ba4..bb979c477 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -108,7 +108,7 @@ private static Chronology selectChronology(Chronology chrono) {
     protected AbstractDateTime() {
         super();
         iChronology = ISOChronology.getInstance();
-        iMillis = System.currentTimeMillis();
+        iMillis = DateTimeUtils.currentTimeMillis();
     }
 
     /**
@@ -122,7 +122,7 @@ protected AbstractDateTime() {
     protected AbstractDateTime(final DateTimeZone zone) {
         super();
         iChronology = ISOChronology.getInstance(zone);
-        iMillis = System.currentTimeMillis();
+        iMillis = DateTimeUtils.currentTimeMillis();
     }
 
     /**
@@ -137,7 +137,7 @@ protected AbstractDateTime(final DateTimeZone zone) {
     protected AbstractDateTime(final Chronology chronology) {
         super();
         iChronology = selectChronology(chronology);
-        iMillis = System.currentTimeMillis();
+        iMillis = DateTimeUtils.currentTimeMillis();
     }
 
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 9e67082f5..ec3b8270f 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -147,7 +147,7 @@ protected AbstractPartialInstant(DateTimeZone zone) {
     protected AbstractPartialInstant(final Chronology chronology) {
         iChronology = selectChronologyUTC(chronology);
         iMillis = resetUnsupportedFields
-            (toLocalTime(System.currentTimeMillis(), chronology, iChronology));
+            (toLocalTime(DateTimeUtils.currentTimeMillis(), chronology, iChronology));
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/DateTimeUtils.java b/JodaTime/src/java/org/joda/time/DateTimeUtils.java
new file mode 100644
index 000000000..62d151f3e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java
@@ -0,0 +1,169 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * DateTimeUtils provide public utility methods for the datetime library.
+ * <p>
+ * DateTimeUtils is thread-safe although shared static variables are used.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class DateTimeUtils {
+
+    /** The singleton instance of the system millisecond provider */
+    private static final SystemMillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();
+    
+    /** The millisecond provider currently in use */
+    private static MillisProvider cMillisProvider = SYSTEM_MILLIS_PROVIDER;
+
+    /**
+     * Restrictive constructor
+     */
+    protected DateTimeUtils() {
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the current time in milliseconds.
+     * <p>
+     * By default this returns <code>System.currentTimeMillis()</code>.
+     * This may be changed using other methods in this class.
+     * 
+     * @return the current time in milliseconds from 1970-01-01T00:00:00Z
+     */
+    public static long currentTimeMillis() {
+        return cMillisProvider.getMillis();
+    }
+
+    /**
+     * Resets the current time to return the system time.
+     * <p>
+     * This method changes the behaviour of {@link #currentTimeMillis()}.
+     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.
+     */
+    public static void setCurrentMillisSystem() {
+        cMillisProvider = SYSTEM_MILLIS_PROVIDER;
+    }
+
+    /**
+     * Sets the current time to return a fixed millisecond time.
+     * <p>
+     * This method changes the behaviour of {@link #currentTimeMillis()}.
+     * Whenever the current time is queried, the same millisecond time will be returned.
+     * 
+     * @param fixedMillis  the fixed millisecond time to use
+     */
+    public static void setCurrentMillisFixed(long fixedMillis) {
+        cMillisProvider = new FixedMillisProvider(fixedMillis);
+    }
+
+    /**
+     * Sets the current time to return the system time plus an offset.
+     * <p>
+     * This method changes the behaviour of {@link #currentTimeMillis()}.
+     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used
+     * and then offset by adding the millisecond value specified here.
+     * 
+     * @param offsetMillis  the fixed millisecond time to use
+     */
+    public static void setCurrentMillisOffset(long offsetMillis) {
+        cMillisProvider = new OffsetMillisProvider(offsetMillis);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Base class defining a millisecond provider.
+     */
+    static abstract class MillisProvider {
+        abstract long getMillis();
+    }
+
+    /**
+     * System millis provider.
+     */
+    static class SystemMillisProvider extends MillisProvider {
+        long getMillis() {
+            return System.currentTimeMillis();
+        }
+    }
+
+    /**
+     * Fixed millisecond provider.
+     */
+    static class FixedMillisProvider extends MillisProvider {
+        private final long iMillis;
+        FixedMillisProvider(long fixedMillis) {
+            iMillis = fixedMillis;
+        }
+        long getMillis() {
+            return iMillis;
+        }
+    }
+
+    /**
+     * Offset from system millis provider.
+     */
+    static class OffsetMillisProvider extends MillisProvider {
+        private final long iMillis;
+        OffsetMillisProvider(long offsetMillis) {
+            iMillis = offsetMillis;
+        }
+        long getMillis() {
+            return System.currentTimeMillis() + iMillis;
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 219ea9a05..fcfab9d15 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -87,7 +87,7 @@
      */
     public Instant() {
         super();
-        iMillis = System.currentTimeMillis();
+        iMillis = DateTimeUtils.currentTimeMillis();
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index 98d653bb7..3fe972ec0 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -67,6 +67,7 @@
 import java.util.Set;
 
 import org.joda.time.Chronology;
+import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
 import org.joda.time.chrono.ISOChronology;
 
@@ -933,7 +934,7 @@ public boolean isTransitionFrom(Transition other) {
             // simple DST cycle is detected or the last rule is a fixed
             // offset. If a zone has a fixed offset set more than 100 years
             // into the future, then it won't be observed.
-            long now = System.currentTimeMillis();
+            long now = DateTimeUtils.currentTimeMillis();
             YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;
         }
 

From d73d392cb525bf58e73a3c14856b3c9ed8ab4e60 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 12 Apr 2004 17:45:29 +0000
Subject: [PATCH 0025/1934] Rename moveDateTimeZone to
 withDateTimeZoneRetainFields

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@174 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInstant.java   | 27 ++++++++++-----
 .../java/org/joda/time/MutableDateOnly.java   |  2 +-
 .../java/org/joda/time/MutableDateTime.java   | 17 ++++++----
 .../java/org/joda/time/MutableTimeOnly.java   |  2 +-
 .../org/joda/time/ReadWritableInstant.java    | 33 +++++++++++--------
 .../java/org/joda/time/ReadableInstant.java   | 28 ++++++++++------
 .../org/joda/time/chrono/LimitChronology.java |  4 +--
 7 files changed, 70 insertions(+), 43 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index d3d08ba42..c398ba2f6 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -123,13 +123,18 @@ public final int get(DateTimeField field) {
      * Gets a copy of this instant with a different time zone, preserving the
      * millisecond instant.
      * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Only the time zone of the chronology will change, the millis are
-     * kept. Immutable subclasses may return <code>this</code> if appropriate.
+     * This method is useful for finding the local time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London, the result
+     * from this method with Europe/Paris would be 13:30.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone, and does not change the
+     * millisecond instant, with the effect that the field values usually change.
+     * Immutable implementations may return <code>this</code> if appropriate.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZoneMoved
+     * @see #withDateTimeZoneRetainFields
      */
     public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
         final Chronology originalChrono = getChronology();
@@ -146,16 +151,20 @@ public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
      * Gets a copy of this instant with a different time zone, preserving the
      * field values.
      * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Moving the time zone alters the millisecond value of this instant
-     * such that it is relative to the new time zone. Immutable subclasses may
-     * return <code>this</code> if appropriate.
+     * This method is useful for finding the millisecond time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone and the millisecond instant to keep
+     * the field values the same.
+     * Immutable implementations may return <code>this</code> if appropriate.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
      * @see #withDateTimeZone
      */
-    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone) {
+    public ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone) {
         final long originalMillis = getMillis();
         final Chronology originalChrono = getChronology();
         final DateTimeZone originalZone;
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index d09fae28a..72f5804c3 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -316,7 +316,7 @@ public void setDateTimeZone(DateTimeZone zone) {
      *
      * @param zone  ignored
      */
-    public void moveDateTimeZone(DateTimeZone zone) {
+    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
     }
 
     // Add
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 40b486874..7044655fc 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -426,30 +426,35 @@ public void setChronology(Chronology chronology) {
     // Time zone
     //-----------------------------------------------------------------------
     /**
-     * Sets the time zone of the datetime, which changes the
+     * Sets the time zone of the datetime, changing the chronology and field values.
+     * <p>
+     * Changing the zone using this method retains the millisecond instant.
+     * The millisecond instant is adjusted in the new zone to compensate.
+     * 
      * chronology. Setting the time zone does not affect the millisecond value
      * of this instant.
      * <p>
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #moveDateTimeZone
+     * @see #setDateTimeZoneRetainFields
      */
     public void setDateTimeZone(DateTimeZone zone) {
         super.setDateTimeZone(zone);
     }
 
     /**
-     * Moves the time zone of the datetime, which changes the
-     * chronology. Moving the time zone alters the millisecond value of this
-     * instant such that it is relative to the new time zone.
+     * Sets the time zone of the datetime, changing the chronology and millisecond.
+     * <p>
+     * Changing the zone using this method retains the field values.
+     * The millisecond instant is adjusted in the new zone to compensate.
      * <p>
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
      * @see #setDateTimeZone
      */
-    public void moveDateTimeZone(DateTimeZone zone) {
+    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
         super.moveDateTimeZone(zone);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index 79ede70c4..3224d7b7f 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -322,7 +322,7 @@ public void setDateTimeZone(DateTimeZone zone) {
      *
      * @param zone  ignored
      */
-    public void moveDateTimeZone(DateTimeZone zone) {
+    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
     }
 
     // Add
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index 6b6d5225f..d0150bcaa 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -53,9 +53,6 @@
  */
 package org.joda.time;
 
-// Import for @link support
-import org.joda.time.convert.ConverterManager;
-
 /**
  * Defines an instant in the datetime continuum that can be queried and modified.
  * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.
@@ -81,7 +78,8 @@
     /**
      * Set the value from an Object representing an instant.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      * 
      * @param instant  an object representing an instant
@@ -99,26 +97,33 @@
     void setChronology(Chronology chronology);
 
     /**
-     * Sets the time zone of the datetime via the chronology, which has no
-     * effect if not applicable. Setting the time zone does not affect the
-     * millisecond value of this instant.
+     * Sets the time zone of the datetime, changing the chronology and field values.
+     * <p>
+     * Changing the zone using this method retains the millisecond instant.
+     * The millisecond instant is adjusted in the new zone to compensate.
+     * 
+     * chronology. Setting the time zone does not affect the millisecond value
+     * of this instant.
+     * <p>
+     * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @throws IllegalArgumentException if the value is invalid
-     * @see #moveDateTimeZone
+     * @see #setDateTimeZoneRetainFields
      */
     void setDateTimeZone(DateTimeZone zone);
 
     /**
-     * Moves the time zone of the datetime via the chronology, which has no
-     * effect if not applicable. Moving the time zone alters the millisecond
-     * value of this instant such that it is relative to the new time zone.
+     * Sets the time zone of the datetime, changing the chronology and millisecond.
+     * <p>
+     * Changing the zone using this method retains the field values.
+     * The millisecond instant is adjusted in the new zone to compensate.
+     * <p>
+     * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @throws IllegalArgumentException if the value is invalid
      * @see #setDateTimeZone
      */
-    void moveDateTimeZone(DateTimeZone zone);
+    void setDateTimeZoneRetainFields(DateTimeZone zone);
 
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 00406322e..8d3ddaeae 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -171,14 +171,18 @@
      * Gets a copy of this instant with a different time zone, preserving the
      * millisecond instant.
      * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Only the time zone of the chronology will change, the millis are
-     * kept. Immutable implementations may return <code>this</code> if
-     * appropriate.
+     * This method is useful for finding the local time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London, the result
+     * from this method with Europe/Paris would be 13:30.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone, and does not change the
+     * millisecond instant, with the effect that the field values usually change.
+     * Immutable implementations may return <code>this</code> if appropriate.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZoneMoved
+     * @see #withDateTimeZoneRetainFields
      */
     ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone);
 
@@ -186,16 +190,20 @@
      * Gets a copy of this instant with a different time zone, preserving the
      * field values.
      * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Moving the time zone alters the millisecond value of this instant
-     * such that it is relative to the new time zone. Immutable implementations
-     * may return <code>this</code> if appropriate.
+     * This method is useful for finding the millisecond time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone and the millisecond instant to keep
+     * the field values the same.
+     * Immutable implementations may return <code>this</code> if appropriate.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
      * @see #withDateTimeZone
      */
-    ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone);
+    ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone);
 
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index 1d9676231..dc6260fa4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -186,14 +186,14 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         DateTime lowerLimit = iLowerLimit;
         if (lowerLimit != null) {
             MutableDateTime mdt = lowerLimit.toMutableDateTime();
-            mdt.moveDateTimeZone(zone);
+            mdt.setDateTimeZoneRetainFields(zone);
             lowerLimit = mdt.toDateTime();
         }
 
         DateTime upperLimit = iUpperLimit;
         if (upperLimit != null) {
             MutableDateTime mdt = upperLimit.toMutableDateTime();
-            mdt.moveDateTimeZone(zone);
+            mdt.setDateTimeZoneRetainFields(zone);
             upperLimit = mdt.toDateTime();
         }
         

From 6f9be0d1458cc621474bd5f371c617ddcd466195 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 12 Apr 2004 19:16:51 +0000
Subject: [PATCH 0026/1934] Change hashcode definition to enable compatability
 with java.util.Date

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@175 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractInstant.java | 11 ++++-------
 JodaTime/src/java/org/joda/time/ReadableInstant.java | 10 +++++-----
 2 files changed, 9 insertions(+), 12 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index c398ba2f6..2ac8cca6a 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -582,17 +582,14 @@ public boolean equals(Object readableInstant) {
     }
 
     /**
-     * Gets a hash code for the instant that is compatable with the 
-     * equals method.
+     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.
      *
      * @return a suitable hash code
      */
     public int hashCode() {
-        // following rules in [Bloch02]
-        int result = 317;
-        result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));
-        result = 59 * result + (getChronology() == null ? 0 : getChronology().hashCode());
-        return result;
+        return
+            ((int) (getMillis() ^ (getMillis() >>> 32))) +
+            (getChronology() == null ? 0 : getChronology().hashCode());
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 8d3ddaeae..2ac422bb0 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -234,14 +234,14 @@
     boolean equals(Object readableInstant);
 
     /**
-     * Gets a hash code for the instant that is compatable with the 
+     * Gets a hash code for the instant that is compatible with the 
      * equals method.
      * <p>
      * The formula used must be as follows:
-     * <pre>int result = 317;
-     * result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));
-     * result = 59 * result + (getChronology() == null ? 0 : getChronology().hashCode());
-     * return result;</pre>
+     * <pre>
+     * ((int) (getMillis() ^ (getMillis() >>> 32))) +
+     * (getChronology() == null ? 0 : getChronology().hashCode())
+     * </pre>
      *
      * @return a hash code as defined above
      */

From 23a2a953abda83eb12eb55909eceae5e32997637 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 12 Apr 2004 19:28:22 +0000
Subject: [PATCH 0027/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@176 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/ReadWritableInstant.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index d0150bcaa..e5a7be8a1 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -167,7 +167,8 @@
      * If the resulting value is too large for the implementation,
      * an exception is thrown.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableDuration, String and Long.
      *
      * @param duration  an object representing a duration

From a26563f0cd1fbdd5587a0f9d3c0c77864553d737 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 14 Apr 2004 23:43:07 +0000
Subject: [PATCH 0028/1934] Rename getDateTimeZone methods to getZone etc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@177 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/Examples.java       |  6 +--
 .../java/org/joda/time/AbstractDateTime.java  | 12 ++---
 .../java/org/joda/time/AbstractInstant.java   | 44 +++++++++----------
 .../org/joda/time/AbstractPartialInstant.java |  8 ++--
 .../src/java/org/joda/time/Chronology.java    |  4 +-
 .../src/java/org/joda/time/DateTimeZone.java  |  8 ++--
 JodaTime/src/java/org/joda/time/Instant.java  |  4 +-
 .../java/org/joda/time/MutableDateOnly.java   |  4 +-
 .../java/org/joda/time/MutableDateTime.java   | 10 ++---
 .../java/org/joda/time/MutableTimeOnly.java   |  4 +-
 .../org/joda/time/ReadWritableInstant.java    |  8 ++--
 .../java/org/joda/time/ReadableInstant.java   | 10 ++---
 .../joda/time/chrono/AbstractChronology.java  |  4 +-
 .../time/chrono/AbstractGJChronology.java     |  6 +--
 .../joda/time/chrono/AssembledChronology.java |  4 +-
 .../joda/time/chrono/BuddhistChronology.java  |  8 ++--
 .../joda/time/chrono/CopticChronology.java    |  6 +--
 .../org/joda/time/chrono/GJChronology.java    | 14 +++---
 .../joda/time/chrono/GregorianChronology.java |  6 +--
 .../org/joda/time/chrono/ISOChronology.java   | 12 ++---
 .../joda/time/chrono/JulianChronology.java    |  6 +--
 .../joda/time/chrono/LenientChronology.java   |  8 ++--
 .../org/joda/time/chrono/LimitChronology.java | 16 +++----
 .../joda/time/chrono/StrictChronology.java    |  8 ++--
 .../org/joda/time/chrono/ZonedChronology.java | 14 +++---
 .../time/convert/PartialInstantConverter.java |  4 +-
 .../convert/ReadableInstantConverter.java     |  4 +-
 .../format/AbstractDateTimeFormatter.java     | 24 +++++-----
 .../time/format/DateTimeFormatterBuilder.java |  8 ++--
 .../time/format/DateTimeParserBucket.java     |  6 +--
 .../src/java/org/joda/time/tz/Provider.java   |  2 +-
 .../java/org/joda/time/tz/UTCProvider.java    |  2 +-
 .../org/joda/time/tz/ZoneInfoProvider.java    |  6 +--
 .../test/time/TestBuddhistChronology.java     |  4 +-
 .../test/org/joda/test/time/TestParseISO.java |  2 +-
 .../test/time/chrono/gj/TestGJChronology.java |  4 +-
 36 files changed, 150 insertions(+), 150 deletions(-)

diff --git a/JodaTime/src/example/org/joda/example/time/Examples.java b/JodaTime/src/example/org/joda/example/time/Examples.java
index bc8acfd5b..f139b1fc3 100644
--- a/JodaTime/src/example/org/joda/example/time/Examples.java
+++ b/JodaTime/src/example/org/joda/example/time/Examples.java
@@ -85,7 +85,7 @@ private void runInstant() {
         System.out.println("Millisecond time:      in.getMillis():           " + in.getMillis());
         System.out.println("ISO string version:    in.toString():            " + in.toString());
         System.out.println("No chronology:         in.getChronology():       " + in.getChronology());
-        System.out.println("No time zone:          in.getDateTimeZone():     " + in.getDateTimeZone());
+        System.out.println("No time zone:          in.getDateTimeZone():     " + in.getZone());
         System.out.println("");
         System.out.println("Convert to DateTime:   in.toDateTime():          " + in.toDateTime());
         System.out.println("Convert to trusted:    in.toTrustedISODateTime():" + in.toTrustedISODateTime());
@@ -105,8 +105,8 @@ private void runInstant() {
         System.out.println("Compare millisecond:   in.isBefore(in2):         " + in.isBefore(in2));
         System.out.println("");
         System.out.println("Change chrono IGNORED: in.withChronology(...):   " + in.withChronology(null));
-        System.out.println("Change zone IGNORED:   in.withDateTimeZone(...): " + in.withDateTimeZone(null));
-        System.out.println("Change zone IGNORED:   in.withDateTimeZoneMoved(...):" + in.withDateTimeZoneMoved(null));
+        System.out.println("Change zone IGNORED:   in.withZone(...):         " + in.withZone(null));
+        System.out.println("Change zone IGNORED:   in.withZoneRetainFields(...):" + in.withZoneRetainFields(null));
         System.out.println("Change millis:         in.withMillis(0):         " + in.withMillis(0L));
     }
 }
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index bb979c477..afe51c1f7 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -636,14 +636,14 @@ protected void setChronology(Chronology chronology) {
      * @param zone  the time zone to use, null means default zone
      * @see #moveDateTimeZone
      */
-    protected void setDateTimeZone(DateTimeZone zone) {
+    protected void setZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (iChronology.getDateTimeZone() != zone) {
+        if (iChronology.getZone() != zone) {
             // Don't set iChronology directly, as it may provide a backdoor to
             // immutable subclasses.
-            setChronology(iChronology.withDateTimeZone(zone));
+            setChronology(iChronology.withZone(zone));
         }
     }
 
@@ -653,20 +653,20 @@ protected void setDateTimeZone(DateTimeZone zone) {
      * relative to the new time zone.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #setDateTimeZone
+     * @see #setZone
      */
     protected void moveDateTimeZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        DateTimeZone currentZone = iChronology.getDateTimeZone();
+        DateTimeZone currentZone = iChronology.getZone();
         if (currentZone != zone) {
             long millis = iMillis;
             millis += currentZone.getOffset(millis);
             millis -= zone.getOffsetFromLocal(millis);
             // Don't set iChronology and iMillis directly, as it may provide a
             // backdoor to immutable subclasses.
-            setChronology(iChronology.withDateTimeZone(zone));
+            setChronology(iChronology.withZone(zone));
             setMillis(millis);
         }
     }
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 2ac8cca6a..4f56f0431 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -91,9 +91,9 @@ protected AbstractInstant() {
      * 
      * @return the DateTimeZone that the datetime is using
      */
-    public final DateTimeZone getDateTimeZone() {
+    public final DateTimeZone getZone() {
         Chronology chrono = getChronology();
-        return (chrono != null ? chrono.getDateTimeZone() : null);
+        return (chrono != null ? chrono.getZone() : null);
     }
 
     // Accessors
@@ -134,9 +134,9 @@ public final int get(DateTimeField field) {
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZoneRetainFields
+     * @see #withZoneRetainFields
      */
-    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
+    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {
         final Chronology originalChrono = getChronology();
         if (originalChrono == null) {
             // Without an original chronology, no new time zone can be
@@ -144,7 +144,7 @@ public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
             // should be made or not.
             return withMillis(getMillis());
         }
-        return withChronology(originalChrono.withDateTimeZone(newDateTimeZone));
+        return withChronology(originalChrono.withZone(newDateTimeZone));
     }
 
     /**
@@ -162,21 +162,21 @@ public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZone
+     * @see #withZone
      */
-    public ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone) {
+    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {
         final long originalMillis = getMillis();
         final Chronology originalChrono = getChronology();
         final DateTimeZone originalZone;
-        if (originalChrono == null || (originalZone = originalChrono.getDateTimeZone()) == null) {
+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {
             // Without an original chronology or time zone, no new time zone
             // can be set. Call withMillis to allow subclass to decide if a
             // clone should be made or not.
             return withMillis(originalMillis);
         }
 
-        ReadableInstant newInstant = withChronology(originalChrono.withDateTimeZone(newDateTimeZone));
-        newDateTimeZone = newInstant.getDateTimeZone();
+        ReadableInstant newInstant = withChronology(originalChrono.withZone(newDateTimeZone));
+        newDateTimeZone = newInstant.getZone();
 
         if (newDateTimeZone == null || newDateTimeZone == originalZone) {
             // New time zone didn't stick or didn't change. Skip millis adjustment.
@@ -236,7 +236,7 @@ public final DateTime toDateTime(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (this instanceof DateTime && getDateTimeZone() == zone) {
+        if (this instanceof DateTime && getZone() == zone) {
             return (DateTime) this;
         }
         return new DateTime(this, zone);
@@ -269,11 +269,11 @@ public final DateTime toDateTime(ReadableInstant base) {
         if (base == null) {
             return new DateTime(this);
         }
-        DateTimeZone zone = base.getDateTimeZone();
+        DateTimeZone zone = base.getZone();
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        return new DateTime(getMillis(base), getChronology().withDateTimeZone(zone));
+        return new DateTime(getMillis(base), getChronology().withZone(zone));
     }
 
     /**
@@ -291,7 +291,7 @@ public final DateTime toDateTime(ReadableInstant base, DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        return new DateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));
+        return new DateTime(getMillis(base, zone), getChronology().withZone(zone));
     }
 
     /**
@@ -309,7 +309,7 @@ public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        return new DateTime(getMillis(base, chronology.getDateTimeZone()), chronology);
+        return new DateTime(getMillis(base, chronology.getZone()), chronology);
     }
 
     /**
@@ -327,7 +327,7 @@ public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {
      * no matching trusted time zone can be found.
      */
     public final DateTime toTrustedISODateTime() {
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         if (zone == null) {
             return new DateTime(this, (Chronology)null);
         }
@@ -393,11 +393,11 @@ public final MutableDateTime toMutableDateTime(ReadableInstant base) {
         if (base == null) {
             return new MutableDateTime(this);
         }
-        DateTimeZone zone = base.getDateTimeZone();
+        DateTimeZone zone = base.getZone();
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        return new MutableDateTime(getMillis(base), getChronology().withDateTimeZone(zone));
+        return new MutableDateTime(getMillis(base), getChronology().withZone(zone));
     }
 
     /**
@@ -415,7 +415,7 @@ public final MutableDateTime toMutableDateTime(ReadableInstant base, DateTimeZon
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        return new MutableDateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));
+        return new MutableDateTime(getMillis(base, zone), getChronology().withZone(zone));
     }
 
     /**
@@ -433,7 +433,7 @@ public final MutableDateTime toMutableDateTime(ReadableInstant base, Chronology
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        return new MutableDateTime(getMillis(base, chronology.getDateTimeZone()), chronology);
+        return new MutableDateTime(getMillis(base, chronology.getZone()), chronology);
     }
 
     /**
@@ -519,7 +519,7 @@ public final Calendar toCalendar(Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         Calendar cal;
         if (zone == null) {
             cal = Calendar.getInstance(locale);
@@ -536,7 +536,7 @@ public final Calendar toCalendar(Locale locale) {
      * @return a GregorianCalendar initialised with this datetime
      */
     public final GregorianCalendar toGregorianCalendar() {
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         GregorianCalendar cal;
         if (zone == null) {
             cal = new GregorianCalendar();
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index ec3b8270f..1ed6fa44c 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -87,7 +87,7 @@
      */
     private static long toLocalTime(long instant, Chronology original, Chronology chronoUTC) {
         if (original != chronoUTC) {
-            DateTimeZone zone = original.getDateTimeZone();
+            DateTimeZone zone = original.getZone();
             if (zone != null) {
                 instant += zone.getOffset(instant);
             }
@@ -107,7 +107,7 @@ private static Chronology selectChronologyUTC(final Chronology chronology) {
             if (utc != null) {
                 return utc;
             }
-            DateTimeZone zone = chronology.getDateTimeZone();
+            DateTimeZone zone = chronology.getZone();
             if (zone == null || zone == DateTimeZone.UTC) {
                 return chronology;
             }
@@ -232,7 +232,7 @@ public final long getMillis(ReadableInstant base) {
         if (base == null || isMatchingType(base)) {
             return getMillis();
         }
-        return getMillis(base, base.getDateTimeZone());
+        return getMillis(base, base.getZone());
     }
 
     /**
@@ -253,7 +253,7 @@ public final long getMillis(ReadableInstant base, DateTimeZone zone) {
         long millis = getMillis();
         long baseMillis = base.getMillis();
 
-        DateTimeZone baseZone = base.getDateTimeZone();
+        DateTimeZone baseZone = base.getZone();
         if (baseZone != null) {
             // Strip zone from base such that sum can be performed.
             baseMillis += baseZone.getOffset(baseMillis);
diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index 987c4609b..16054f151 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -84,7 +84,7 @@
      *
      * @return DateTimeZone null if unspecified
      */
-    DateTimeZone getDateTimeZone();
+    DateTimeZone getZone();
 
     /**
      * Returns an instance of this Chronology that operates in the UTC time
@@ -102,7 +102,7 @@
      * @param zone to use, or default if null
      * @see org.joda.time.chrono.ZonedChronology
      */
-    Chronology withDateTimeZone(DateTimeZone zone);
+    Chronology withZone(DateTimeZone zone);
 
     /**
      * Returns a date-only millisecond instant, by clearing the time fields
diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index ed21befc6..13714c1fd 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -204,7 +204,7 @@ public static DateTimeZone getInstance(String id) throws IllegalArgumentExceptio
         if (id.equals("UTC")) {
             return DateTimeZone.UTC;
         }
-        DateTimeZone zone = cProvider.getDateTimeZone(id);
+        DateTimeZone zone = cProvider.getZone(id);
         if (zone != null) {
             return zone;
         }
@@ -241,8 +241,8 @@ public static DateTimeZone getInstance(java.util.TimeZone zone) {
         DateTimeZone dtz;
         // Convert from old alias before consulting provider since they may differ.
         String convId = getConvertedId(id);
-        if (convId == null || (dtz = cProvider.getDateTimeZone(convId)) == null) {
-            dtz = cProvider.getDateTimeZone(id);
+        if (convId == null || (dtz = cProvider.getZone(convId)) == null) {
+            dtz = cProvider.getZone(id);
         }
         if (dtz != null) {
             return dtz;
@@ -325,7 +325,7 @@ private static void setProvider0(Provider provider) {
         if (!ids.contains("UTC")) {
             throw new IllegalArgumentException("The provider doesn't support UTC");
         }
-        if (!UTC.equals(provider.getDateTimeZone("UTC"))) {
+        if (!UTC.equals(provider.getZone("UTC"))) {
             throw new IllegalArgumentException("Invalid UTC zone provided");
         }
         cProvider = provider;
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index fcfab9d15..9e6bc1af8 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -157,7 +157,7 @@ public ReadableInstant withChronology(Chronology newChronology) {
      * @param newDateTimeZone  ignored
      * @return this
      */
-    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
+    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {
         return this;
     }
 
@@ -168,7 +168,7 @@ public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
      * @param newDateTimeZone  ignored
      * @return this
      */
-    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone) {
+    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {
         return this;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index 72f5804c3..c1591a518 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -308,7 +308,7 @@ public void setChronology(Chronology chronology) {
      *
      * @param zone  ignored
      */
-    public void setDateTimeZone(DateTimeZone zone) {
+    public void setZone(DateTimeZone zone) {
     }
 
     /**
@@ -316,7 +316,7 @@ public void setDateTimeZone(DateTimeZone zone) {
      *
      * @param zone  ignored
      */
-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
+    public void setZoneRetainFields(DateTimeZone zone) {
     }
 
     // Add
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 7044655fc..8bdb406e3 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -437,10 +437,10 @@ public void setChronology(Chronology chronology) {
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #setDateTimeZoneRetainFields
+     * @see #setZoneRetainFields
      */
-    public void setDateTimeZone(DateTimeZone zone) {
-        super.setDateTimeZone(zone);
+    public void setZone(DateTimeZone zone) {
+        super.setZone(zone);
     }
 
     /**
@@ -452,9 +452,9 @@ public void setDateTimeZone(DateTimeZone zone) {
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #setDateTimeZone
+     * @see #setZone
      */
-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
+    public void setZoneRetainFields(DateTimeZone zone) {
         super.moveDateTimeZone(zone);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index 3224d7b7f..1a012a4e9 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -314,7 +314,7 @@ public void setChronology(Chronology chronology) {
      *
      * @param zone  ignored
      */
-    public void setDateTimeZone(DateTimeZone zone) {
+    public void setZone(DateTimeZone zone) {
     }
 
     /**
@@ -322,7 +322,7 @@ public void setDateTimeZone(DateTimeZone zone) {
      *
      * @param zone  ignored
      */
-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {
+    public void setZoneRetainFields(DateTimeZone zone) {
     }
 
     // Add
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index e5a7be8a1..cf26c727e 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -108,9 +108,9 @@
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #setDateTimeZoneRetainFields
+     * @see #setZoneRetainFields
      */
-    void setDateTimeZone(DateTimeZone zone);
+    void setZone(DateTimeZone zone);
 
     /**
      * Sets the time zone of the datetime, changing the chronology and millisecond.
@@ -121,9 +121,9 @@
      * If the chronology already has this time zone, no change occurs.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #setDateTimeZone
+     * @see #setZone
      */
-    void setDateTimeZoneRetainFields(DateTimeZone zone);
+    void setZoneRetainFields(DateTimeZone zone);
 
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 2ac422bb0..1ad24aa44 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -124,7 +124,7 @@
      * 
      * @return the DateTimeZone, null if not applicable
      */
-    DateTimeZone getDateTimeZone();
+    DateTimeZone getZone();
 
     /**
      * Get the value of one of the fields of a datetime.
@@ -182,9 +182,9 @@
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZoneRetainFields
+     * @see #withZoneRetainFields
      */
-    ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone);
+    ReadableInstant withZone(DateTimeZone newDateTimeZone);
 
     /**
      * Gets a copy of this instant with a different time zone, preserving the
@@ -201,9 +201,9 @@
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
-     * @see #withDateTimeZone
+     * @see #withZone
      */
-    ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone);
+    ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone);
 
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
index 46c378729..9f685130f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
@@ -91,7 +91,7 @@ protected AbstractChronology() {
      *
      * @return DateTimeZone null if unspecified
      */
-    public abstract DateTimeZone getDateTimeZone();
+    public abstract DateTimeZone getZone();
 
     /**
      * Returns an instance of this Chronology that operates in the UTC time
@@ -109,7 +109,7 @@ protected AbstractChronology() {
      * @param zone to use, or default if null
      * @see org.joda.time.chrono.ZonedChronology
      */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+    public abstract Chronology withZone(DateTimeZone zone);
 
     /**
      * Returns a date-only millisecond instant, by clearing the time fields
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 325feb4f3..1e6caaba6 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -230,10 +230,10 @@
         iYearInfoCacheMask = cacheSize - 1;
     }
 
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         Chronology base;
         if ((base = getBase()) != null) {
-            return base.getDateTimeZone();
+            return base.getZone();
         }
         return DateTimeZone.UTC;
     }
@@ -350,7 +350,7 @@ public String toString() {
         }
         sb.append(name);
         sb.append('[');
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         if (zone != null) {
             sb.append(zone.getID());
             sb.append(", ");
diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
index a5b8b44e2..dd9022d15 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -138,10 +138,10 @@ protected AssembledChronology(Chronology base, Object param) {
         setFields();
     }
 
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         Chronology base;
         if ((base = iBase) != null) {
-            return base.getDateTimeZone();
+            return base.getZone();
         }
         return null;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
index 9a713dcaa..df4c4798b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
@@ -158,7 +158,7 @@ private BuddhistChronology(Chronology base, Object param) {
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getDateTimeZone());
+        return getInstance(getBase().getZone());
     }
 
     // Conversion
@@ -178,11 +178,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone);
@@ -197,7 +197,7 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
      */
     public String toString() {
         String str = "BuddhistChronology";
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         if (zone != null) {
             str = str + '[' + zone.getID() + ']';
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
index cf9e880f1..93132e19a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -200,7 +200,7 @@ public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirst
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getDateTimeZone());
+        return getInstance(getBase().getZone());
     }
 
     // Conversion
@@ -220,11 +220,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone);
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index 0bb2d8dae..c27d6b4e6 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -320,13 +320,13 @@ private GJChronology(Chronology base,
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getDateTimeZone(), iCutoverInstant, getMinimumDaysInFirstWeek());
+        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());
     }
 
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         Chronology base;
         if ((base = getBase()) != null) {
-            return base.getDateTimeZone();
+            return base.getZone();
         }
         return DateTimeZone.UTC;
     }
@@ -339,7 +339,7 @@ public DateTimeZone getDateTimeZone() {
      * @return the chronology in UTC
      */
     public Chronology withUTC() {
-        return withDateTimeZone(DateTimeZone.UTC);
+        return withZone(DateTimeZone.UTC);
     }
 
     /**
@@ -348,11 +348,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());
@@ -461,7 +461,7 @@ public String toString() {
         StringBuffer sb = new StringBuffer(60);
         sb.append("GJCutoverChronology");
         sb.append('[');
-        sb.append(getDateTimeZone().getID());
+        sb.append(getZone().getID());
         sb.append(", ");
 
         sb.append("cutover=");
diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
index 040f1b35b..46e186a39 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -182,7 +182,7 @@ private GregorianChronology(Chronology base, Object param, int minDaysInFirstWee
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getDateTimeZone());
+        return getInstance(getBase().getZone());
     }
 
     // Conversion
@@ -202,11 +202,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone);
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index b5fa448e8..91f8f167d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -134,7 +134,7 @@ public static ISOChronology getInstance(DateTimeZone zone) {
         }
         int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);
         ISOChronology chrono = cFastCache[index];
-        if (chrono != null && chrono.getDateTimeZone() == zone) {
+        if (chrono != null && chrono.getZone() == zone) {
             return chrono;
         }
         synchronized (cCache) {
@@ -175,11 +175,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone);
@@ -194,7 +194,7 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
      */
     public String toString() {
         String str = "ISOChronology";
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         if (zone != null) {
             str = str + '[' + zone.getID() + ']';
         }
@@ -202,7 +202,7 @@ public String toString() {
     }
 
     protected void assemble(Fields fields) {
-        if (getBase().getDateTimeZone() == DateTimeZone.UTC) {
+        if (getBase().getZone() == DateTimeZone.UTC) {
             // Use zero based century and year of century.
             fields.centuryOfEra = new DividedDateTimeField
                 (ISOYearOfEraDateTimeField.INSTANCE, "centuryOfEra", "centuries", 100);
@@ -218,7 +218,7 @@ protected void assemble(Fields fields) {
      * serialized size, and deserialized instances come from the cache.
      */
     private Object writeReplace() {
-        return new Stub(getDateTimeZone());
+        return new Stub(getZone());
     }
 
     private static final class Stub implements Serializable {
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
index f8d3ebe18..703e8f029 100644
--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -197,7 +197,7 @@ public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirst
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getDateTimeZone());
+        return getInstance(getBase().getZone());
     }
 
     // Conversion
@@ -217,11 +217,11 @@ public Chronology withUTC() {
      * @param zone  the zone to get the chronology in, null is default
      * @return the chronology
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
         return getInstance(zone);
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
index fbf0222d4..2854a1fd1 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -99,7 +99,7 @@ private LenientChronology(Chronology base) {
 
     public Chronology withUTC() {
         if (iWithUTC == null) {
-            if (getDateTimeZone() == DateTimeZone.UTC) {
+            if (getZone() == DateTimeZone.UTC) {
                 iWithUTC = this;
             } else {
                 iWithUTC = LenientChronology.getInstance(getBase().withUTC());
@@ -108,17 +108,17 @@ public Chronology withUTC() {
         return iWithUTC;
     }
 
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
         if (zone == DateTimeZone.UTC) {
             return withUTC();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
-        return LenientChronology.getInstance(getBase().withDateTimeZone(zone));
+        return LenientChronology.getInstance(getBase().withZone(zone));
     }
 
     protected void assemble(Fields fields) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index dc6260fa4..ca492ae82 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -90,7 +90,7 @@
 
     /**
      * Wraps another chronology, with datetime limits. When withUTC or
-     * withDateTimeZone is called, the returned LimitChronology instance has
+     * withZone is called, the returned LimitChronology instance has
      * the same limits, except they are time zone adjusted.
      *
      * @param base  base chronology to wrap
@@ -125,7 +125,7 @@ public static LimitChronology getInstance(Chronology base,
 
     /**
      * Wraps another chronology, with datetime limits. When withUTC or
-     * withDateTimeZone is called, the returned LimitChronology instance has
+     * withZone is called, the returned LimitChronology instance has
      * the same limits, except they are time zone adjusted.
      *
      * @param lowerLimit  inclusive lower limit, or null if none
@@ -163,7 +163,7 @@ public DateTime getUpperLimit() {
      * adjusted to the new time zone.
      */
     public Chronology withUTC() {
-        return withDateTimeZone(DateTimeZone.UTC);
+        return withZone(DateTimeZone.UTC);
     }
 
     /**
@@ -171,11 +171,11 @@ public Chronology withUTC() {
      * this is returned. Otherwise, a new instance is returned, with the limits
      * adjusted to the new time zone.
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
 
@@ -186,19 +186,19 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         DateTime lowerLimit = iLowerLimit;
         if (lowerLimit != null) {
             MutableDateTime mdt = lowerLimit.toMutableDateTime();
-            mdt.setDateTimeZoneRetainFields(zone);
+            mdt.setZoneRetainFields(zone);
             lowerLimit = mdt.toDateTime();
         }
 
         DateTime upperLimit = iUpperLimit;
         if (upperLimit != null) {
             MutableDateTime mdt = upperLimit.toMutableDateTime();
-            mdt.setDateTimeZoneRetainFields(zone);
+            mdt.setZoneRetainFields(zone);
             upperLimit = mdt.toDateTime();
         }
         
         LimitChronology chrono = getInstance
-            (getBase().withDateTimeZone(zone), lowerLimit, upperLimit);
+            (getBase().withZone(zone), lowerLimit, upperLimit);
 
         if (zone == DateTimeZone.UTC) {
             iWithUTC = chrono;
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
index 4e1778aca..6d55c7167 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -99,7 +99,7 @@ private StrictChronology(Chronology base) {
 
     public Chronology withUTC() {
         if (iWithUTC == null) {
-            if (getDateTimeZone() == DateTimeZone.UTC) {
+            if (getZone() == DateTimeZone.UTC) {
                 iWithUTC = this;
             } else {
                 iWithUTC = StrictChronology.getInstance(getBase().withUTC());
@@ -108,17 +108,17 @@ public Chronology withUTC() {
         return iWithUTC;
     }
 
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
         if (zone == DateTimeZone.UTC) {
             return withUTC();
         }
-        if (zone == getDateTimeZone()) {
+        if (zone == getZone()) {
             return this;
         }
-        return StrictChronology.getInstance(getBase().withDateTimeZone(zone));
+        return StrictChronology.getInstance(getBase().withZone(zone));
     }
 
     protected void assemble(Fields fields) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 6b0d9bf32..d2a22b71c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -116,7 +116,7 @@ private ZonedChronology(Chronology base, DateTimeZone zone) {
         super(base, zone);
     }
 
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         return (DateTimeZone)getParam();
     }
 
@@ -124,7 +124,7 @@ public Chronology withUTC() {
         return getBase();
     }
 
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
@@ -166,7 +166,7 @@ public long getDateTimeMillis(long instant,
         throws IllegalArgumentException
     {
         return localToUTC(getBase().getDateTimeMillis
-                          (instant + getDateTimeZone().getOffset(instant),
+                          (instant + getZone().getOffset(instant),
                            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
     }
 
@@ -184,7 +184,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @param instant instant from 1970-01-01T00:00:00 local time
      */
     private long localToUTC(long instant) {
-        DateTimeZone zone = getDateTimeZone();
+        DateTimeZone zone = getZone();
         int offset = zone.getOffsetFromLocal(instant);
         instant -= offset;
         if (offset != zone.getOffset(instant)) {
@@ -248,7 +248,7 @@ private DurationField convertField(DurationField field, HashMap converted) {
         if (converted.containsKey(field)) {
             return (DurationField)converted.get(field);
         }
-        ZonedDurationField zonedField = new ZonedDurationField(field, getDateTimeZone());
+        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());
         converted.put(field, zonedField);
         return zonedField;
     }
@@ -261,7 +261,7 @@ private DateTimeField convertField(DateTimeField field, HashMap converted) {
             return (DateTimeField)converted.get(field);
         }
         ZonedDateTimeField zonedField =
-            new ZonedDateTimeField(field, getDateTimeZone(),
+            new ZonedDateTimeField(field, getZone(),
                                    convertField(field.getDurationField(), converted),
                                    convertField(field.getRangeDurationField(), converted),
                                    convertField(field.getLeapDurationField(), converted));
@@ -270,7 +270,7 @@ private DateTimeField convertField(DateTimeField field, HashMap converted) {
     }
 
     public String toString() {
-        return "ZonedChronology[" + getBase() + ", " + getDateTimeZone().getID() + ']';
+        return "ZonedChronology[" + getBase() + ", " + getZone().getID() + ']';
     }
 
     /*
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
index aab0d2634..05f1e245c 100644
--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
@@ -117,7 +117,7 @@ public long getInstantMillis(Object object, Chronology chrono) {
         if (chrono == null) {
             zone = DateTimeZone.getDefault();
         } else {
-            zone = chrono.getDateTimeZone();
+            zone = chrono.getZone();
         }
         if (zone != null) {
             millis -= zone.getOffsetFromLocal(millis);
@@ -140,7 +140,7 @@ public Chronology getChronology(Object object) {
         if (chrono == null) {
             return ISOChronology.getInstance();
         }
-        return chrono.withDateTimeZone(DateTimeZone.getDefault());
+        return chrono.withZone(DateTimeZone.getDefault());
     }
     
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
index 6036bbd7d..9f7d303d7 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
@@ -121,9 +121,9 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
         if (chrono == null) {
             return ISOChronology.getInstance(zone);
         }
-        DateTimeZone chronoZone = chrono.getDateTimeZone();
+        DateTimeZone chronoZone = chrono.getZone();
         if (chronoZone != zone) {
-            chrono = chrono.withDateTimeZone(zone);
+            chrono = chrono.withZone(zone);
             if (chrono == null) {
                 return ISOChronology.getInstance(zone);
             }
diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
index ded726572..ecf032399 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
@@ -115,12 +115,12 @@ static String createErrorMessage(final String text, final int errorPos) {
      * Returns the DateTimeZone from the formatter's Chronology, defaulting to
      * UTC if the Chronology or its DateTimeZone is null.
      */
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         Chronology chrono = getChronology();
         if (chrono == null) {
             return DateTimeZone.UTC;
         }
-        DateTimeZone zone = chrono.getDateTimeZone();
+        DateTimeZone zone = chrono.getZone();
         return zone == null ? DateTimeZone.UTC : zone;
     }
 
@@ -128,7 +128,7 @@ public void printTo(final StringBuffer buf, final ReadableInstant instant) {
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
-            printTo(buf, millisUTC, chrono.getDateTimeZone());
+            printTo(buf, millisUTC, chrono.getZone());
         } else {
             ((DateTimePrinter)this).printTo(buf, millisUTC, null);
         }
@@ -138,7 +138,7 @@ public void printTo(final Writer out, final ReadableInstant instant) throws IOEx
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
-            printTo(out, millisUTC, chrono.getDateTimeZone());
+            printTo(out, millisUTC, chrono.getZone());
         } else {
             ((DateTimePrinter)this).printTo(out, millisUTC, null);
         }
@@ -154,7 +154,7 @@ public void printTo(final Writer out, final long instant) throws IOException {
 
     public void printTo(final StringBuffer buf, final long instant, DateTimeZone zone) {
         if (zone == null) {
-            zone = getDateTimeZone();
+            zone = getZone();
         }
         ((DateTimePrinter) this).printTo
             (buf, instant, zone, instant + zone.getOffset(instant));
@@ -162,7 +162,7 @@ public void printTo(final StringBuffer buf, final long instant, DateTimeZone zon
 
     public void printTo(final Writer out, final long instant, DateTimeZone zone) throws IOException {
         if (zone == null) {
-            zone = getDateTimeZone();
+            zone = getZone();
         }
         ((DateTimePrinter) this).printTo
             (out, instant, zone, instant + zone.getOffset(instant));
@@ -172,7 +172,7 @@ public String print(final ReadableInstant instant) {
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
-            return print(millisUTC, chrono.getDateTimeZone());
+            return print(millisUTC, chrono.getZone());
         } else {
             return print(millisUTC, null);
         }
@@ -184,7 +184,7 @@ public String print(final long instant) {
 
     public String print(final long instant, DateTimeZone zone) {
         if (zone == null) {
-            zone = getDateTimeZone();
+            zone = getZone();
         }
         return print(instant, zone, instant + zone.getOffset(instant));
     }
@@ -202,7 +202,7 @@ public int parseInto(final ReadWritableInstant instant, final String text, final
         long millis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         if (chrono != null) {
-            DateTimeZone zone = chrono.getDateTimeZone();
+            DateTimeZone zone = chrono.getZone();
             if (zone != null) {
                 // Move millis to local time.
                 millis += zone.getOffset(millis);
@@ -257,7 +257,7 @@ private long getInstantLocal(ReadableInstant instant) {
             instantLocal = 0;
         } else {
             instantLocal = instant.getMillis();
-            DateTimeZone zone = instant.getDateTimeZone();
+            DateTimeZone zone = instant.getZone();
             if (zone != null) {
                 instantLocal += zone.getOffset(instantLocal);
             }
@@ -269,9 +269,9 @@ private DateTimeParserBucket createBucket(final long millis) {
         DateTimeParserBucket bucket = new DateTimeParserBucket(millis);
         Chronology chrono = getChronology();
         if (chrono != null) {
-            DateTimeZone zone = chrono.getDateTimeZone();
+            DateTimeZone zone = chrono.getZone();
             if (zone != null) {
-                bucket.setDateTimeZone(zone);
+                bucket.setZone(zone);
             }
         }
         return bucket;
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 3fea8b244..70c785f90 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -148,7 +148,7 @@ public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {
         }
         iChrono = chrono;
         iChronoUTC = chrono.withUTC();
-        DateTimeZone zone = chrono.getDateTimeZone();
+        DateTimeZone zone = chrono.getZone();
         iLocale = locale;
         iElementPairs = new ArrayList();
     }
@@ -1826,7 +1826,7 @@ public int estimatePrintedLength() {
         public void printTo(StringBuffer buf, long instant,
                             DateTimeZone zone, long instantLocal) {
             if (zone == null) {
-                zone = getDateTimeZone();
+                zone = getZone();
             }
             if (iShortFormat) {
                 buf.append(zone.getShortName(instant, this.iLocale));
@@ -1838,7 +1838,7 @@ public void printTo(StringBuffer buf, long instant,
         public void printTo(Writer out, long instant,
                             DateTimeZone zone, long instantLocal) throws IOException {
             if (zone == null) {
-                zone = getDateTimeZone();
+                zone = getZone();
             }
             if (iShortFormat) {
                 out.write(zone.getShortName(instant, this.iLocale));
@@ -1849,7 +1849,7 @@ public void printTo(Writer out, long instant,
 
         public String print(long instant, DateTimeZone zone, long instantLocal) {
             if (zone == null) {
-                zone = getDateTimeZone();
+                zone = getZone();
             }
             if (iShortFormat) {
                 return zone.getShortName(instant, this.iLocale);
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index d44406cc2..39198c59d 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -103,7 +103,7 @@ public DateTimeParserBucket(long instantLocal) {
      * Returns the time zone used by computeMillis, or null if an offset is
      * used instead.
      */
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         return iZone;
     }
 
@@ -113,7 +113,7 @@ public DateTimeZone getDateTimeZone() {
      *
      * @param zone the date time zone to operate in, or null if UTC
      */
-    public void setDateTimeZone(DateTimeZone zone) {
+    public void setZone(DateTimeZone zone) {
         iSavedState = null;
         iZone = zone == DateTimeZone.UTC ? null : zone;
         iOffset = 0;
@@ -121,7 +121,7 @@ public void setDateTimeZone(DateTimeZone zone) {
 
     /**
      * Returns the time zone offset used by computeMillis, unless
-     * getDateTimeZone doesn't return null.
+     * getZone doesn't return null.
      */
     public int getOffset() {
         return iOffset;
diff --git a/JodaTime/src/java/org/joda/time/tz/Provider.java b/JodaTime/src/java/org/joda/time/tz/Provider.java
index c74b8d26a..16f304f2f 100644
--- a/JodaTime/src/java/org/joda/time/tz/Provider.java
+++ b/JodaTime/src/java/org/joda/time/tz/Provider.java
@@ -68,7 +68,7 @@
      *
      * @return null if not found
      */
-    DateTimeZone getDateTimeZone(String id);
+    DateTimeZone getZone(String id);
 
     /**
      * Returns an unmodifiable set of ids. All providers must at least
diff --git a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
index cc2d7bb28..99a12d1cd 100644
--- a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
@@ -69,7 +69,7 @@
      * Returns {@link DateTimeZone#UTC UTC} for <code>"UTC"</code>, null
      * otherwise.
      */
-    public DateTimeZone getDateTimeZone(String id) {
+    public DateTimeZone getZone(String id) {
         if ("UTC".equalsIgnoreCase(id)) {
             return DateTimeZone.UTC;
         }
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
index ce65aa84c..eed6594cf 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
@@ -177,7 +177,7 @@ private ZoneInfoProvider(String resourcePath,
      * called to log the error and null is returned for this and all future
      * requests.
      */
-    public synchronized DateTimeZone getDateTimeZone(String id) {
+    public synchronized DateTimeZone getZone(String id) {
         if (id == null) {
             return null;
         }
@@ -202,7 +202,7 @@ public synchronized DateTimeZone getDateTimeZone(String id) {
         }
 
         // If this point is reached, mapping must link to another.
-        return getDateTimeZone((String)obj);
+        return getZone((String)obj);
     }
 
     public synchronized Set getAvailableIDs() {
@@ -210,7 +210,7 @@ public synchronized Set getAvailableIDs() {
     }
 
     /**
-     * Called if an exception is thrown from getDateTimeZone while loading zone
+     * Called if an exception is thrown from getZone while loading zone
      * data.
      */
     protected void uncaughtException(Exception e) {
diff --git a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
index b9fc0e358..902da32e3 100644
--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
@@ -123,13 +123,13 @@ public void testGetInstanceNull() throws Exception {
         DateTimeZone zone = DateTimeZone.getDefault();
         assertNotNull(BuddhistChronology.getInstance());
         assertTrue(BuddhistChronology.getInstance() instanceof BuddhistChronology);
-        assertSame(zone, BuddhistChronology.getInstance().getDateTimeZone());
+        assertSame(zone, BuddhistChronology.getInstance().getZone());
     }
     public void testGetInstanceZone() throws Exception {
         DateTimeZone zone = DateTimeZone.getInstance("+01:00");
         assertNotNull(BuddhistChronology.getInstance(zone));
         assertTrue(BuddhistChronology.getInstance(zone) instanceof BuddhistChronology);
-        assertSame(zone, BuddhistChronology.getInstance(zone).getDateTimeZone());
+        assertSame(zone, BuddhistChronology.getInstance(zone).getZone());
     }
     public void testGetInstanceZoneUTC() throws Exception {
         assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(DateTimeZone.UTC));
diff --git a/JodaTime/src/test/org/joda/test/time/TestParseISO.java b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
index cd172ee48..eecb53608 100644
--- a/JodaTime/src/test/org/joda/test/time/TestParseISO.java
+++ b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
@@ -356,7 +356,7 @@ protected void assertDate() {
                 str = (zone < 0 ? "-" : "+") + str;
                 z = DateTimeZone.getInstance(str);
             }
-            assertEquals(msg + "\nZone: ", z, dt.getDateTimeZone());
+            assertEquals(msg + "\nZone: ", z, dt.getZone());
         }
         protected void parse(DateTimeParser p) {
             int result = p.parseInto(dt, extended, 0);
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
index eec544e9d..4bf02ae27 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
@@ -129,7 +129,7 @@ public TestGJChronology(int epochYear, int epochMonth, int epochDay) {
         iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;
     }
 
-    public DateTimeZone getDateTimeZone() {
+    public DateTimeZone getZone() {
         return null;
     }
 
@@ -140,7 +140,7 @@ public Chronology withUTC() {
     /**
      * Unsupported.
      */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
+    public Chronology withZone(DateTimeZone zone) {
         throw new UnsupportedOperationException();
     }
 

From c291d58aa5f7d15c9d3655c6f80afff651d80e33 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 14 Apr 2004 23:46:44 +0000
Subject: [PATCH 0029/1934] Rename moveDateTimeZone to setZoneRetainFields

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@178 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDateTime.java | 4 ++--
 JodaTime/src/java/org/joda/time/MutableDateTime.java  | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index afe51c1f7..78ef93664 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -634,7 +634,7 @@ protected void setChronology(Chronology chronology) {
      * zone does not affect the millisecond value of this instant.
      *
      * @param zone  the time zone to use, null means default zone
-     * @see #moveDateTimeZone
+     * @see #setZoneRetainFields
      */
     protected void setZone(DateTimeZone zone) {
         if (zone == null) {
@@ -655,7 +655,7 @@ protected void setZone(DateTimeZone zone) {
      * @param zone  the time zone to use, null means default zone
      * @see #setZone
      */
-    protected void moveDateTimeZone(DateTimeZone zone) {
+    protected void setZoneRetainFields(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 8bdb406e3..9ae8061e0 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -455,7 +455,7 @@ public void setZone(DateTimeZone zone) {
      * @see #setZone
      */
     public void setZoneRetainFields(DateTimeZone zone) {
-        super.moveDateTimeZone(zone);
+        super.setZoneRetainFields(zone);
     }
 
     // Field based

From 21a05d42260bf6fac5b1bb59d481db14e73c061c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 15 Apr 2004 23:16:54 +0000
Subject: [PATCH 0030/1934] Remove withXxx methods from ReadableInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@179 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/Examples.java       |  6 +-
 .../java/org/joda/time/AbstractDuration.java  |  4 +-
 .../java/org/joda/time/AbstractInstant.java   | 76 +--------------
 JodaTime/src/java/org/joda/time/DateOnly.java | 35 +++----
 JodaTime/src/java/org/joda/time/DateTime.java | 94 ++++++++++++++++---
 JodaTime/src/java/org/joda/time/Instant.java  | 54 +++--------
 .../java/org/joda/time/ReadableDuration.java  |  2 +-
 .../java/org/joda/time/ReadableInstant.java   | 74 +--------------
 JodaTime/src/java/org/joda/time/TimeOnly.java | 24 ++---
 9 files changed, 133 insertions(+), 236 deletions(-)

diff --git a/JodaTime/src/example/org/joda/example/time/Examples.java b/JodaTime/src/example/org/joda/example/time/Examples.java
index f139b1fc3..6d693fe9c 100644
--- a/JodaTime/src/example/org/joda/example/time/Examples.java
+++ b/JodaTime/src/example/org/joda/example/time/Examples.java
@@ -86,6 +86,7 @@ private void runInstant() {
         System.out.println("ISO string version:    in.toString():            " + in.toString());
         System.out.println("No chronology:         in.getChronology():       " + in.getChronology());
         System.out.println("No time zone:          in.getDateTimeZone():     " + in.getZone());
+        System.out.println("Change millis:         in.withMillis(0):         " + in.withMillis(0L));
         System.out.println("");
         System.out.println("Convert to DateTime:   in.toDateTime():          " + in.toDateTime());
         System.out.println("Convert to trusted:    in.toTrustedISODateTime():" + in.toTrustedISODateTime());
@@ -103,10 +104,5 @@ private void runInstant() {
         System.out.println("Compare millisecond:   in.isEqual(in2):          " + in.isEqual(in2));
         System.out.println("Compare millisecond:   in.isAfter(in2):          " + in.isAfter(in2));
         System.out.println("Compare millisecond:   in.isBefore(in2):         " + in.isBefore(in2));
-        System.out.println("");
-        System.out.println("Change chrono IGNORED: in.withChronology(...):   " + in.withChronology(null));
-        System.out.println("Change zone IGNORED:   in.withZone(...):         " + in.withZone(null));
-        System.out.println("Change zone IGNORED:   in.withZoneRetainFields(...):" + in.withZoneRetainFields(null));
-        System.out.println("Change millis:         in.withMillis(0):         " + in.withMillis(0L));
     }
 }
diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index 3273e71b5..a15fba7e6 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -495,8 +495,8 @@ private static int scaleValue(int value, int scalar) {
      * @throws IllegalArgumentException if the instant is null
      * @throws ArithmeticException if the result of the calculation is too large
      */
-    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {
-        return instant.withMillis(addTo(instant.getMillis(), scalar));
+    public final Instant addTo(ReadableInstant instant, int scalar) {
+        return new Instant(addTo(instant.getMillis(), scalar));
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 4f56f0431..7d8892b11 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -85,6 +85,8 @@ protected AbstractInstant() {
         super();
     }
 
+    // Accessors
+    //-----------------------------------------------------------------------
     /**
      * Gets the time zone of the datetime from the chronology, or null if there
      * isn't any chronology.
@@ -96,8 +98,6 @@ public final DateTimeZone getZone() {
         return (chrono != null ? chrono.getZone() : null);
     }
 
-    // Accessors
-    //-----------------------------------------------------------------------
     /**
      * Get the value of the specified field.
      * <p>
@@ -105,7 +105,7 @@ public final DateTimeZone getZone() {
      * For example:
      * <pre>
      * Instant dt = new Instant();
-     * int gjYear = dt.get(ISOChronology.getInstance().year());
+     * int gjYear = dt.get(GJChronology.getInstance().year());
      * </pre>
      * 
      * @param field  the DateTimeField subclass to use
@@ -119,76 +119,6 @@ public final int get(DateTimeField field) {
         return field.get(getMillis());
     }
 
-    /**
-     * Gets a copy of this instant with a different time zone, preserving the
-     * millisecond instant.
-     * <p>
-     * This method is useful for finding the local time in another timezone.
-     * For example, if this instant holds 12:30 in Europe/London, the result
-     * from this method with Europe/Paris would be 13:30.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone, and does not change the
-     * millisecond instant, with the effect that the field values usually change.
-     * Immutable implementations may return <code>this</code> if appropriate.
-     *
-     * @param newDateTimeZone  the new time zone
-     * @return a copy of this instant with a different time zone
-     * @see #withZoneRetainFields
-     */
-    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {
-        final Chronology originalChrono = getChronology();
-        if (originalChrono == null) {
-            // Without an original chronology, no new time zone can be
-            // set. Call withMillis to allow subclass to decide if a clone
-            // should be made or not.
-            return withMillis(getMillis());
-        }
-        return withChronology(originalChrono.withZone(newDateTimeZone));
-    }
-
-    /**
-     * Gets a copy of this instant with a different time zone, preserving the
-     * field values.
-     * <p>
-     * This method is useful for finding the millisecond time in another timezone.
-     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
-     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone and the millisecond instant to keep
-     * the field values the same.
-     * Immutable implementations may return <code>this</code> if appropriate.
-     *
-     * @param newDateTimeZone  the new time zone
-     * @return a copy of this instant with a different time zone
-     * @see #withZone
-     */
-    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {
-        final long originalMillis = getMillis();
-        final Chronology originalChrono = getChronology();
-        final DateTimeZone originalZone;
-        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {
-            // Without an original chronology or time zone, no new time zone
-            // can be set. Call withMillis to allow subclass to decide if a
-            // clone should be made or not.
-            return withMillis(originalMillis);
-        }
-
-        ReadableInstant newInstant = withChronology(originalChrono.withZone(newDateTimeZone));
-        newDateTimeZone = newInstant.getZone();
-
-        if (newDateTimeZone == null || newDateTimeZone == originalZone) {
-            // New time zone didn't stick or didn't change. Skip millis adjustment.
-            return newInstant;
-        }
-
-        long newMillis = originalMillis + originalZone.getOffset(originalMillis);
-        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);
-
-        return newInstant.withMillis(newMillis);
-    }
-
     // Conversion
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 07a6647d2..175fc6c18 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -56,8 +56,6 @@
 import java.io.Serializable;
 
 import org.joda.time.chrono.ISOChronology;
-// Import for @link support
-import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.property.DateOnlyFieldProperty;
 
@@ -86,9 +84,8 @@
  * <li>minimum value
  * </ul>
  * <p>
- * DateOnly is thread-safe and immutable, provided that the Chronology is as
- * well. All standard Chronology classes supplied are thread-safe and
- * immutable.
+ * DateOnly is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
@@ -99,7 +96,8 @@
  */
 public class DateOnly extends AbstractPartialInstant implements Serializable {
 
-    static final long serialVersionUID = -5796551185494585279L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -5796551185494585279L;
 
     // Constructors
     //-----------------------------------------------------------------------
@@ -153,7 +151,8 @@ public DateOnly(long instant, Chronology chronology) {
     /**
      * Constructs an instance from an Object that represents a date.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -167,7 +166,8 @@ public DateOnly(Object instant) {
      * Constructs an instance from an Object that represents a date, using the
      * specified chronology.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -219,37 +219,40 @@ public DateOnly(
               chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Gets a copy of this instant with different millis.
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the millis will change, the chronology is kept.
+     * Time fields will be removed from the specified millis.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant withMillis(long newMillis) {
+    public final DateOnly withMillis(long newMillis) {
         newMillis = resetUnsupportedFields(newMillis);
-        return newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology());
+        return (newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology()));
     }
-    
+
     /**
      * Gets a copy of this instant with a different chronology.
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the chronology will change, the millis are kept.
+     * The chronology will be converted to a UTC zone.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
      */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
-            : newChronology.withUTC();
-        return newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology);
+    public final DateOnly withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();
+        return (newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology));
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Returns the lower limiting field, dayOfYear.
      *
@@ -501,5 +504,5 @@ protected final void setMillis(long millis) {
      */
     protected final void setChronology(Chronology chronology) {
     }
-    
+
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index c89b4a752..ed451bfde 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -55,8 +55,6 @@
 
 import java.io.Serializable;
 
-// Import for @link support
-import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.property.DateTimeFieldProperty;
 
@@ -85,9 +83,8 @@
  * </ul>
  *
  * <p>
- * DateTime is thread-safe and immutable, provided that the Chronology is as
- * well. All standard Chronology classes supplied are thread-safe and
- * immutable.
+ * DateTime is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Kandarp Shah
@@ -100,7 +97,8 @@
 public class DateTime extends AbstractDateTime
         implements ReadableDateTime, Serializable {
     
-    static final long serialVersionUID = -5171125899451703815L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -5171125899451703815L;
 
     // Constructors
     //-----------------------------------------------------------------------
@@ -182,7 +180,8 @@ public DateTime(long instant, Chronology chronology) {
      * If the object contains no chronology, <code>ISOChronology</code>
      * in the default time zone is used.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -199,7 +198,8 @@ public DateTime(Object instant) {
      * If the object contains no chronology, <code>ISOChronology</code> is used.
      * If the specified time zone is null, the default zone is used.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -216,7 +216,8 @@ public DateTime(Object instant, DateTimeZone zone) {
      * <p>
      * If the chronology is null, ISOChronology in the default time zone is used.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -319,10 +320,10 @@ public DateTime(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant withMillis(long newMillis) {
-        return newMillis == getMillis() ? this : new DateTime(newMillis, getChronology());
+    public final DateTime withMillis(long newMillis) {
+        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));
     }
-    
+
     /**
      * Gets a copy of this instant with a different chronology.
      * <p>
@@ -333,10 +334,73 @@ public ReadableInstant withMillis(long newMillis) {
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
      */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        return newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology);
+    public final DateTime withChronology(Chronology newChronology) {
+        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));
     }
-    
+
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * millisecond instant.
+     * <p>
+     * This method is useful for finding the local time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London, the result
+     * from this method with Europe/Paris would be 13:30.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone, and does not change the
+     * millisecond instant, with the effect that the field values usually change.
+     * Immutable implementations may return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withZoneRetainFields
+     */
+    public final DateTime withZone(DateTimeZone newDateTimeZone) {
+        return withChronology(getChronology().withZone(newDateTimeZone));
+    }
+
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * field values.
+     * <p>
+     * This method is useful for finding the millisecond time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone and the millisecond instant to keep
+     * the field values the same.
+     * Immutable implementations may return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withZone
+     */
+    public final DateTime withZoneRetainFields(DateTimeZone newDateTimeZone) {
+        final long originalMillis = getMillis();
+        final Chronology originalChrono = getChronology();
+        final DateTimeZone originalZone;
+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {
+            // Without an original chronology or time zone, no new time zone
+            // can be set. Call withMillis to allow subclass to decide if a
+            // clone should be made or not.
+            return withMillis(originalMillis);
+        }
+
+        DateTime newInstant = withChronology(originalChrono.withZone(newDateTimeZone));
+        newDateTimeZone = newInstant.getZone();
+
+        if (newDateTimeZone == null || newDateTimeZone == originalZone) {
+            // New time zone didn't stick or didn't change. Skip millis adjustment.
+            return newInstant;
+        }
+
+        long newMillis = originalMillis + originalZone.getOffset(originalMillis);
+        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);
+
+        return newInstant.withMillis(newMillis);
+    }
+
     // Date properties
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 9e6bc1af8..9f8f00712 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -75,7 +75,8 @@
 public final class Instant extends AbstractInstant
         implements ReadableInstant, Serializable {
 
-    static final long serialVersionUID = 3299096530934209741L;
+    /** Serialization lock */
+	private static final long serialVersionUID = 3299096530934209741L;
 
     /** The millis from 1970-01-01T00:00:00Z */
     private final long iMillis;
@@ -126,51 +127,18 @@ public Instant(Object instant) {
         iMillis = converter.getInstantMillis(instant);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Gets a copy of this instant with different millis, as an Instant.
+     * Gets a copy of this instant with different millis.
      * <p>
-     * The returned object will be either be a new Instant or
-     * <code>this</code>.
+     * The returned object will be either be a new Instant or <code>this</code>.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant withMillis(long newMillis) {
+    public Instant withMillis(long newMillis) {
         return newMillis == iMillis ? this : new Instant(newMillis);
     }
-    
-    /**
-     * Since Instant does not support chronologies, this method always returns
-     * <code>this</code>.
-     *
-     * @param newChronology  ignored
-     * @return this
-     */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        return this;
-    }
-    
-    /**
-     * Since Instant does not support time zones, this method always returns
-     * <code>this</code>.
-     *
-     * @param newDateTimeZone  ignored
-     * @return this
-     */
-    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {
-        return this;
-    }
-
-    /**
-     * Since Instant does not support time zones, this method always returns
-     * <code>this</code>.
-     *
-     * @param newDateTimeZone  ignored
-     * @return this
-     */
-    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {
-        return this;
-    }
 
     // Accessors
     //-----------------------------------------------------------------------
@@ -179,7 +147,7 @@ public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {
      * 
      * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final long getMillis() {
+    public long getMillis() {
         return iMillis;
     }
 
@@ -189,7 +157,7 @@ public final long getMillis() {
      * @param base ignored
      * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final long getMillis(ReadableInstant base) {
+    public long getMillis(ReadableInstant base) {
         return iMillis;
     }
 
@@ -200,7 +168,7 @@ public final long getMillis(ReadableInstant base) {
      * @param zone ignored
      * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
+    public long getMillis(ReadableInstant base, DateTimeZone zone) {
         return iMillis;
     }
 
@@ -214,7 +182,7 @@ public final long getMillis(ReadableInstant base, DateTimeZone zone) {
      * 
      * @return null
      */
-    public final Chronology getChronology() {
+    public Chronology getChronology() {
         return null;
     }
 
@@ -228,7 +196,7 @@ public final Chronology getChronology() {
      * 
      * @return ISO8601 date formatted string
      */
-    public final String toString() {
+    public String toString() {
         return ISODateTimeFormat.getInstanceUTC().dateTime().print(this);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/ReadableDuration.java b/JodaTime/src/java/org/joda/time/ReadableDuration.java
index 5d182015f..78a8e624b 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java
@@ -144,7 +144,7 @@
      * @throws IllegalArgumentException if the instant is null
      * @throws ArithmeticException if the result of the calculation is too large
      */
-    ReadableInstant addTo(ReadableInstant instant, int scalar);
+    Instant addTo(ReadableInstant instant, int scalar);
 
     /**
      * Adds this duration into the given mutable instant.
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 1ad24aa44..f26ee6cd3 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -138,72 +138,6 @@
      * @throws IllegalArgumentException if the field is null
      */
     int get(DateTimeField field);
-    
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a copy of this instant with different millis, preserving the
-     * chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Only the millis will change, the chronology and time zone are
-     * kept. Immutable implementations may return <code>this</code> if
-     * appropriate.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    ReadableInstant withMillis(long newMillis);
-    
-    /**
-     * Gets a copy of this instant with a different chronology, preserving the
-     * millisecond instant.
-     * <p>
-     * The returned object will be a new instance of the same implementation
-     * type. Only the chronology will change, the millis are kept. Immutable
-     * implementations may return <code>this</code> if appropriate.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    ReadableInstant withChronology(Chronology newChronology);
-    
-    /**
-     * Gets a copy of this instant with a different time zone, preserving the
-     * millisecond instant.
-     * <p>
-     * This method is useful for finding the local time in another timezone.
-     * For example, if this instant holds 12:30 in Europe/London, the result
-     * from this method with Europe/Paris would be 13:30.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone, and does not change the
-     * millisecond instant, with the effect that the field values usually change.
-     * Immutable implementations may return <code>this</code> if appropriate.
-     *
-     * @param newDateTimeZone  the new time zone
-     * @return a copy of this instant with a different time zone
-     * @see #withZoneRetainFields
-     */
-    ReadableInstant withZone(DateTimeZone newDateTimeZone);
-
-    /**
-     * Gets a copy of this instant with a different time zone, preserving the
-     * field values.
-     * <p>
-     * This method is useful for finding the millisecond time in another timezone.
-     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
-     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone and the millisecond instant to keep
-     * the field values the same.
-     * Immutable implementations may return <code>this</code> if appropriate.
-     *
-     * @param newDateTimeZone  the new time zone
-     * @return a copy of this instant with a different time zone
-     * @see #withZone
-     */
-    ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone);
 
     //-----------------------------------------------------------------------
     /**
@@ -216,7 +150,7 @@
      * @return the value as an <code>Instant</code> object
      */
     Instant toInstant();
-    
+
     //-----------------------------------------------------------------------
     /**
      * Compares this object with the specified object for equality based
@@ -279,7 +213,7 @@
      * @throws IllegalArgumentException if the instant is null
      */
     boolean isBefore(ReadableInstant readableInstant);
-    
+
     /**
      * Is the millisecond value equal to the millisecond passed in.
      *
@@ -288,7 +222,7 @@
      * @throws IllegalArgumentException if the instant is null
      */
     boolean isEqual(ReadableInstant readableInstant);
-    
+
     //-----------------------------------------------------------------------
     /**
      * Get the value as a String in a recognisable ISO8601 format.
@@ -299,5 +233,5 @@
      * @return the value as an ISO8601 string
      */
     String toString();
-    
+
 }
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index 00cf0bf2b..f4fd2b9ae 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -56,8 +56,6 @@
 import java.io.Serializable;
 
 import org.joda.time.chrono.ISOChronology;
-// Import for @link support
-import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.property.TimeOnlyFieldProperty;
 
@@ -99,7 +97,8 @@
  */
 public class TimeOnly extends AbstractPartialInstant implements Serializable {
 
-    static final long serialVersionUID = -8414446947366046476L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -8414446947366046476L;
 
     // Constructors
     //-----------------------------------------------------------------------
@@ -153,7 +152,8 @@ public TimeOnly(long instant, Chronology chronology) {
     /**
      * Constructs an instance from an Object that represents a time.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -167,7 +167,8 @@ public TimeOnly(Object instant) {
      * Constructs an instance from an Object that represents a time, using the
      * specified chronology.
      * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
@@ -228,14 +229,15 @@ public TimeOnly(
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the millis will change, the chronology is kept.
+     * Date fields will be removed from the millis.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant withMillis(long newMillis) {
+    public final TimeOnly withMillis(long newMillis) {
         newMillis = resetUnsupportedFields(newMillis);
-        return newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology());
+        return (newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology()));
     }
     
     /**
@@ -243,15 +245,15 @@ public ReadableInstant withMillis(long newMillis) {
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the chronology will change, the millis are kept.
+     * The chronology will be converted to a UTC zone.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
      */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
-            : newChronology.withUTC();
-        return newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology);
+    public final TimeOnly withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();
+        return (newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology));
     }
 
     /**

From d8d6d6851b539bfec3bcb4bd578f87a4e6f7d2f0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 16 Apr 2004 14:44:19 +0000
Subject: [PATCH 0031/1934] Minor comment fixes

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@180 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/format/DateTimeFormatterBuilder.java   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 70c785f90..00617e354 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -136,7 +136,7 @@ public DateTimeFormatterBuilder(final Chronology chrono) {
     /**
      * Creates a DateTimeFormatterBuilder with any chronology and locale.
      *
-     * @param chrono Chronology to use, or null for default iso
+     * @param chrono Chronology to use, or null for default of ISO
      * @param locale Locale to use, or null for default
      */
     public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {
@@ -161,7 +161,7 @@ public Chronology getChronology() {
     }
 
     /**
-     * Returns the locale being used the formatter builder.
+     * Returns the locale being used by the formatter builder.
      */
     public Locale getLocale() {
         return iLocale;

From c6391f360db0b1e047e153298bd1d175bfb8a5be Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 17 Apr 2004 17:17:05 +0000
Subject: [PATCH 0032/1934] Uses generic JodaTimePermission class.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@181 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeZone.java  |  7 +-
 .../org/joda/time/JodaTimePermission.java     | 85 +++++++++++++++++++
 2 files changed, 88 insertions(+), 4 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/JodaTimePermission.java

diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index 13714c1fd..b3833aa4c 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -65,7 +65,6 @@
 
 import org.joda.time.format.DateTimeFormatter;
 import org.joda.time.format.DateTimeFormatterBuilder;
-import org.joda.time.tz.DateTimeZonePermission;
 import org.joda.time.tz.DefaultNameProvider;
 import org.joda.time.tz.FixedDateTimeZone;
 import org.joda.time.tz.NameProvider;
@@ -174,7 +173,7 @@ public static DateTimeZone getDefault() {
     public static void setDefault(DateTimeZone zone) throws SecurityException {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
-            sm.checkPermission(new DateTimeZonePermission("setDefault"));
+            sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault"));
         }
         if (zone == null) {
             throw new IllegalArgumentException("The datetime zone must not be null");
@@ -305,7 +304,7 @@ public static Provider getProvider() {
     public static void setProvider(Provider provider) throws SecurityException {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
-            sm.checkPermission(new DateTimeZonePermission("setProvider"));
+            sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider"));
         }
         setProvider0(provider);
     }
@@ -342,7 +341,7 @@ public static NameProvider getNameProvider() {
     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
-            sm.checkPermission(new DateTimeZonePermission("setNameProvider"));
+            sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider"));
         }
         setNameProvider0(nameProvider);
     }
diff --git a/JodaTime/src/java/org/joda/time/JodaTimePermission.java b/JodaTime/src/java/org/joda/time/JodaTimePermission.java
new file mode 100644
index 000000000..a4fef9380
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/JodaTimePermission.java
@@ -0,0 +1,85 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * JodaTimePermission is used for securing global method calls in the Joda-Time
+ * library. Since this class extends BasicPermission, asterisks may be used to
+ * denote wildcard permissions. The following permissions are supported:
+ *
+ * <pre>
+ * DateTimeZone
+ *   .setDefault                 Allows a default DateTimeZone to be set
+ *   .setProvider                Allows the DateTimeZone instance provider to be set
+ *   .setNameProvider            Allows the DateTimeZone name provider to be set
+ *
+ * ConverterManager
+ *   .alterInstantConverters     Allows an instant converter to be added or removed
+ *   .alterDurationConverters    Allows a duration converter to be added or removed
+ *   .alterIntervalConverters    Allows an interval converter to be added or removed
+ *
+ * CurrentTime.setProvider       Allows the current time provider to be set
+ * </pre>
+ * <p>
+ * JodaTimePermission is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public class JodaTimePermission extends java.security.BasicPermission {
+    static final long serialVersionUID = 1408944367355875472L;
+
+    public JodaTimePermission(String name) {
+        super(name);
+    }
+}

From ade078da787d01451a019116846ab286611fe239 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 17 Apr 2004 17:17:38 +0000
Subject: [PATCH 0033/1934] Replaced by JodaTimePermission.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@182 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/tz/DateTimeZonePermission.java  | 80 -------------------
 1 file changed, 80 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java

diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
deleted file mode 100644
index f2f6d12f6..000000000
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.tz;
-
-/**
- * DateTimeZonePermission allows global settings of DateTimeZone to be changed.
- * The following permission target names are supported:
- * <pre>
- * setDefault        Allows a default DateTimeZone to be set
- * setProvider       Allows a provider of DateTimeZone instances to be set
- * setNameProvider   Allows a provider of DateTimeZone names to be set
- * </pre>
- * <p>
- * DateTimeZonePermission is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- */
-public class DateTimeZonePermission extends java.security.BasicPermission {
-
-    static final long serialVersionUID = 3496753502571108448L;
-
-    public DateTimeZonePermission(String name) {
-        super(name);
-    }
-
-    public DateTimeZonePermission(String name, String actions) {
-        super(name, actions);
-    }
-}

From 72028b718f85d3c547e770c8d84f688b8cd89e16 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 17 Apr 2004 17:18:18 +0000
Subject: [PATCH 0034/1934] Permission checks in place.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@183 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeUtils.java | 16 ++++-
 .../joda/time/convert/ConverterManager.java   | 62 ++++++++++++++++---
 2 files changed, 66 insertions(+), 12 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeUtils.java b/JodaTime/src/java/org/joda/time/DateTimeUtils.java
index 62d151f3e..24ec0a4cb 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java
@@ -94,7 +94,8 @@ public static long currentTimeMillis() {
      * This method changes the behaviour of {@link #currentTimeMillis()}.
      * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.
      */
-    public static void setCurrentMillisSystem() {
+    public static void setCurrentMillisSystem() throws SecurityException {
+        checkPermission();
         cMillisProvider = SYSTEM_MILLIS_PROVIDER;
     }
 
@@ -106,7 +107,8 @@ public static void setCurrentMillisSystem() {
      * 
      * @param fixedMillis  the fixed millisecond time to use
      */
-    public static void setCurrentMillisFixed(long fixedMillis) {
+    public static void setCurrentMillisFixed(long fixedMillis) throws SecurityException {
+        checkPermission();
         cMillisProvider = new FixedMillisProvider(fixedMillis);
     }
 
@@ -119,10 +121,18 @@ public static void setCurrentMillisFixed(long fixedMillis) {
      * 
      * @param offsetMillis  the fixed millisecond time to use
      */
-    public static void setCurrentMillisOffset(long offsetMillis) {
+    public static void setCurrentMillisOffset(long offsetMillis) throws SecurityException {
+        checkPermission();
         cMillisProvider = new OffsetMillisProvider(offsetMillis);
     }
 
+    private static void checkPermission() throws SecurityException {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new JodaTimePermission("CurrentTime.setProvider"));
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Base class defining a millisecond provider.
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index ea2731705..fcf14fb8e 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -53,6 +53,8 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.JodaTimePermission;
+
 /**
  * ConverterManager controls the date and time converters.
  * <p>
@@ -182,7 +184,10 @@ public InstantConverter getInstantConverter(Object object) {
      * @param converter  the converter to add, null ignored
      * @return replaced converter, or null
      */
-    public InstantConverter addInstantConverter(InstantConverter converter) {
+    public InstantConverter addInstantConverter(InstantConverter converter)
+        throws SecurityException
+    {
+        checkAlterInstantConverters();
         if (converter == null) {
             return null;
         }
@@ -198,7 +203,10 @@ public InstantConverter addInstantConverter(InstantConverter converter) {
      * @param converter  the converter to remove, null ignored
      * @return replaced converter, or null
      */
-    public InstantConverter removeInstantConverter(InstantConverter converter) {
+    public InstantConverter removeInstantConverter(InstantConverter converter)
+        throws SecurityException
+    {
+        checkAlterInstantConverters();
         if (converter == null) {
             return null;
         }
@@ -214,12 +222,20 @@ public InstantConverter removeInstantConverter(InstantConverter converter) {
      * @return replaced converter, or null
      * @throws IndexOutOfBoundsException if the index is invalid
      */
-    public InstantConverter removeInstantConverter(int index) {
+    public InstantConverter removeInstantConverter(int index) throws SecurityException {
+        checkAlterInstantConverters();
         InstantConverter[] removed = new InstantConverter[1];
         iInstantConverters = iInstantConverters.remove(index, removed);
         return removed[0];
     }
 
+    private void checkAlterInstantConverters() throws SecurityException {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new JodaTimePermission("ConverterManager.alterInstantConverters"));
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Gets the best converter for the object specified.
@@ -264,7 +280,10 @@ public DurationConverter getDurationConverter(Object object) {
      * @param converter  the converter to add, null ignored
      * @return replaced converter, or null
      */
-    public DurationConverter addDurationConverter(DurationConverter converter) {
+    public DurationConverter addDurationConverter(DurationConverter converter)
+        throws SecurityException
+    {
+        checkAlterDurationConverters();
         if (converter == null) {
             return null;
         }
@@ -280,7 +299,10 @@ public DurationConverter addDurationConverter(DurationConverter converter) {
      * @param converter  the converter to remove, null ignored
      * @return replaced converter, or null
      */
-    public DurationConverter removeDurationConverter(DurationConverter converter) {
+    public DurationConverter removeDurationConverter(DurationConverter converter)
+        throws SecurityException
+    {
+        checkAlterDurationConverters();
         if (converter == null) {
             return null;
         }
@@ -296,12 +318,20 @@ public DurationConverter removeDurationConverter(DurationConverter converter) {
      * @return replaced converter, or null
      * @throws IndexOutOfBoundsException if the index is invalid
      */
-    public DurationConverter removeDurationConverter(int index) {
+    public DurationConverter removeDurationConverter(int index) throws SecurityException {
+        checkAlterDurationConverters();
         DurationConverter[] removed = new DurationConverter[1];
         iDurationConverters = iDurationConverters.remove(index, removed);
         return removed[0];
     }
 
+    private void checkAlterDurationConverters() throws SecurityException {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new JodaTimePermission("ConverterManager.alterDurationConverters"));
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Gets the best converter for the object specified.
@@ -346,7 +376,10 @@ public IntervalConverter getIntervalConverter(Object object) {
      * @param converter  the converter to add, null ignored
      * @return replaced converter, or null
      */
-    public IntervalConverter addIntervalConverter(IntervalConverter converter) {
+    public IntervalConverter addIntervalConverter(IntervalConverter converter) 
+        throws SecurityException
+    {
+        checkAlterIntervalConverters();
         if (converter == null) {
             return null;
         }
@@ -362,7 +395,10 @@ public IntervalConverter addIntervalConverter(IntervalConverter converter) {
      * @param converter  the converter to remove, null ignored
      * @return replaced converter, or null
      */
-    public IntervalConverter removeIntervalConverter(IntervalConverter converter) {
+    public IntervalConverter removeIntervalConverter(IntervalConverter converter)
+        throws SecurityException
+    {
+        checkAlterIntervalConverters();
         if (converter == null) {
             return null;
         }
@@ -378,12 +414,20 @@ public IntervalConverter removeIntervalConverter(IntervalConverter converter) {
      * @return replaced converter, or null
      * @throws IndexOutOfBoundsException if the index is invalid
      */
-    public IntervalConverter removeIntervalConverter(int index) {
+    public IntervalConverter removeIntervalConverter(int index) throws SecurityException {
+        checkAlterIntervalConverters();
         IntervalConverter[] removed = new IntervalConverter[1];
         iIntervalConverters = iIntervalConverters.remove(index, removed);
         return removed[0];
     }
 
+    private void checkAlterIntervalConverters() throws SecurityException {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new JodaTimePermission("ConverterManager.alterIntervalConverters"));
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Gets a debug representation of the object

From b81cd9b2a176fd98a1810eb34a8d720fe17a1548 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 27 Apr 2004 15:07:01 +0000
Subject: [PATCH 0035/1934] Removed withMillis and withChronology methods.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@184 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/MutableDateOnly.java   | 28 -----------------
 .../java/org/joda/time/MutableDateTime.java   | 26 ----------------
 .../java/org/joda/time/MutableTimeOnly.java   | 30 -------------------
 3 files changed, 84 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index c1591a518..eca1c3f0d 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -222,34 +222,6 @@ public MutableDateOnly(
               chronology);
     }
 
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology is kept.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public ReadableInstant withMillis(long newMillis) {
-        return new MutableDateOnly(newMillis, getChronology());
-    }
-    
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
-            : newChronology.withUTC();
-        return new MutableDateOnly(getMillis(), newChronology);
-    }
-
     /**
      * Returns the lower limiting field, dayOfYear.
      *
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 9ae8061e0..6b5aaa52b 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -311,32 +311,6 @@ public MutableDateTime(
               hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);
     }
 
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology and time zone are kept.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public ReadableInstant withMillis(long newMillis) {
-        return new MutableDateTime(newMillis, getChronology());
-    }
-    
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        return new MutableDateTime(getMillis(), newChronology);
-    }
     
     // Millis
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index 1a012a4e9..14965dc99 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -226,36 +226,6 @@ public MutableTimeOnly(
               chronology);
     }
 
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology is kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public ReadableInstant withMillis(long newMillis) {
-        return new MutableTimeOnly(newMillis, getChronology());
-    }
-    
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public ReadableInstant withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
-            : newChronology.withUTC();
-        return new MutableTimeOnly(getMillis(), newChronology);
-    }
-
     /**
      * Returns the lower limiting field, null.
      *

From 331282f8082168aa43ee92ad2a57374aa073f74e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 27 Apr 2004 15:08:08 +0000
Subject: [PATCH 0036/1934] Comment updates.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@185 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateOnly.java |  4 ++--
 JodaTime/src/java/org/joda/time/DateTime.java | 12 ++++++------
 JodaTime/src/java/org/joda/time/TimeOnly.java |  4 ++--
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 175fc6c18..3887a37a4 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -226,7 +226,7 @@ public DateOnly(
      * The returned object will be a new instance of the same implementation type.
      * Only the millis will change, the chronology is kept.
      * Time fields will be removed from the specified millis.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
@@ -242,7 +242,7 @@ public final DateOnly withMillis(long newMillis) {
      * The returned object will be a new instance of the same implementation type.
      * Only the chronology will change, the millis are kept.
      * The chronology will be converted to a UTC zone.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index ed451bfde..ef4737e2c 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -315,7 +315,7 @@ public DateTime(
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the millis will change, the chronology and time zone are kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
@@ -329,7 +329,7 @@ public final DateTime withMillis(long newMillis) {
      * <p>
      * The returned object will be a new instance of the same implementation type.
      * Only the chronology will change, the millis are kept.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
@@ -349,7 +349,7 @@ public final DateTime withChronology(Chronology newChronology) {
      * The returned object will be a new instance of the same implementation type.
      * This method changes alters the time zone, and does not change the
      * millisecond instant, with the effect that the field values usually change.
-     * Immutable implementations may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
@@ -370,7 +370,7 @@ public final DateTime withZone(DateTimeZone newDateTimeZone) {
      * The returned object will be a new instance of the same implementation type.
      * This method changes alters the time zone and the millisecond instant to keep
      * the field values the same.
-     * Immutable implementations may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newDateTimeZone  the new time zone
      * @return a copy of this instant with a different time zone
@@ -382,8 +382,8 @@ public final DateTime withZoneRetainFields(DateTimeZone newDateTimeZone) {
         final DateTimeZone originalZone;
         if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {
             // Without an original chronology or time zone, no new time zone
-            // can be set. Call withMillis to allow subclass to decide if a
-            // clone should be made or not.
+            // can be set. Call withMillis to let it decide if a clone should
+            // be made or not.
             return withMillis(originalMillis);
         }
 
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index f4fd2b9ae..af1913cad 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -230,7 +230,7 @@ public TimeOnly(
      * The returned object will be a new instance of the same implementation type.
      * Only the millis will change, the chronology is kept.
      * Date fields will be removed from the millis.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
@@ -246,7 +246,7 @@ public final TimeOnly withMillis(long newMillis) {
      * The returned object will be a new instance of the same implementation type.
      * Only the chronology will change, the millis are kept.
      * The chronology will be converted to a UTC zone.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new instance or <code>this</code>.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology

From bee95ce26278c47d98060f2836a91bde29a8a030 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 17:27:43 +0000
Subject: [PATCH 0037/1934] Delegate to the correct method

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@186 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/property/AbstractReadableInstantFieldProperty.java     | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
index 83fa1a4a2..b6bf79181 100644
--- a/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
@@ -138,7 +138,7 @@ public String getAsText(Locale locale) {
      * @see DateTimeField#getAsText
      */
     public final String getAsText() {
-        return getField().getAsText(getInstant().getMillis(), null);
+        return getAsText(null);
     }
 
     /**

From 43bceec9fc98fd056391ab0f100e0dd54fa3764c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 17:29:56 +0000
Subject: [PATCH 0038/1934] Made abstract

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@187 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/field/DecoratedDateTimeField.java   | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
index c415876ef..5599b4d1e 100644
--- a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
@@ -73,9 +73,10 @@
  * @since 1.0
  * @see DelegatedDateTimeField
  */
-public class DecoratedDateTimeField extends AbstractDateTimeField {
+public abstract class DecoratedDateTimeField extends AbstractDateTimeField {
 
-    static final long serialVersionUID = 203115783733757597L;
+    /** Serialization version */
+    private static final long serialVersionUID = 203115783733757597L;
 
     /** The DateTimeField being wrapped */
     private final DateTimeField iField;
@@ -83,7 +84,7 @@
     /**
      * @param name allow name to be overridden
      */
-    public DecoratedDateTimeField(DateTimeField field, String name) {
+    protected DecoratedDateTimeField(DateTimeField field, String name) {
         super(name);
         if (field == null) {
             throw new IllegalArgumentException("The field must not be null");

From 92e7588025c7c7ef7685e18f0ae180e7a8342202 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 17:40:04 +0000
Subject: [PATCH 0039/1934] Initial version of refactored PartialInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@189 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 124 ++-
 .../time/chrono/AbstractGJChronology.java     |   4 +-
 .../time/chrono/BuddhistEraDateTimeField.java |  25 +-
 .../time/chrono/CopticEraDateTimeField.java   |  25 +-
 .../time/chrono/GJDayOfWeekDateTimeField.java |  13 +-
 .../joda/time/chrono/GJEraDateTimeField.java  |   7 +-
 .../chrono/GJMonthOfYearDateTimeField.java    |  14 +-
 .../time/field/AbstractDateTimeField.java     | 110 ++-
 .../time/field/DelegatedDateTimeField.java    |  22 +-
 .../time/field/UnsupportedDateTimeField.java  |  19 +-
 .../partial/AbstractPartialFieldProperty.java | 335 ++++++++
 .../org/joda/time/partial/PartialInstant.java | 169 +++++
 .../java/org/joda/time/partial/TimeOfDay.java | 713 ++++++++++++++++++
 .../joda/test/time/partial/TestTimeOfDay.java | 296 ++++++++
 14 files changed, 1723 insertions(+), 153 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
 create mode 100644 JodaTime/src/java/org/joda/time/partial/PartialInstant.java
 create mode 100644 JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
 create mode 100644 JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 5cba084e0..b51265936 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -55,6 +55,8 @@
 
 import java.util.Locale;
 
+import org.joda.time.partial.PartialInstant;
+
 /**
  * Defines the calculation engine for date and time fields.
  * The interface defines a set of methods that manipulate a millisecond datetime
@@ -68,7 +70,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public interface DateTimeField {
+public abstract class DateTimeField {
 
     /**
      * Get the name of the field, intended for debugging purposes only. By
@@ -79,14 +81,14 @@
      * 
      * @return field name
      */
-    String getName();
+    public abstract String getName();
 
     /**
      * Returns true if this field is supported.
      * 
      * @return true if this field is supported
      */
-    boolean isSupported();
+    public abstract boolean isSupported();
 
     /**
      * Returns true if the set method is lenient. If so, it accepts values that
@@ -95,7 +97,7 @@
      * 
      * @return true if this field is lenient
      */
-    boolean isLenient();
+    public abstract boolean isLenient();
 
     // Main access API
     //------------------------------------------------------------------------
@@ -105,7 +107,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the value of the field, in the units of the field
      */
-    int get(long instant);
+    public abstract int get(long instant);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
@@ -115,7 +117,7 @@
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    String getAsText(long instant, Locale locale);
+    public abstract String getAsText(long instant, Locale locale);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
@@ -123,7 +125,32 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the text value of the field
      */
-    String getAsText(long instant);
+    public String getAsText(long instant) {
+        return getAsText(instant, null);
+    }
+
+    /**
+     * Get the human-readable, text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     *
+     * @param partial  the partial instant to query
+     * @param fieldValue  the field value of this field, provided for performance
+     * @param locale  the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    public abstract String getAsText(PartialInstant partial, int fieldValue, Locale locale);
+
+    /**
+     * Get the human-readable, text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     *
+     * @param partial  the partial instant to query
+     * @param locale  the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    public String getAsText(PartialInstant partial, Locale locale) {
+        return getAsText(partial, partial.get(this), locale);
+    }
 
     /**
      * Get the human-readable, short text value of this field from the
@@ -133,7 +160,7 @@
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the short text value of the field
      */
-    String getAsShortText(long instant, Locale locale);
+    public abstract String getAsShortText(long instant, Locale locale);
 
     /**
      * Get the human-readable, short text value of this field from the
@@ -142,7 +169,32 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the short text value of the field
      */
-    String getAsShortText(long instant);
+    public String getAsShortText(long instant) {
+        return getAsShortText(instant, null);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     *
+     * @param partial  the partial instant to query
+     * @param fieldValue  the field value of this field, provided for performance
+     * @param locale  the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    public abstract String getAsShortText(PartialInstant partial, int fieldValue, Locale locale);
+
+    /**
+     * Get the human-readable, short text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     *
+     * @param partial  the partial instant to query
+     * @param locale  the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    public String getAsShortText(PartialInstant partial, Locale locale) {
+        return getAsShortText(partial, partial.get(this), locale);
+    }
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -165,7 +217,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    long add(long instant, int value);
+    public abstract long add(long instant, int value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -177,7 +229,7 @@
      * @throws IllegalArgumentException if value is too large
      * @see #add(long,int)
      */
-    long add(long instant, long value);
+    public abstract long add(long instant, long value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -200,7 +252,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    long addWrapped(long instant, int value) ;
+    public abstract long addWrapped(long instant, int value) ;
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -221,7 +273,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    int getDifference(long minuendInstant, long subtrahendInstant);
+    public abstract int getDifference(long minuendInstant, long subtrahendInstant);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -242,7 +294,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
+    public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
 
     /**
      * Sets a value in the milliseconds supplied.
@@ -255,7 +307,7 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the value is invalid
      */
-    long set(long instant, int value);
+    public abstract long set(long instant, int value);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
@@ -268,7 +320,7 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    long set(long instant, String text, Locale locale);
+    public abstract long set(long instant, String text, Locale locale);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
@@ -279,7 +331,9 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    long set(long instant, String text);
+    public long set(long instant, String text) {
+        return set(instant, text, null);
+    }
 
     // Extra information API
     //------------------------------------------------------------------------
@@ -290,7 +344,7 @@
      * @return the duration of this field, or UnsupportedDurationField if field
      * has no duration
      */
-    DurationField getDurationField();
+    public abstract DurationField getDurationField();
 
     /**
      * Returns the range duration of this field. For example, if this field
@@ -298,7 +352,7 @@
      *
      * @return the range duration of this field, or null if field has no range
      */
-    DurationField getRangeDurationField();
+    public abstract DurationField getRangeDurationField();
 
     /**
      * Returns whether this field is 'leap' for the specified instant.
@@ -308,7 +362,7 @@
      * 
      * @return true if the field is 'leap'
      */
-    boolean isLeap(long instant);
+    public abstract boolean isLeap(long instant);
 
     /**
      * Gets the amount by which this field is 'leap' for the specified instant.
@@ -316,13 +370,13 @@
      * For example, a leap year would return one, a non leap year would return
      * zero.
      */
-    int getLeapAmount(long instant);
+    public abstract int getLeapAmount(long instant);
 
     /**
      * If this field were to leap, then it would be in units described by the
      * returned duration. If this field doesn't ever leap, null is returned.
      */
-    DurationField getLeapDurationField();
+    public abstract DurationField getLeapDurationField();
 
     /**
      * Get the minimum allowable value for this field.
@@ -330,7 +384,7 @@
      * @return the minimum valid value for this field, in the units of the
      * field
      */
-    int getMinimumValue();
+    public abstract int getMinimumValue();
 
     /**
      * Get the minimum value for this field evaluated at the specified time.
@@ -338,7 +392,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the minimum value for this field, in the units of the field
      */
-    int getMinimumValue(long instant);
+    public abstract int getMinimumValue(long instant);
 
     /**
      * Get the maximum allowable value for this field.
@@ -346,7 +400,7 @@
      * @return the maximum valid value for this field, in the units of the
      * field
      */
-    int getMaximumValue();
+    public abstract int getMaximumValue();
 
     /**
      * Get the maximum value for this field evaluated at the specified time.
@@ -354,7 +408,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the maximum value for this field, in the units of the field
      */
-    int getMaximumValue(long instant);
+    public abstract int getMaximumValue(long instant);
 
     /**
      * Get the maximum text value for this field.
@@ -362,7 +416,7 @@
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum text length
      */
-    int getMaximumTextLength(Locale locale);
+    public abstract int getMaximumTextLength(Locale locale);
 
     /**
      * Get the maximum short text value for this field.
@@ -370,7 +424,7 @@
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum short text length
      */
-    int getMaximumShortTextLength(Locale locale);
+    public abstract int getMaximumShortTextLength(Locale locale);
 
     // Calculation API
     //------------------------------------------------------------------------
@@ -386,7 +440,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    long roundFloor(long instant);
+    public abstract long roundFloor(long instant);
 
     /**
      * Round to the highest whole unit of this field. The value of this field
@@ -400,7 +454,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    long roundCeiling(long instant);
+    public abstract long roundCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -411,7 +465,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    long roundHalfFloor(long instant);
+    public abstract long roundHalfFloor(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -422,7 +476,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    long roundHalfCeiling(long instant);
+    public abstract long roundHalfCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -437,7 +491,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    long roundHalfEven(long instant);
+    public abstract long roundHalfEven(long instant);
 
     /**
      * Returns the fractional duration milliseconds of this field. In other
@@ -451,13 +505,13 @@
      * remainder
      * @return remainder duration, in milliseconds
      */
-    long remainder(long instant);
+    public abstract long remainder(long instant);
 
     /**
      * Get a suitable debug string.
      * 
      * @return debug string
      */
-    String toString();
+    public abstract String toString();
     
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 1e6caaba6..7721bfcd4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -840,8 +840,8 @@ private YearInfo getYearInfo(int year) {
             super("halfdayOfDay", cHalfdaysField, cDaysField);
         }
 
-        public String getAsText(long millis, Locale locale) {
-            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));
+        protected String getAsText(int fieldValue, Locale locale) {
+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);
         }
 
         public long set(long millis, String text, Locale locale) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
index 95d653ba8..27f3cae6b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
@@ -70,7 +70,8 @@
  */
 final class BuddhistEraDateTimeField extends AbstractDateTimeField {
     
-    static final long serialVersionUID = -9175876774456816364L;
+    /** Serialization version */
+    private static final long serialVersionUID = -9175876774456816364L;
 
     /**
      * Singleton instance
@@ -164,31 +165,11 @@ public int getMinimumValue() {
     public int getMaximumValue() {
         return BuddhistChronology.BE;
     }
-    
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        return "BE";
-    }
-    
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return 2;
-    }
 
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsText(long instant, Locale locale) {
+    protected String getAsText(int fieldValue, Locale locale) {
         return "BE";
     }
 
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
     public int getMaximumTextLength(Locale locale) {
         return 2;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
index b1adfd9c1..9212c9bb0 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
@@ -69,7 +69,8 @@
  */
 final class CopticEraDateTimeField extends AbstractDateTimeField {
     
-    static final long serialVersionUID = 4090856468123006167L;
+    /** Serialization version */
+    private static final long serialVersionUID = 4090856468123006167L;
 
     /**
      * Singleton instance
@@ -164,30 +165,10 @@ public int getMaximumValue() {
         return CopticChronology.AM;
     }
     
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        return "AM";
-    }
-    
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return 2;
-    }
-
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsText(long instant, Locale locale) {
+    protected String getAsText(int fieldValue, Locale locale) {
         return "AM";
     }
 
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
     public int getMaximumTextLength(Locale locale) {
         return 2;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
index 2b6ad26b3..a91f8c8ec 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
@@ -70,7 +70,8 @@
  */
 final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {
     
-    static final long serialVersionUID = -3857947176719041436L;
+    /** Serialization version */
+    private static final long serialVersionUID = -3857947176719041436L;
 
     private final AbstractGJChronology iChronology;
 
@@ -95,12 +96,12 @@ public int get(long instant) {
     /**
      * Get the textual value of the specified time instant.
      * 
-     * @param instant  the time instant in millis to query
+     * @param fieldValue  the field value to query
      * @param locale  the locale to use
      * @return the day of the week, such as 'Monday'
      */
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));
+    protected String getAsText(int fieldValue, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);
     }
 
     /**
@@ -110,8 +111,8 @@ public String getAsText(long instant, Locale locale) {
      * @param locale  the locale to use
      * @return the day of the week, such as 'Mon'
      */
-    public String getAsShortText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));
+    protected String getAsShortText(int fieldValue, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
index 093764aa9..4d49ad5c4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
@@ -71,7 +71,8 @@
  */
 final class GJEraDateTimeField extends AbstractDateTimeField {
     
-    static final long serialVersionUID = 4240986525305515528L;
+    /** Serialization version */
+    private static final long serialVersionUID = 4240986525305515528L;
 
     private final AbstractGJChronology iChronology;
 
@@ -100,8 +101,8 @@ public int get(long instant) {
         }
     }
 
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));
+    protected String getAsText(int fieldValue, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
index c453b3865..454a7210d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
@@ -56,10 +56,9 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.field.ImpreciseDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  * Provides time calculations for the month of the year component of time.
@@ -72,7 +71,8 @@
  */
 final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
 
-    static final long serialVersionUID = -4748157875845286249L;
+    /** Serialization version */
+    private static final long serialVersionUID = -4748157875845286249L;
 
     private static final int MIN = DateTimeConstants.JANUARY;
     private static final int MAX = DateTimeConstants.DECEMBER;
@@ -103,12 +103,12 @@ public int get(long instant) {
         return iChronology.getMonthOfYear(instant);
     }
 
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));
+    protected String getAsText(int fieldValue, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue);
     }
 
-    public String getAsShortText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));
+    protected String getAsShortText(int fieldValue, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
index ae41151af..192bd55ed 100644
--- a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
@@ -55,8 +55,10 @@
 
 import java.io.Serializable;
 import java.util.Locale;
+
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * AbstractDateTimeField provides the common behaviour for DateTimeField
@@ -73,9 +75,10 @@
  * @since 1.0
  * @see DecoratedDateTimeField
  */
-public abstract class AbstractDateTimeField implements DateTimeField, Serializable {
+public abstract class AbstractDateTimeField extends DateTimeField implements Serializable {
 
-    static final long serialVersionUID = -4388055220581798589L;
+    /** Serialization version */
+    private static final long serialVersionUID = -4388055220581798589L;
 
     /** A desriptive name for the field */
     private final String iName;
@@ -112,14 +115,12 @@ public final boolean isSupported() {
      */
     public abstract int get(long instant);
 
+    //-----------------------------------------------------------------------
     /**
      * Get the human-readable, text value of this field from the milliseconds.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns Integer.toString(get(instant)).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getMaximumTextLength.
+     * The default implementation returns getAsText(get(instant)).
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @param locale the locale to use for selecting a text symbol, null for
@@ -127,50 +128,89 @@ public final boolean isSupported() {
      * @return the text value of the field
      */
     public String getAsText(long instant, Locale locale) {
-        return Integer.toString(get(instant));
+        return getAsText(get(instant));
     }
 
     /**
-     * Get the human-readable, text value of this field from the milliseconds.
-     * This implementation returns getAsText(instant, null).
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * Get the human-readable, text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns getAsText(fieldValue).
+     *
+     * @param partial  the partial instant to query
+     * @param fieldValue  the field value of this field, provided for performance
+     * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public final String getAsText(long instant) {
-        return getAsText(instant, null);
+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
+        return getAsText(fieldValue);
     }
 
     /**
-     * Get the human-readable, short text value of this field from the
-     * milliseconds.  If the specified locale is null, the default locale is
-     * used.
+     * Get the human-readable, text value of this field from the field value.
+     * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns getAsText(instant, locale).
+     * The default implementation returns Integer.toString(get(instant)).
      * <p>
      * Note: subclasses that override this method should also override
-     * getMaximumShortTextLength.
+     * getMaximumTextLength.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
-     * @return the short text value of the field
+     * @param locale the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    protected String getAsText(int fieldValue, Locale locale) {
+        return Integer.toString(fieldValue);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the human-readable, short text value of this field from the milliseconds.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns getAsShortText(get(instant)).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
      */
     public String getAsShortText(long instant, Locale locale) {
-        return getAsText(instant, locale);
+        return getAsShortText(get(instant));
     }
 
     /**
-     * Get the human-readable, short text value of this field from the
-     * milliseconds.  This implementation returns getAsShortText(instant, null).
-     * 
+     * Get the human-readable, short text value of this field from a partial instant.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns getAsShortText(fieldValue).
+     *
+     * @param partial  the partial instant to query
+     * @param fieldValue  the field value of this field, provided for performance
+     * @param locale  the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
+     */
+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
+        return getAsShortText(fieldValue);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from the field value.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns getAsText(fieldValue, locale).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getMaximumShortTextLength.
+     *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the short text value of the field
+     * @param locale the locale to use for selecting a text symbol, null for default
+     * @return the text value of the field
      */
-    public final String getAsShortText(long instant) {
-        return getAsShortText(instant, null);
+    protected String getAsShortText(int fieldValue, Locale locale) {
+        return getAsText(fieldValue, locale);
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Adds a value (which may be negative) to the instant value,
      * overflowing into larger fields if necessary.
@@ -241,6 +281,7 @@ public long addWrapped(long instant, int value) {
         return set(instant, wrapped);
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Computes the difference between two instants, as measured in the units
      * of this field. Any fractional units are dropped from the result. Calling
@@ -325,19 +366,6 @@ public long set(long instant, String text, Locale locale) {
         }
     }
 
-    /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. This implementation returns set(instant, text, null).
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param text  the text value to set
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if the text value is invalid
-     */
-    public final long set(long instant, String text) {
-        return set(instant, text, null);
-    }
-
     // Extra information API
     //------------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index d7748ba36..c7669a717 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -57,6 +57,7 @@
 import java.util.Locale;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * <code>DelegatedDateTimeField</code> delegates each method call to the
@@ -69,9 +70,10 @@
  * @since 1.0
  * @see DecoratedDateTimeField
  */
-public class DelegatedDateTimeField implements DateTimeField, Serializable {
+public class DelegatedDateTimeField extends DateTimeField implements Serializable {
 
-    static final long serialVersionUID = -4730164440214502503L;
+    /** Serialization version */
+    private static final long serialVersionUID = -4730164440214502503L;
 
     /** The DateTimeField being wrapped */
     private final DateTimeField iField;
@@ -124,6 +126,14 @@ public String getAsText(long instant) {
         return iField.getAsText(instant);
     }
 
+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
+        return iField.getAsText(partial, fieldValue, locale);
+    }
+
+    public String getAsText(PartialInstant partial, Locale locale) {
+        return iField.getAsText(partial, locale);
+    }
+
     public String getAsShortText(long instant, Locale locale) {
         return iField.getAsShortText(instant, locale);
     }
@@ -132,6 +142,14 @@ public String getAsShortText(long instant) {
         return iField.getAsShortText(instant);
     }
 
+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
+        return iField.getAsShortText(partial, fieldValue, locale);
+    }
+
+    public String getAsShortText(PartialInstant partial, Locale locale) {
+        return iField.getAsShortText(partial, locale);
+    }
+
     public long add(long instant, int value) {
         return iField.add(instant, value);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index d00055b9d..ccf4852c4 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -58,6 +58,7 @@
 import java.util.Locale;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * A placeholder implementation to use when a datetime field is not supported.
@@ -66,9 +67,10 @@
  *
  * @author Brian S O'Neill
  */
-public final class UnsupportedDateTimeField implements DateTimeField, Serializable {
+public final class UnsupportedDateTimeField extends DateTimeField implements Serializable {
 
-    static final long serialVersionUID = -1934618396111902255L;
+    /** Serialilzation version */
+    private static final long serialVersionUID = -1934618396111902255L;
 
     /**
      * Instance with the name "unsupported".
@@ -160,7 +162,7 @@ public String getAsText(long instant, Locale locale) {
      *
      * @throws UnsupportedOperationException
      */
-    public String getAsText(long instant) {
+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
         throw unsupported();
     }
 
@@ -178,7 +180,7 @@ public String getAsShortText(long instant, Locale locale) {
      *
      * @throws UnsupportedOperationException
      */
-    public String getAsShortText(long instant) {
+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
         throw unsupported();
     }
 
@@ -245,15 +247,6 @@ public long set(long instant, String text, Locale locale) {
         throw unsupported();
     }
 
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long set(long instant, String text) {
-        throw unsupported();
-    }
-
     /**
      * Even though this DateTimeField is unsupported, the duration field might
      * be supported.
diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
new file mode 100644
index 000000000..63064f7d9
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -0,0 +1,335 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.ReadableInstant;
+
+/**
+ * AbstractPartialFieldProperty is a base class for binding a
+ * PartialInstant to a DateTimeField.
+ * <p>
+ * It allows the date and time manipulation code to be field based yet
+ * still easy to use.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractPartialFieldProperty {
+
+    /**
+     * Constructor.
+     */
+    protected AbstractPartialFieldProperty() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public abstract DateTimeField getField();
+
+    /**
+     * Gets the name of the field.
+     * 
+     * @return the field name
+     */
+    public String getName() {
+        return getField().getName();
+    }
+
+    /**
+     * Gets the partial instant being used.
+     * 
+     * @return the partial instant
+     */
+    public abstract PartialInstant getPartialInstant();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a value from the partial instant.
+     * 
+     * @return the current value
+     */
+    public abstract int get();
+
+    /**
+     * Gets a text value from the partial instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public String getAsText(Locale locale) {
+        return getField().getAsText(getPartialInstant(), get(), locale);
+    }
+
+    /**
+     * Gets a text value from the partial instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public final String getAsText() {
+        return getAsText(null);
+    }
+
+    /**
+     * Gets a short text value from the partial instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public String getAsShortText(Locale locale) {
+        return getField().getAsShortText(getPartialInstant(), get(), locale);
+    }
+
+    /**
+     * Gets a short text value from the partial instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public final String getAsShortText() {
+        return getAsShortText(null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField
+     */
+    public DurationField getDurationField() {
+        return getField().getDurationField();
+    }
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField() {
+        return getField().getRangeDurationField();
+    }
+
+// TODO
+//    /**
+//     * Gets whether this field is leap.
+//     * 
+//     * @return true if a leap field
+//     * @see DateTimeField#isLeap
+//     */
+//    public boolean isLeap() {
+//        return getField().isLeap(getPartialInstant(), get());
+//    }
+//
+//    /**
+//     * Gets the amount by which this field is leap.
+//     * 
+//     * @return the amount by which the field is leap
+//     * @see DateTimeField#getLeapAmount
+//     */
+//    public int getLeapAmount() {
+//        return getField().getLeapAmount(getPartialInstant(), get());
+//    }
+
+    /**
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
+     */
+    public DurationField getLeapDurationField() {
+        return getField().getLeapDurationField();
+    }
+
+    //-----------------------------------------------------------------------
+// TODO
+//    /**
+//     * Gets the minimum value for the field ignoring the current time.
+//     * 
+//     * @return the minimum value
+//     * @see DateTimeField#getMinimumValue
+//     */
+//    public int getMinimumValueOverall() {
+//        return getField().getMinimumValue();
+//    }
+//
+//    /**
+//     * Gets the minimum value for the field.
+//     * 
+//     * @return the minimum value
+//     * @see DateTimeField#getMinimumValue
+//     */
+//    public int getMinimumValue() {
+//        return getField().getMinimumValue(getPartialInstant(), get());
+//    }
+//
+//    /**
+//     * Gets the maximum value for the field ignoring the current time.
+//     * 
+//     * @return the maximum value
+//     * @see DateTimeField#getMaximumValue
+//     */
+//    public int getMaximumValueOverall() {
+//        return getField().getMaximumValue();
+//    }
+//
+//    /**
+//     * Gets the maximum value for the field.
+//     * 
+//     * @return the maximum value
+//     * @see DateTimeField#getMaximumValue
+//     */
+//    public int getMaximumValue() {
+//        return getField().getMaximumValue(getPartialInstant(), get());
+//    }
+
+    /**
+     * Gets the maximum text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumTextLength
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return getField().getMaximumTextLength(locale);
+    }
+
+    /**
+     * Gets the maximum short text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumShortTextLength
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return getField().getMaximumShortTextLength(locale);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compare this field to the same field on another instant.
+     * <p>
+     * The {@link #get()} method is used to obtain the value to compare for
+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method
+     * is used for the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public int compareTo(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        int thisValue = get();
+        int otherValue = instant.get(getField());
+        if (thisValue < otherValue) {
+            return -1;
+        } else if (thisValue > otherValue) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    /**
+     * Compare this field to the same field on another partial instant.
+     * <p>
+     * The {@link #get()} method is used to obtain the value to compare for
+     * this instant and the {@link PartialInstant#get(DateTimeField)} method
+     * is used for the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws IllegalArgumentException if the instant is null
+     * @throws IllegalArgumentException if the field of this property cannot be queried
+     *  on the specified instant
+     */
+    public int compareTo(PartialInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        int thisValue = get();
+        int otherValue = instant.get(getField());
+        if (thisValue < otherValue) {
+            return -1;
+        } else if (thisValue > otherValue) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Output a debugging string.
+     * 
+     * @return debugging string
+     */
+    public String toString() {
+        return "Property[" + getName() + "]";
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
new file mode 100644
index 000000000..77acf7990
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
@@ -0,0 +1,169 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.ReadableInstant;
+
+/**
+ * Defines an instant that does not support every datetime field.
+ * <p>
+ * A PartialInstant supports a set of fields and cannot be compared to a
+ * full complete instant. Methods are provided to resolve the partial instant
+ * into a full instant by 'filling in the gaps'.
+ *
+ * @author Stephen Colebourne
+ */
+public interface PartialInstant {
+
+    /**
+     * Gets an array of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     *
+     * @return the fields supported, largest to smallest
+     */
+    DateTimeField[] getSupportedFields();
+
+    /**
+     * Gets the chronology of the partial which is never null.
+     * <p>
+     * The {@link Chronology} is the calculation engine behind the partial and
+     * provides conversion and validation of the fields in a particular calendar system.
+     * 
+     * @return the chronology
+     */
+    Chronology getChronology();
+
+    /**
+     * Get the value of one of the fields of a datetime.
+     * <p>
+     * The field specified must be one of those that is supported by the partial instant.
+     *
+     * @param field  a DateTimeField instance that is supported by this partial
+     * @return the value of that field
+     * @throws IllegalArgumentException if the field is null or not supported
+     */
+    int get(DateTimeField field);
+
+    /**
+     * Checks whether the field specified is supported by this partial instant.
+     *
+     * @param field  the field to check, may be null which returns false
+     * @return true if the field is supported
+     */
+    boolean isSupported(DateTimeField field);
+
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param baseMillis  source of missing fields
+     * @return the combined instant in milliseconds
+     */
+    long resolve(long baseMillis);
+
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param base  the instant that provides the missing fields, null means now
+     * @return the combined datetime
+     */
+    DateTime resolveDateTime(ReadableInstant base);
+
+//    /**
+//     * Compares this object with the specified object for equality based
+//     * on the millisecond instant, the Chronology, and the limiting fields.
+//     * <p>
+//     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
+//     * the chronology), use {@link #isEqual(ReadableInstant)} or
+//     * {@link #compareTo(Object)}.
+//     *
+//     * @param readableInstant  a readable instant to check against
+//     * @return true if millisecond and chronology are equal, false if
+//     *  not or the instant is null or of an incorrect type
+//     */
+//    boolean equals(Object readableInstant);
+//
+//    /**
+//     * Gets a hash code for the instant that is compatable with the 
+//     * equals method.
+//     *
+//     * @return a suitable hash code
+//     */
+//    int hashCode();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value as a String in a recognisable ISO8601 format, only
+     * displaying supported fields.
+     * <p>
+     * The string output is in ISO8601 format to enable the String
+     * constructor to correctly parse it.
+     *
+     * @return the value as an ISO8601 string
+     */
+    String toString();
+
+}
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
new file mode 100644
index 000000000..a447d78c3
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -0,0 +1,713 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.util.Arrays;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.InstantConverter;
+
+/**
+ * TimeOfDay is an immutable partial instant supporting the hour, minute, second
+ * and millisecond fields.
+ * <p>
+ * Each individual field can be queried in two ways:
+ * <ul>
+ * <li><code>getHourOfDay()</code>
+ * <li><code>hourOfDay().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>numeric value
+ * <li>text value
+ * <li>short text value
+ * <li>maximum value
+ * <li>minimum value
+ * </ul>
+ * <p>
+ * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class TimeOfDay implements PartialInstant {
+
+    /** The index of the hourOfDay field in the field array */
+    private static final int HOUR_OF_DAY = 0;
+    /** The index of the minuteOfHour field in the field array */
+    private static final int MINUTE_OF_HOUR = 1;
+    /** The index of the secondOfMinute field in the field array */
+    private static final int SECOND_OF_MINUTE = 2;
+    /** The index of the millisOfSecond field in the field array */
+    private static final int MILLIS_OF_SECOND = 3;
+
+    // TODO: Is chronology needed here?
+    /** The chronology in use */
+    private final Chronology iChronology;
+    /** The fields supported by this partial instant */
+    private final DateTimeField[] iFields;
+    /** The values of each field in this partial instant */
+    private final int[] iValues;
+
+    // TODO serialize
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a TimeOfDay with the current time, using ISOChronology in
+     * the default zone to extract the fields.
+     */
+    public TimeOfDay() {
+        this(DateTimeUtils.currentTimeMillis(), null);
+    }
+
+    /**
+     * Constructs a TimeOfDay with the current time, using the specified chronology
+     * and zone to extract the fields.
+     *
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public TimeOfDay(Chronology chronology) {
+        this(DateTimeUtils.currentTimeMillis(), chronology);
+    }
+
+    /**
+     * Constructs a TimeOfDay extracting the partial fields from the specified
+     * milliseconds using the ISOChronology in the default zone.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public TimeOfDay(long instant) {
+        this(instant, null);
+    }
+
+    /**
+     * Constructs a TimeOfDay extracting the partial fields from the specified
+     * milliseconds using the chronology provided.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public TimeOfDay(long instant, Chronology chronology) {
+        super();
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology;
+        iFields = initFields(chronology);
+        iValues = initValues(instant);
+    }
+
+    /**
+     * Constructs a TimeOfDay from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public TimeOfDay(Object instant) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        Chronology chronology = converter.getChronology(instant);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology;
+        iFields = initFields(chronology);
+        iValues = initValues(converter.getInstantMillis(instant));
+    }
+
+    /**
+     * Constructs a TimeOfDay from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the date is null
+     */
+    public TimeOfDay(Object instant, Chronology chronology) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        Chronology original = converter.getChronology(instant, chronology);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology;
+        iFields = initFields(chronology);
+        iValues = initValues(converter.getInstantMillis(instant, chronology));
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified time field values using
+     * <code>ISOChronology</code> in the default zone.
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the millisecond of the second
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {
+        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified time field values and chronology.
+     * 
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the millisecond of the second
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour,
+            int secondOfMinute, int millisOfSecond, Chronology chronology) {
+        super();
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology;
+        iFields = initFields(chronology);
+        // TODO: Validate
+        iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified fields, values and chronology.
+     *
+     * @param partial  the partial to base this new instance on
+     * @param values  the new set of values
+     */
+    TimeOfDay(TimeOfDay partial, int[] values) {
+        super();
+        iChronology = partial.iChronology;
+        iFields = partial.iFields;
+        iValues = values;
+    }
+
+    /**
+     * Initialize the array of fields.
+     * 
+     * @param chrono  the chronology to use
+     */
+    private DateTimeField[] initFields(Chronology chrono) {
+        return new DateTimeField[] {
+            chrono.hourOfDay(),
+            chrono.minuteOfHour(),
+            chrono.secondOfMinute(),
+            chrono.millisOfSecond(),
+        };
+    }
+
+    /**
+     * Initialize the array of values.
+     * 
+     * @param instant  the instant to use
+     */
+    private int[] initValues(long instant) {
+        return new int[] {
+            iFields[0].get(instant),
+            iFields[1].get(instant),
+            iFields[2].get(instant),
+            iFields[3].get(instant),
+        };
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the field
+     */
+    protected DateTimeField getField(int index) {
+        return iFields[index];
+    }
+    
+    /**
+     * Gets the value of the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the value
+     */
+    protected int getValue(int index) {
+        return iValues[index];
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets an array of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     *
+     * @return the fields supported, largest to smallest
+     */
+    public DateTimeField[] getSupportedFields() {
+        return (DateTimeField[]) iFields.clone();
+    }
+
+    /**
+     * Gets the chronology of the partial which is never null.
+     * <p>
+     * The {@link Chronology} is the calculation engine behind the partial and
+     * provides conversion and validation of the fields in a particular calendar system.
+     * 
+     * @return the chronology
+     */
+    public Chronology getChronology() {
+        return iChronology;
+    }
+
+    /**
+     * Get the value of one of the fields of a datetime.
+     * <p>
+     * The field specified must be one of those that is supported by the partial instant.
+     *
+     * @param field  a DateTimeField instance that is supported by this partial
+     * @return the value of that field
+     * @throws IllegalArgumentException if the field is null or not supported
+     */
+    public int get(DateTimeField field) {
+        for (int i = 0; i < iFields.length; i++) {
+            if (iFields[i] == field) {
+                return iValues[i];
+            }
+        }
+        throw new IllegalArgumentException("Field '" + field + "' is not supported by TimeOfDay");
+    }
+
+    /**
+     * Checks whether the field specified is supported by this partial instant.
+     *
+     * @param field  the field to check, may be null which returns false
+     * @return true if the field is supported
+     */
+    public boolean isSupported(DateTimeField field) {
+        for (int i = 0; i < iFields.length; i++) {
+            if (iFields[i] == field) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param baseMillis  source of missing fields
+     * @return the combined instant in milliseconds
+     */
+    public long resolve(long baseMillis) {
+        long millis = baseMillis;
+        for (int i = 0; i < iFields.length; i++) {
+            millis = iFields[i].set(millis, iValues[i]);
+        }
+        return millis;
+    }
+
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param base  the instant that provides the missing fields, null means now
+     * @return the combined datetime
+     */
+    public DateTime resolveDateTime(ReadableInstant base) {
+        if (base == null) {
+            base = new DateTime();
+        }
+        Chronology chrono = base.getChronology();
+        long millis = base.getMillis();
+        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));
+        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));
+        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));
+        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));
+        return new DateTime(millis, chrono);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day (0-23) field value.
+     *
+     * @return the hour of day
+     */
+    public int getHourOfDay() {
+        return getValue(HOUR_OF_DAY);
+    }
+
+    /**
+     * Get the minute of hour field value.
+     *
+     * @return the minute of hour
+     */
+    public int getMinuteOfHour() {
+        return getValue(MINUTE_OF_HOUR);
+    }
+
+    /**
+     * Get the second of minute field value.
+     *
+     * @return the second of minute
+     */
+    public int getSecondOfMinute() {
+        return getValue(SECOND_OF_MINUTE);
+    }
+
+    /**
+     * Get the millis of second field value.
+     *
+     * @return the millis of second
+     */
+    public int getMillisOfSecond() {
+        return getValue(MILLIS_OF_SECOND);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day (0-23) field property
+     * 
+     * @return the hour of day property
+     */
+    public Property hourOfDay() {
+        return new Property(this, HOUR_OF_DAY);
+    }
+
+    /**
+     * Get the minute of hour field property
+     * 
+     * @return the minute of hour property
+     */
+    public Property minuteOfHour() {
+        return new Property(this, MINUTE_OF_HOUR);
+    }
+
+    /**
+     * Get the second of minute field property
+     * 
+     * @return the second of minute property
+     */
+    public Property secondOfMinute() {
+        return new Property(this, SECOND_OF_MINUTE);
+    }
+
+    /**
+     * Get the millis of second property
+     * 
+     * @return the millis of second property
+     */
+    public Property millisOfSecond() {
+        return new Property(this, MILLIS_OF_SECOND);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this TimeOfDay with another returning true if the fields and
+     * values are equal.
+     *
+     * @param timeOfDay  an object to check against
+     * @return true if fields and values are equal
+     */
+    public boolean equals(Object timeOfDay) {
+        if (timeOfDay instanceof TimeOfDay == false) {
+            return false;
+        }
+        TimeOfDay other = (TimeOfDay) timeOfDay;
+        return Arrays.equals(iValues, other.iValues) &&
+               Arrays.equals(iFields, other.iFields);
+    }
+
+    /**
+     * Gets a hash code for the TimeOfDay that is compatible with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    public int hashCode() {
+        int total = 157;
+        for (int i = 0; i < iValues.length; i++) {
+            total = 23 * total + getValue(i);
+            total += getField(i).hashCode();
+        }
+        return total;
+    }
+
+    /**
+     * Output the time in ISO8601 time only format (hh:mm:ss.SSS).
+     * 
+     * @return ISO8601 time formatted string
+     */
+    public String toString() {
+        // TODO
+        return "";
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * The property class for TimeOfDay.
+     */
+    public static class Property extends AbstractPartialFieldProperty {
+
+        /** The instant */
+        private final TimeOfDay iInstant;
+        /** The field index */
+        private final int iFieldIndex;
+
+        /**
+         * Constructs a property.
+         * 
+         * @param instant  the partial instant
+         * @param field  the field
+         * @param fieldIndex  the index in the instant
+         */
+        Property(TimeOfDay instant, int fieldIndex) {
+            super();
+            iInstant = instant;
+            iFieldIndex = fieldIndex;
+        }
+
+        /**
+         * Gets the field that this property uses.
+         * 
+         * @return the field
+         */
+        public DateTimeField getField() {
+            return iInstant.getField(iFieldIndex);
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public PartialInstant getPartialInstant() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public TimeOfDay getTimeOfDay() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the value of the field that the partial instant is set to.
+         * 
+         * @return the field value
+         */
+        public int get() {
+            return iInstant.getValue(iFieldIndex);
+        }
+
+        //-----------------------------------------------------------------------
+// TODO
+//        /**
+//         * Adds to this field in a copy of this TimeOfDay.
+//         * <p>
+//         * The TimeOnly attached to this property is unchanged by this call.
+//         * 
+//         * @param value  the value to add to the field in the copy
+//         * @return a copy of the TimeOnly with the field value changed
+//         * @throws IllegalArgumentException if the value isn't valid
+//         */
+//        public TimeOfDay addToCopy(int value) {
+//            int[] newValues = getField().add(getInstant(), value);
+//            return new TimeOfDay(getInstant(), newValues);
+//        }
+//
+//        /**
+//         * Adds to this field, possibly wrapped, in a copy of this TimeOfDay.
+//         * A wrapped operation only changes this field.
+//         * Thus 12:59:00 addWrapped one minute goes to 12:00:00.
+//         * <p>
+//         * The TimeOfDay attached to this property is unchanged by this call.
+//         * 
+//         * @param value  the value to add to the field in the copy
+//         * @return a copy of the TimeOfDay with the field value changed
+//         * @throws IllegalArgumentException if the value isn't valid
+//         */
+//        public TimeOfDay addWrappedToCopy(int value) {
+//            int[] newValues = getField().addWrapped(getInstant(), value);
+//            return new TimeOfDay(getInstant(), newValues);
+//        }
+//
+//        //-----------------------------------------------------------------------
+//        /**
+//         * Sets this field in a copy of the TimeOfDay.
+//         * <p>
+//         * The TimeOfDay attached to this property is unchanged by this call.
+//         * 
+//         * @param value  the value to set the field in the copy to
+//         * @return a copy of the TimeOfDay with the field value changed
+//         * @throws IllegalArgumentException if the value isn't valid
+//         */
+//        public TimeOfDay setCopy(int value) {
+//            int[] newValues = getField().set(getInstant(), value);
+//            return new TimeOfDay(getInstant(), newValues);
+//        }
+//    
+//        /**
+//         * Sets this field in a copy of the TimeOfDay to a parsed text value.
+//         * <p>
+//         * The TimeOfDay attached to this property is unchanged by this call.
+//         * 
+//         * @param text  the text value to set
+//         * @param locale  optional locale to use for selecting a text symbol
+//         * @return a copy of the TimeOfDay with the field value changed
+//         * @throws IllegalArgumentException if the text value isn't valid
+//         */
+//        public TimeOfDay setCopy(String text, Locale locale) {
+//            int[] newValues = getField().set(getInstant(), text, locale);
+//            return new TimeOfDay(getInstant(), newValues);
+//        }
+//
+//        /**
+//         * Sets this field in a copy of the TimeOfDay to a parsed text value.
+//         * <p>
+//         * The TimeOfDay attached to this property is unchanged by this call.
+//         * This operation is faster than converting a TimeOfDay to a MutableTimeOfDay
+//         * and back again when setting one field. When setting multiple fields,
+//         * it is generally quicker to make the conversion to MutableTimeOfDay.
+//         * 
+//         * @param text  the text value to set
+//         * @return a copy of the TimeOfDay with the field value changed
+//         * @throws IllegalArgumentException if the text value isn't valid
+//         */
+//        public final TimeOfDay setCopy(String text) {
+//            return setCopy(text, null);
+//        }
+
+//        //-----------------------------------------------------------------------
+//        /**
+//         * Rounds to the lowest whole unit of this field on a copy of this TimeOfDay.
+//         *
+//         * @return a copy of the TimeOfDay with the field value changed
+//         */
+//        public TimeOfDay roundFloorCopy() {
+//            TimeOfDay instant = iInstant;
+//            return (TimeOfDay) instant.withMillis(iField.roundFloor(instant.getMillis()));
+//        }
+//
+//        /**
+//         * Rounds to the highest whole unit of this field on a copy of this TimeOfDay.
+//         *
+//         * @return a copy of the TimeOfDay with the field value changed
+//         */
+//        public TimeOfDay roundCeilingCopy() {
+//            TimeOfDay instant = iInstant;
+//            return (TimeOfDay) instant.withMillis(iField.roundCeiling(instant.getMillis()));
+//        }
+//
+//        /**
+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,
+//         * favoring the floor if halfway.
+//         *
+//         * @return a copy of the TimeOfDay with the field value changed
+//         */
+//        public TimeOfDay roundHalfFloorCopy() {
+//            TimeOfDay instant = iInstant;
+//            return (TimeOfDay) instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
+//        }
+//
+//        /**
+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,
+//         * favoring the ceiling if halfway.
+//         *
+//         * @return a copy of the TimeOfDay with the field value changed
+//         */
+//        public TimeOfDay roundHalfCeilingCopy() {
+//            TimeOfDay instant = iInstant;
+//            return (TimeOfDay) instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
+//        }
+//
+//        /**
+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay.
+//         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+//         *
+//         * @return a copy of the TimeOfDay with the field value changed
+//         */
+//        public TimeOfDay roundHalfEvenCopy() {
+//            TimeOfDay instant = iInstant;
+//            return (TimeOfDay) instant.withMillis(iField.roundHalfEven(instant.getMillis()));
+//        }
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
new file mode 100644
index 000000000..8e254ed87
--- /dev/null
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -0,0 +1,296 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.test.time.partial;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+import org.joda.time.partial.TimeOfDay;
+
+/**
+ * This class is a Junit unit test for TimeOfDay.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestTimeOfDay extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    
+    private long TEST_TIME =
+            10L * DateTimeConstants.MILLIS_PER_HOUR
+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE
+            + 30L * DateTimeConstants.MILLIS_PER_SECOND
+            + 40L;
+            
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestTimeOfDay.class);
+    }
+
+    public TestTimeOfDay(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME);
+        zone = DateTimeZone.getDefault();
+        DateTimeZone.setDefault(DateTimeZone.UTC);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Chronology)
+     */
+    public void testConstructor_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_longChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        // TODO
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_ObjectChronology() throws Throwable {
+        // TODO
+    }
+
+    /**
+     * Test constructor (int, int, int, int)
+     */
+    public void testConstructor_intintintint() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (int, int, int, int, Chronology)
+     */
+    public void testConstructor_intintintintChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    public void testGetField() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));
+        try {
+            test.get(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance().dayOfMonth());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance(PARIS).hourOfDay());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation
+//        try {
+//            test.get(JulianChronology.getInstance().hourOfDay());
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetSupportedFields() {
+        TimeOfDay test = new TimeOfDay();
+        DateTimeField[] fields = test.getSupportedFields();
+        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);
+        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);
+        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);
+        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);
+    }
+
+    public void testIsSupported() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));
+    }
+
+    public void testEqualsHashCode() {
+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(true, test1.equals(test2));
+        assertEquals(true, test2.equals(test1));
+        assertEquals(true, test1.equals(test1));
+        assertEquals(true, test2.equals(test2));
+        assertEquals(test1.hashCode(), test2.hashCode());
+        assertEquals(test1.hashCode(), test1.hashCode());
+        assertEquals(test2.hashCode(), test2.hashCode());
+        
+        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);
+        assertEquals(false, test1.equals(test3));
+        assertEquals(false, test2.equals(test3));
+        assertEquals(false, test3.equals(test1));
+        assertEquals(false, test3.equals(test2));
+        assertTrue(test1.hashCode() != test3.hashCode());
+        assertTrue(test2.hashCode() != test3.hashCode());
+    }
+
+    public void testResolve_long() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        DateTime dt = new DateTime(0L);
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        
+        DateTime result = new DateTime(test.resolve(dt.getMillis()));
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
+    }
+
+    public void testResolve_RI() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        DateTime dt = new DateTime(0L);
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        
+        DateTime result = test.resolveDateTime(dt);
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
+    }
+
+}

From 3746dd47d9bc17c4e5090c4aa49d2307cb0121a1 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 23:23:45 +0000
Subject: [PATCH 0040/1934] Fix getAsText to avoid infinite recursion

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@190 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/field/AbstractDateTimeField.java   | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
index 192bd55ed..8c2606c46 100644
--- a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
@@ -120,7 +120,7 @@ public final boolean isSupported() {
      * Get the human-readable, text value of this field from the milliseconds.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns getAsText(get(instant)).
+     * The default implementation returns getAsText(get(instant), locale).
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @param locale the locale to use for selecting a text symbol, null for
@@ -128,14 +128,14 @@ public final boolean isSupported() {
      * @return the text value of the field
      */
     public String getAsText(long instant, Locale locale) {
-        return getAsText(get(instant));
+        return getAsText(get(instant), locale);
     }
 
     /**
      * Get the human-readable, text value of this field from a partial instant.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns getAsText(fieldValue).
+     * The default implementation returns getAsText(fieldValue, locale).
      *
      * @param partial  the partial instant to query
      * @param fieldValue  the field value of this field, provided for performance
@@ -143,7 +143,7 @@ public String getAsText(long instant, Locale locale) {
      * @return the text value of the field
      */
     public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
-        return getAsText(fieldValue);
+        return getAsText(fieldValue, locale);
     }
 
     /**
@@ -168,21 +168,21 @@ protected String getAsText(int fieldValue, Locale locale) {
      * Get the human-readable, short text value of this field from the milliseconds.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns getAsShortText(get(instant)).
+     * The default implementation returns getAsShortText(get(instant), locale).
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
     public String getAsShortText(long instant, Locale locale) {
-        return getAsShortText(get(instant));
+        return getAsShortText(get(instant), locale);
     }
 
     /**
      * Get the human-readable, short text value of this field from a partial instant.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns getAsShortText(fieldValue).
+     * The default implementation returns getAsShortText(fieldValue, locale).
      *
      * @param partial  the partial instant to query
      * @param fieldValue  the field value of this field, provided for performance
@@ -190,7 +190,7 @@ public String getAsShortText(long instant, Locale locale) {
      * @return the text value of the field
      */
     public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
-        return getAsShortText(fieldValue);
+        return getAsShortText(fieldValue, locale);
     }
 
     /**

From 20f7208f6aa584228a75774409d22170a4ea180c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 23:24:42 +0000
Subject: [PATCH 0041/1934] Remove leap year code as partials cannot determine
 this accurately

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@191 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../partial/AbstractPartialFieldProperty.java | 29 -------------------
 1 file changed, 29 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
index 63064f7d9..f503747f6 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -174,35 +174,6 @@ public DurationField getRangeDurationField() {
         return getField().getRangeDurationField();
     }
 
-// TODO
-//    /**
-//     * Gets whether this field is leap.
-//     * 
-//     * @return true if a leap field
-//     * @see DateTimeField#isLeap
-//     */
-//    public boolean isLeap() {
-//        return getField().isLeap(getPartialInstant(), get());
-//    }
-//
-//    /**
-//     * Gets the amount by which this field is leap.
-//     * 
-//     * @return the amount by which the field is leap
-//     * @see DateTimeField#getLeapAmount
-//     */
-//    public int getLeapAmount() {
-//        return getField().getLeapAmount(getPartialInstant(), get());
-//    }
-
-    /**
-     * If this field were to leap, then it would be in units described by the
-     * returned duration. If this field doesn't ever leap, null is returned.
-     */
-    public DurationField getLeapDurationField() {
-        return getField().getLeapDurationField();
-    }
-
     //-----------------------------------------------------------------------
 // TODO
 //    /**

From ef7e9471cdeaa35b803857fc2535c23f6eef475f Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 23:25:22 +0000
Subject: [PATCH 0042/1934] Update resolve() and add equals/hashCode

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@192 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/partial/PartialInstant.java | 51 ++++++++++---------
 1 file changed, 26 insertions(+), 25 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
index 77acf7990..e1daee0cc 100644
--- a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
@@ -56,6 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
 
 /**
@@ -108,16 +109,17 @@
     boolean isSupported(DateTimeField field);
 
     /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * Resolves this partial against another complete millisecond instant to
+     * create a new full instant specifying the time zone to resolve with.
      * <p>
      * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
+     * will be the datetime from the specified base plus the time from this instant
+     * set using the time zone specified.
      *
      * @param baseMillis  source of missing fields
      * @return the combined instant in milliseconds
      */
-    long resolve(long baseMillis);
+    long resolve(long baseMillis, DateTimeZone zone);
 
     /**
      * Resolves this partial against another complete instant to create a new
@@ -132,27 +134,26 @@
      */
     DateTime resolveDateTime(ReadableInstant base);
 
-//    /**
-//     * Compares this object with the specified object for equality based
-//     * on the millisecond instant, the Chronology, and the limiting fields.
-//     * <p>
-//     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
-//     * the chronology), use {@link #isEqual(ReadableInstant)} or
-//     * {@link #compareTo(Object)}.
-//     *
-//     * @param readableInstant  a readable instant to check against
-//     * @return true if millisecond and chronology are equal, false if
-//     *  not or the instant is null or of an incorrect type
-//     */
-//    boolean equals(Object readableInstant);
-//
-//    /**
-//     * Gets a hash code for the instant that is compatable with the 
-//     * equals method.
-//     *
-//     * @return a suitable hash code
-//     */
-//    int hashCode();
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this partial with the specified object for equality based
+     * on the implementation class, supported fields, chronology and values.
+     * <p>
+     * Instances of PartialInstant are not generally comparable to one another
+     * as the comparison is based on the implementation class.
+     *
+     * @param object  the object to compare to
+     * @return true if equal
+     */
+    boolean equals(Object object);
+
+    /**
+     * Gets a hash code for the instant that is compatible with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    int hashCode();
 
     //-----------------------------------------------------------------------
     /**

From 524a3429ae5a7c2e77f468895ae933e4856bd17f Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 23:27:08 +0000
Subject: [PATCH 0043/1934] Remove explicit field array Rework resolve

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@193 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/partial/TimeOfDay.java | 148 +++++++++++-------
 1 file changed, 92 insertions(+), 56 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index a447d78c3..0b06ea3f0 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -53,12 +53,14 @@
  */
 package org.joda.time.partial;
 
+import java.io.Serializable;
 import java.util.Arrays;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
 import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
@@ -68,6 +70,9 @@
  * TimeOfDay is an immutable partial instant supporting the hour, minute, second
  * and millisecond fields.
  * <p>
+ * Calculations on TimeOfDay are performed using a {@link Chronology}.
+ * This chronology is set to be in the UTC time zone for all calculations.
+ * <p>
  * Each individual field can be queried in two ways:
  * <ul>
  * <li><code>getHourOfDay()</code>
@@ -90,7 +95,10 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class TimeOfDay implements PartialInstant {
+public final class TimeOfDay implements PartialInstant, Serializable {
+
+    /** Serialization version */
+    private static final long serialVersionUID = 3633353405803318660L;
 
     /** The index of the hourOfDay field in the field array */
     private static final int HOUR_OF_DAY = 0;
@@ -101,21 +109,20 @@
     /** The index of the millisOfSecond field in the field array */
     private static final int MILLIS_OF_SECOND = 3;
 
-    // TODO: Is chronology needed here?
     /** The chronology in use */
     private final Chronology iChronology;
-    /** The fields supported by this partial instant */
-    private final DateTimeField[] iFields;
     /** The values of each field in this partial instant */
     private final int[] iValues;
 
-    // TODO serialize
-
     // Constructors
     //-----------------------------------------------------------------------
     /**
      * Constructs a TimeOfDay with the current time, using ISOChronology in
      * the default zone to extract the fields.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
      */
     public TimeOfDay() {
         this(DateTimeUtils.currentTimeMillis(), null);
@@ -124,6 +131,10 @@ public TimeOfDay() {
     /**
      * Constructs a TimeOfDay with the current time, using the specified chronology
      * and zone to extract the fields.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
      *
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
@@ -134,6 +145,10 @@ public TimeOfDay(Chronology chronology) {
     /**
      * Constructs a TimeOfDay extracting the partial fields from the specified
      * milliseconds using the ISOChronology in the default zone.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
@@ -144,6 +159,10 @@ public TimeOfDay(long instant) {
     /**
      * Constructs a TimeOfDay extracting the partial fields from the specified
      * milliseconds using the chronology provided.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      * @param chronology  the chronology, null means ISOChronology in the default zone
@@ -153,9 +172,8 @@ public TimeOfDay(long instant, Chronology chronology) {
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        iChronology = chronology;
-        iFields = initFields(chronology);
-        iValues = initValues(instant);
+        iValues = initValues(instant, chronology);
+        iChronology = chronology.withUTC();
     }
 
     /**
@@ -175,9 +193,8 @@ public TimeOfDay(Object instant) {
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        iChronology = chronology;
-        iFields = initFields(chronology);
-        iValues = initValues(converter.getInstantMillis(instant));
+        iValues = initValues(converter.getInstantMillis(instant), chronology);
+        iChronology = chronology.withUTC();
     }
 
     /**
@@ -187,6 +204,10 @@ public TimeOfDay(Object instant) {
      * The recognised object types are defined in
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
      *
      * @param instant  the datetime object, must not be null
      * @param chronology  the chronology, null means ISOChronology
@@ -199,14 +220,17 @@ public TimeOfDay(Object instant, Chronology chronology) {
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        iChronology = chronology;
-        iFields = initFields(chronology);
-        iValues = initValues(converter.getInstantMillis(instant, chronology));
+        iValues = initValues(converter.getInstantMillis(instant, chronology), chronology);
+        iChronology = chronology.withUTC();
     }
 
     /**
      * Constructs a TimeOfDay with specified time field values using
      * <code>ISOChronology</code> in the default zone.
+     * <p>
+     * The constructor uses the no time zone initialising the fields as provided.
+     * Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
      *
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
@@ -219,7 +243,10 @@ public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millis
 
     /**
      * Constructs a TimeOfDay with specified time field values and chronology.
-     * 
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
      *
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
@@ -233,10 +260,9 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        iChronology = chronology;
-        iFields = initFields(chronology);
         // TODO: Validate
         iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};
+        iChronology = chronology.withUTC();
     }
 
     /**
@@ -248,35 +274,21 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
     TimeOfDay(TimeOfDay partial, int[] values) {
         super();
         iChronology = partial.iChronology;
-        iFields = partial.iFields;
         iValues = values;
     }
 
-    /**
-     * Initialize the array of fields.
-     * 
-     * @param chrono  the chronology to use
-     */
-    private DateTimeField[] initFields(Chronology chrono) {
-        return new DateTimeField[] {
-            chrono.hourOfDay(),
-            chrono.minuteOfHour(),
-            chrono.secondOfMinute(),
-            chrono.millisOfSecond(),
-        };
-    }
-
     /**
      * Initialize the array of values.
      * 
      * @param instant  the instant to use
+     * @param chrono  the chronology to use
      */
-    private int[] initValues(long instant) {
+    private int[] initValues(long instant, Chronology chrono) {
         return new int[] {
-            iFields[0].get(instant),
-            iFields[1].get(instant),
-            iFields[2].get(instant),
-            iFields[3].get(instant),
+            chrono.hourOfDay().get(instant),
+            chrono.minuteOfHour().get(instant),
+            chrono.secondOfMinute().get(instant),
+            chrono.millisOfSecond().get(instant),
         };
     }
 
@@ -288,7 +300,18 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
      * @return the field
      */
     protected DateTimeField getField(int index) {
-        return iFields[index];
+        switch (index) {
+            case HOUR_OF_DAY:
+                return iChronology.hourOfDay();
+            case MINUTE_OF_HOUR:
+                return iChronology.minuteOfHour();
+            case SECOND_OF_MINUTE:
+                return iChronology.secondOfMinute();
+            case MILLIS_OF_SECOND:
+                return iChronology.millisOfSecond();
+            default:
+                throw new IllegalArgumentException();
+        }
     }
     
     /**
@@ -310,7 +333,12 @@ protected int getValue(int index) {
      * @return the fields supported, largest to smallest
      */
     public DateTimeField[] getSupportedFields() {
-        return (DateTimeField[]) iFields.clone();
+        return new DateTimeField[] {
+            iChronology.hourOfDay(),
+            iChronology.minuteOfHour(),
+            iChronology.secondOfMinute(),
+            iChronology.millisOfSecond(),
+        };
     }
 
     /**
@@ -335,10 +363,17 @@ public Chronology getChronology() {
      * @throws IllegalArgumentException if the field is null or not supported
      */
     public int get(DateTimeField field) {
-        for (int i = 0; i < iFields.length; i++) {
-            if (iFields[i] == field) {
-                return iValues[i];
-            }
+        if (iChronology.hourOfDay() == field) {
+            return getValue(HOUR_OF_DAY);
+        }
+        if (iChronology.minuteOfHour() == field) {
+            return getValue(MINUTE_OF_HOUR);
+        }
+        if (iChronology.secondOfMinute() == field) {
+            return getValue(SECOND_OF_MINUTE);
+        }
+        if (iChronology.millisOfSecond() == field) {
+            return getValue(MILLIS_OF_SECOND);
         }
         throw new IllegalArgumentException("Field '" + field + "' is not supported by TimeOfDay");
     }
@@ -350,12 +385,11 @@ public int get(DateTimeField field) {
      * @return true if the field is supported
      */
     public boolean isSupported(DateTimeField field) {
-        for (int i = 0; i < iFields.length; i++) {
-            if (iFields[i] == field) {
-                return true;
-            }
-        }
-        return false;
+        return 
+            iChronology.hourOfDay() == field ||
+            iChronology.minuteOfHour() == field ||
+            iChronology.secondOfMinute() == field ||
+            iChronology.millisOfSecond() == field;
     }
 
     //-----------------------------------------------------------------------
@@ -369,11 +403,13 @@ public boolean isSupported(DateTimeField field) {
      * @param baseMillis  source of missing fields
      * @return the combined instant in milliseconds
      */
-    public long resolve(long baseMillis) {
+    public long resolve(long baseMillis, DateTimeZone zone) {
+        Chronology chrono = iChronology.withZone(zone);
         long millis = baseMillis;
-        for (int i = 0; i < iFields.length; i++) {
-            millis = iFields[i].set(millis, iValues[i]);
-        }
+        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));
+        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));
+        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));
+        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));
         return millis;
     }
 
@@ -489,7 +525,7 @@ public boolean equals(Object timeOfDay) {
         }
         TimeOfDay other = (TimeOfDay) timeOfDay;
         return Arrays.equals(iValues, other.iValues) &&
-               Arrays.equals(iFields, other.iFields);
+               iChronology == other.iChronology;
     }
 
     /**
@@ -502,8 +538,8 @@ public int hashCode() {
         int total = 157;
         for (int i = 0; i < iValues.length; i++) {
             total = 23 * total + getValue(i);
-            total += getField(i).hashCode();
         }
+        total += iChronology.hashCode();
         return total;
     }
 

From 906205a213eeedc41b2f4deb9802f75d85947a9c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 2 May 2004 23:27:54 +0000
Subject: [PATCH 0044/1934] Update resolve test and add tests for property

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@194 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/test/time/partial/TestTimeOfDay.java | 21 ++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 8e254ed87..86e303b62 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -53,6 +53,8 @@
  */
 package org.joda.test.time.partial;
 
+import java.util.Locale;
+
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
@@ -266,7 +268,7 @@ public void testResolve_long() {
         DateTime dt = new DateTime(0L);
         assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
         
-        DateTime result = new DateTime(test.resolve(dt.getMillis()));
+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));
         assertEquals(10, test.getHourOfDay());
         assertEquals(20, test.getMinuteOfHour());
         assertEquals(30, test.getSecondOfMinute());
@@ -293,4 +295,21 @@ public void testResolve_RI() {
         assertEquals("1970-01-01T10:20:30.040Z", result.toString());
     }
 
+    public void testProperty() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());
+        assertEquals("hourOfDay", test.hourOfDay().getName());
+        assertSame(test, test.hourOfDay().getPartialInstant());
+        assertSame(test, test.hourOfDay().getTimeOfDay());
+        assertEquals(10, test.hourOfDay().get());
+        assertEquals("10", test.hourOfDay().getAsText());
+        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));
+        assertEquals("10", test.hourOfDay().getAsShortText());
+        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());
+        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());
+        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));
+        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
+    }
+
 }

From e1927ec87106ffbba3efef78204eefc016d3eb95 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 9 May 2004 14:11:44 +0000
Subject: [PATCH 0045/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@195 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/field/MillisDurationField.java   | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
index 851af285b..617d9bf5c 100644
--- a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
@@ -65,12 +65,18 @@
  * @author Brian S O'Neill
  */
 public final class MillisDurationField implements DurationField, Serializable {
-    
-    static final long serialVersionUID = 2656707858124633367L;
 
+    /** Serialization version. */
+    private static final long serialVersionUID = 2656707858124633367L;
+
+    /** Singleton instance. */
     public static final DurationField INSTANCE = new MillisDurationField();
 
+    /**
+     * Restricted constructor.
+     */
     private MillisDurationField() {
+        super();
     }
     
     //------------------------------------------------------------------------
@@ -79,6 +85,8 @@ public String getName() {
     }
 
     /**
+     * Returns true as this field is supported.
+     * 
      * @return true always
      */
     public boolean isSupported() {
@@ -86,14 +94,14 @@ public boolean isSupported() {
     }
 
     /**
-     * This field is precise.
+     * Returns true as this field is precise.
      * 
      * @return true always
      */
     public final boolean isPrecise() {
         return true;
     }
-    
+
     /**
      * Returns the amount of milliseconds per unit value of this field.
      *
@@ -178,7 +186,7 @@ public String toString() {
     }
 
     /**
-     * Serialization singleton
+     * Deserialize to the singleton.
      */
     private Object readResolve() {
         return INSTANCE;

From e0a8fe92b6607ba1869a5866ac5d1e8742b89058 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 9 May 2004 14:12:47 +0000
Subject: [PATCH 0046/1934] Remove final

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@196 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/partial/AbstractPartialFieldProperty.java   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
index f503747f6..22e258192 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -128,7 +128,7 @@ public String getAsText(Locale locale) {
      * @return the current text value
      * @see DateTimeField#getAsText
      */
-    public final String getAsText() {
+    public String getAsText() {
         return getAsText(null);
     }
 
@@ -149,7 +149,7 @@ public String getAsShortText(Locale locale) {
      * @return the current text value
      * @see DateTimeField#getAsShortText
      */
-    public final String getAsShortText() {
+    public String getAsShortText() {
         return getAsShortText(null);
     }
 

From 07ae1b8e83e3120ee6163a62bdb0ad47f14fc3ea Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 9 May 2004 14:22:38 +0000
Subject: [PATCH 0047/1934] Fix method details

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@197 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/partial/TimeOfDay.java | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 0b06ea3f0..766b3e6e5 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -216,7 +216,6 @@ public TimeOfDay(Object instant) {
     public TimeOfDay(Object instant, Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        Chronology original = converter.getChronology(instant, chronology);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
@@ -299,7 +298,7 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
      * @param index  the index
      * @return the field
      */
-    protected DateTimeField getField(int index) {
+    DateTimeField getField(int index) {
         switch (index) {
             case HOUR_OF_DAY:
                 return iChronology.hourOfDay();
@@ -320,7 +319,7 @@ protected DateTimeField getField(int index) {
      * @param index  the index
      * @return the value
      */
-    protected int getValue(int index) {
+    int getValue(int index) {
         return iValues[index];
     }
     
@@ -401,6 +400,7 @@ public boolean isSupported(DateTimeField field) {
      * will be the date from the specified base plus the time from this instant.
      *
      * @param baseMillis  source of missing fields
+     * @param zone  the zone to use, null means default
      * @return the combined instant in milliseconds
      */
     public long resolve(long baseMillis, DateTimeZone zone) {

From bd965bb674a58ffd2e36a8617ae1b54175926bf3 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 9 May 2004 14:43:53 +0000
Subject: [PATCH 0048/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@198 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/field/DecoratedDateTimeField.java   |  5 ++++-
 .../org/joda/time/field/DelegatedDateTimeField.java   | 11 +++++++++++
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
index 5599b4d1e..be7ed1c0d 100644
--- a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
@@ -82,7 +82,10 @@
     private final DateTimeField iField;
 
     /**
-     * @param name allow name to be overridden
+     * Constructor.
+     * 
+     * @param field  the field being decorated
+     * @param name  allow name to be overridden
      */
     protected DecoratedDateTimeField(DateTimeField field, String name) {
         super(name);
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index c7669a717..30be9cc6b 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -80,10 +80,21 @@
     /** A desriptive name for the field */
     private final String iName;
 
+    /**
+     * Constructor.
+     * 
+     * @param field  the field being decorated
+     */
     protected DelegatedDateTimeField(DateTimeField field) {
         this(field, null);
     }
 
+    /**
+     * Constructor.
+     * 
+     * @param field  the field being decorated
+     * @param name  the name of the field
+     */
     protected DelegatedDateTimeField(DateTimeField field, String name) {
         super();
         if (field == null) {

From 1a816f691b617a5f5a07f0c79a335b870a4e7165 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 15 May 2004 06:06:37 +0000
Subject: [PATCH 0049/1934] Explit order applied to initialization of
 constants.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@199 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/chrono/ISOChronology.java | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index 91f8f167d..b0cf3978e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -89,17 +89,18 @@
     private static final long serialVersionUID = -6212696554273812441L;
 
     /** Singleton instance of a UTC ISOChronology */
-    private static final ISOChronology INSTANCE_UTC =
-        new ISOChronology(GregorianChronology.getInstanceUTC());
+    private static final ISOChronology INSTANCE_UTC;
         
     private static final int FAST_CACHE_SIZE = 64;
 
     /** Fast cache of zone to chronology */
-    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];
+    private static final ISOChronology[] cFastCache;
 
     /** Cache of zone to chronology */
     private static final Map cCache = new HashMap();
     static {
+        cFastCache = new ISOChronology[FAST_CACHE_SIZE];
+        INSTANCE_UTC = new ISOChronology(GregorianChronology.getInstanceUTC());
         cCache.put(DateTimeZone.UTC, INSTANCE_UTC);
     }
 

From eb0cac2be7678d8c6b3c2bde3aff15eb4ca982f1 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 15 May 2004 06:08:59 +0000
Subject: [PATCH 0050/1934] Fix for bug 954058, which caused an
 ExceptionInInitializerError to be thrown if the system property
 "user.timezone" specified an explicit offset.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@200 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeZone.java  | 13 ++++++++++++-
 .../joda/time/format/DateTimeFormatterBuilder.java | 14 ++++++++++----
 2 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index b3833aa4c..18405b405 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -139,6 +139,17 @@
         setProvider0(null);
         setNameProvider0(null);
 
+        // Because of the cyclic initializer dependencies between many of the
+        // main classes, and because cOffsetFormatter is built from those main
+        // classes, a user time zone with an explicit offset fails. Rather than
+        // duplicate all the code used by DateTimeFormatterBuilder's offset
+        // formatter, DateTimeFormatterBuilder's constructor tests if
+        // DateTimeZone.getDefault() is null, in which case it allows the
+        // chronology to be null. This breaks the dependency cycle and allows
+        // cOffsetFormatter to be defined. In order for this inelegant solution
+        // to work propery, cDefault must be left as null until after an
+        // attempt has been made to set the user time zone.
+
         try {
             try {
                 cDefault = getInstance(System.getProperty("user.timezone"));
@@ -400,7 +411,7 @@ private static synchronized String getConvertedId(String id) {
 
     private static synchronized DateTimeFormatter offsetFormatter() {
         if (cOffsetFormatter == null) {
-            cOffsetFormatter = new DateTimeFormatterBuilder(UTC)
+            cOffsetFormatter = new DateTimeFormatterBuilder((Chronology)null, null)
                 .appendTimeZoneOffset(null, true, 2, 4)
                 .toFormatter();
         }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 00617e354..16bcc1a03 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -141,14 +141,20 @@ public DateTimeFormatterBuilder(final Chronology chrono) {
      */
     public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {
         if (chrono == null) {
-            chrono = ISOChronology.getInstance();
+            if (DateTimeZone.getDefault() == null) {
+                // See DateTimeZone's static initializer for details on this
+                // special case.
+                iChrono = iChronoUTC = null;
+            } else {
+                iChrono = iChronoUTC = ISOChronology.getInstance();
+            }
+        } else {
+            iChrono = chrono;
+            iChronoUTC = chrono.withUTC();
         }
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        iChrono = chrono;
-        iChronoUTC = chrono.withUTC();
-        DateTimeZone zone = chrono.getZone();
         iLocale = locale;
         iElementPairs = new ArrayList();
     }

From aecb61159d6b54798a6b450ae655054299a9806f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 15 May 2004 06:17:12 +0000
Subject: [PATCH 0051/1934] Fixed usage message.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@201 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/example/org/joda/example/time/DateTimeBrowser.java    | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
index b62e7b792..72a2fba69 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
@@ -183,7 +183,9 @@ public static void main(String[] args) {
      */
     private static void usage() {
             System.err.println("Usage:");
-            System.err.println("DateTimeBrowser <options> <filename>");
+            System.err.print("java <options> ");
+            System.err.print(DateTimeBrowser.class.getName());
+            System.err.println(" <filename>");
             System.err.println("<filename> contains a list of Strings");
             System.err.println("\twhich are valid for DateTime instantiation.");
             System.err.println("<optons>");

From 7502788280a604032faebeae23bf0ae380560b8a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 16 May 2004 12:39:47 +0000
Subject: [PATCH 0052/1934] Rename AbstractDateTimeField to BaseDateTimeField

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@202 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/BuddhistEraDateTimeField.java    | 4 ++--
 .../java/org/joda/time/chrono/CopticEraDateTimeField.java | 4 ++--
 JodaTime/src/java/org/joda/time/chrono/GJChronology.java  | 4 ++--
 .../src/java/org/joda/time/chrono/GJEraDateTimeField.java | 4 ++--
 .../src/java/org/joda/time/chrono/ZonedChronology.java    | 4 ++--
 ...{AbstractDateTimeField.java => BaseDateTimeField.java} | 8 ++++----
 .../java/org/joda/time/field/DecoratedDateTimeField.java  | 6 +++---
 .../java/org/joda/time/field/ImpreciseDateTimeField.java  | 4 ++--
 .../org/joda/time/field/PreciseDurationDateTimeField.java | 2 +-
 9 files changed, 20 insertions(+), 20 deletions(-)
 rename JodaTime/src/java/org/joda/time/field/{AbstractDateTimeField.java => BaseDateTimeField.java} (98%)

diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
index 27f3cae6b..7c7019d51 100644
--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
 
@@ -68,7 +68,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-final class BuddhistEraDateTimeField extends AbstractDateTimeField {
+final class BuddhistEraDateTimeField extends BaseDateTimeField {
     
     /** Serialization version */
     private static final long serialVersionUID = -9175876774456816364L;
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
index 9212c9bb0..26a2a8403 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
 
@@ -67,7 +67,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-final class CopticEraDateTimeField extends AbstractDateTimeField {
+final class CopticEraDateTimeField extends BaseDateTimeField {
     
     /** Serialization version */
     private static final long serialVersionUID = 4090856468123006167L;
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index c27d6b4e6..e28324e99 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -66,7 +66,7 @@
 import org.joda.time.DurationField;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.DecoratedDurationField;
 import org.joda.time.format.DateTimePrinter;
 import org.joda.time.format.ISODateTimeFormat;
@@ -599,7 +599,7 @@ long gregorianToJulianByWeekyear(long instant) {
      * This basic cutover field adjusts calls to 'get' and 'set' methods, and
      * assumes that calls to add and addWrapped are unaffected by the cutover.
      */
-    private class CutoverField extends AbstractDateTimeField {
+    private class CutoverField extends BaseDateTimeField {
         static final long serialVersionUID = 3528501219481026402L;
 
         final DateTimeField iJulianField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
index 4d49ad5c4..81356ebb4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
-import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
 
@@ -69,7 +69,7 @@
  * @version 1.0
  * @since 1.0
  */
-final class GJEraDateTimeField extends AbstractDateTimeField {
+final class GJEraDateTimeField extends BaseDateTimeField {
     
     /** Serialization version */
     private static final long serialVersionUID = 4240986525305515528L;
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index d2a22b71c..9b97d1f1a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -61,7 +61,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
-import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.AbstractDurationField;
 
 /**
@@ -355,7 +355,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * This class converts passed in instants to local wall time, and vice
      * versa on output.
      */
-    static final class ZonedDateTimeField extends AbstractDateTimeField {
+    static final class ZonedDateTimeField extends BaseDateTimeField {
         static final long serialVersionUID = -3968986277775529794L;
 
         final DateTimeField iField;
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 8c2606c46..60935cf74 100644
--- a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -61,21 +61,21 @@
 import org.joda.time.partial.PartialInstant;
 
 /**
- * AbstractDateTimeField provides the common behaviour for DateTimeField
+ * BaseDateTimeField provides the common behaviour for DateTimeField
  * implementations. 
  * <p>
  * This class should generally not be used directly by API users. The
  * DateTimeField interface should be used when different kinds of DateTimeField
  * objects are to be referenced.
  * <p>
- * AbstractDateTimeField is thread-safe and immutable, and its subclasses must
+ * BaseDateTimeField is thread-safe and immutable, and its subclasses must
  * be as well.
  *
  * @author Brian S O'Neill
  * @since 1.0
  * @see DecoratedDateTimeField
  */
-public abstract class AbstractDateTimeField extends DateTimeField implements Serializable {
+public abstract class BaseDateTimeField extends DateTimeField implements Serializable {
 
     /** Serialization version */
     private static final long serialVersionUID = -4388055220581798589L;
@@ -86,7 +86,7 @@
     /**
      * Constructor.
      */
-    protected AbstractDateTimeField(String name) {
+    protected BaseDateTimeField(String name) {
         super();
         if (name == null) {
             throw new IllegalArgumentException("The name must not be null");
diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
index be7ed1c0d..49f24f11c 100644
--- a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
@@ -57,13 +57,13 @@
 import org.joda.time.DurationField;
 
 /**
- * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},
+ * <code>DecoratedDateTimeField</code> extends {@link BaseDateTimeField},
  * implementing only the minimum required set of methods. These implemented
  * methods delegate to a wrapped field.
  * <p>
  * This design allows new DateTimeField types to be defined that piggyback on
  * top of another, inheriting all the safe method implementations from
- * AbstractDateTimeField. Should any method require pure delegation to the
+ * BaseDateTimeField. Should any method require pure delegation to the
  * wrapped field, simply override and use the provided getWrappedField method.
  * <p>
  * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must
@@ -73,7 +73,7 @@
  * @since 1.0
  * @see DelegatedDateTimeField
  */
-public abstract class DecoratedDateTimeField extends AbstractDateTimeField {
+public abstract class DecoratedDateTimeField extends BaseDateTimeField {
 
     /** Serialization version */
     private static final long serialVersionUID = 203115783733757597L;
diff --git a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
index d57c3127b..6c3dd2365 100644
--- a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
@@ -64,7 +64,7 @@
  * {@link PreciseDateTimeField} should be used instead.
  * <p>
  * When defining imprecise DateTimeFields where a matching DurationField is
- * already available, just extend AbstractDateTimeField directly so as not to
+ * already available, just extend BaseDateTimeField directly so as not to
  * create redundant DurationField instances.
  * <p>
  * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must
@@ -73,7 +73,7 @@
  * @author Brian S O'Neill
  * @see PreciseDateTimeField
  */
-public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {
+public abstract class ImpreciseDateTimeField extends BaseDateTimeField {
 
     static final long serialVersionUID = 7190739608550251860L;
 
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
index fa804a770..3956069f1 100644
--- a/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
@@ -63,7 +63,7 @@
  *
  * @author Brian S O'Neill
  */
-public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {
+public abstract class PreciseDurationDateTimeField extends BaseDateTimeField {
 
     static final long serialVersionUID = 5004523158306266035L;
 

From 7ab0e5ac2557a0e59260898b287f8f89f9d16d95 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 16 May 2004 12:43:51 +0000
Subject: [PATCH 0053/1934] Remove unecessary casts

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@203 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/property/DateOnlyFieldProperty.java  | 20 +++++++++----------
 .../time/property/DateTimeFieldProperty.java  | 20 +++++++++----------
 .../time/property/TimeOnlyFieldProperty.java  | 20 +++++++++----------
 3 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
index e781ee61b..4e80957bf 100644
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -150,7 +150,7 @@ public DateOnly getDateOnly() {
      */
     public DateOnly addToCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -167,7 +167,7 @@ public DateOnly addToCopy(int value) {
      */
     public DateOnly addToCopy(long value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -186,7 +186,7 @@ public DateOnly addToCopy(long value) {
      */
     public DateOnly addWrappedToCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
+        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -204,7 +204,7 @@ public DateOnly addWrappedToCopy(int value) {
      */
     public DateOnly setCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.set(instant.getMillis(), value));
+        return instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -222,7 +222,7 @@ public DateOnly setCopy(int value) {
      */
     public DateOnly setCopy(String text, Locale locale) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.set(instant.getMillis(), text, locale));
+        return instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -249,7 +249,7 @@ public final DateOnly setCopy(String text) {
      */
     public DateOnly roundFloorCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.roundFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -259,7 +259,7 @@ public DateOnly roundFloorCopy() {
      */
     public DateOnly roundCeilingCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.roundCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -270,7 +270,7 @@ public DateOnly roundCeilingCopy() {
      */
     public DateOnly roundHalfFloorCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -281,7 +281,7 @@ public DateOnly roundHalfFloorCopy() {
      */
     public DateOnly roundHalfCeilingCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -292,7 +292,7 @@ public DateOnly roundHalfCeilingCopy() {
      */
     public DateOnly roundHalfEvenCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index 7463576ec..be8e6f28f 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -152,7 +152,7 @@ public DateTime getDateTime() {
      */
     public DateTime addToCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -169,7 +169,7 @@ public DateTime addToCopy(int value) {
      */
     public DateTime addToCopy(long value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -188,7 +188,7 @@ public DateTime addToCopy(long value) {
      */
     public DateTime addWrappedToCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
+        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -206,7 +206,7 @@ public DateTime addWrappedToCopy(int value) {
      */
     public DateTime setCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.set(instant.getMillis(), value));
+        return instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -224,7 +224,7 @@ public DateTime setCopy(int value) {
      */
     public DateTime setCopy(String text, Locale locale) {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.set(instant.getMillis(), text, locale));
+        return instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -251,7 +251,7 @@ public final DateTime setCopy(String text) {
      */
     public DateTime roundFloorCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -261,7 +261,7 @@ public DateTime roundFloorCopy() {
      */
     public DateTime roundCeilingCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.roundCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -272,7 +272,7 @@ public DateTime roundCeilingCopy() {
      */
     public DateTime roundHalfFloorCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -283,7 +283,7 @@ public DateTime roundHalfFloorCopy() {
      */
     public DateTime roundHalfCeilingCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -294,7 +294,7 @@ public DateTime roundHalfCeilingCopy() {
      */
     public DateTime roundHalfEvenCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
index 528dc1f05..cf85f9a86 100644
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -150,7 +150,7 @@ public TimeOnly getTimeOnly() {
      */
     public TimeOnly addToCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -167,7 +167,7 @@ public TimeOnly addToCopy(int value) {
      */
     public TimeOnly addToCopy(long value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.add(instant.getMillis(), value));
+        return instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -186,7 +186,7 @@ public TimeOnly addToCopy(long value) {
      */
     public TimeOnly addWrappedToCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
+        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -204,7 +204,7 @@ public TimeOnly addWrappedToCopy(int value) {
      */
     public TimeOnly setCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.set(instant.getMillis(), value));
+        return instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -222,7 +222,7 @@ public TimeOnly setCopy(int value) {
      */
     public TimeOnly setCopy(String text, Locale locale) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.set(instant.getMillis(), text, locale));
+        return instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -249,7 +249,7 @@ public final TimeOnly setCopy(String text) {
      */
     public TimeOnly roundFloorCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.roundFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -259,7 +259,7 @@ public TimeOnly roundFloorCopy() {
      */
     public TimeOnly roundCeilingCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.roundCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -270,7 +270,7 @@ public TimeOnly roundCeilingCopy() {
      */
     public TimeOnly roundHalfFloorCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -281,7 +281,7 @@ public TimeOnly roundHalfFloorCopy() {
      */
     public TimeOnly roundHalfCeilingCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -292,7 +292,7 @@ public TimeOnly roundHalfCeilingCopy() {
      */
     public TimeOnly roundHalfEvenCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
+        return instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }

From dc281ce23550136680863097623d8e5aa3bb576b Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 16 May 2004 15:11:50 +0000
Subject: [PATCH 0054/1934] PartialInstant set method

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@204 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 28 ++++++-
 .../joda/time/field/BaseDateTimeField.java    | 33 +++++++-
 .../time/field/DelegatedDateTimeField.java    |  4 +
 .../time/field/UnsupportedDateTimeField.java  |  9 +++
 .../org/joda/time/partial/PartialInstant.java | 39 +++++++++-
 .../java/org/joda/time/partial/TimeOfDay.java | 78 ++++++++++++-------
 .../joda/test/time/partial/TestTimeOfDay.java | 57 +++++++++++++-
 7 files changed, 213 insertions(+), 35 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index b51265936..66a8ec1f2 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -299,8 +299,13 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
     /**
      * Sets a value in the milliseconds supplied.
      * <p>
-     * The value of this field will be set. If the value is invalid, an
-     * exception if thrown. Other fields are always unaffected.
+     * The value of this field will be set.
+     * If the value is invalid, an exception if thrown.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
      * 
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param value  the value to set, in the units of the field
@@ -309,6 +314,25 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      */
     public abstract long set(long instant, int value);
 
+    /**
+     * Sets a value using the specified partial instant.
+     * <p>
+     * The value of this field (specified by the index) will be set.
+     * If the value is invalid, an exception if thrown.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param value  the value to set, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public abstract int[] set(PartialInstant instant, int fieldIndex, int value);
+
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
      * value. If the specified locale is null, the default locale is used.
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 60935cf74..67f9ba3e6 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -331,8 +331,13 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
     /**
      * Sets a value in the milliseconds supplied.
      * <p>
-     * The value of this field will be set. If the value is invalid, an
-     * exception if thrown. Other fields are always unaffected.
+     * The value of this field will be set.
+     * If the value is invalid, an exception if thrown.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
      * 
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param value  the value to set, in the units of the field
@@ -341,6 +346,30 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      */
     public abstract long set(long instant, int value);
 
+    /**
+     * Sets a value using the specified partial instant.
+     * <p>
+     * The value of this field (specified by the index) will be set.
+     * If the value is invalid, an exception if thrown.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param value  the value to set, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public int[] set(PartialInstant instant, int fieldIndex, int value) {
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        int[] array = instant.getValues();
+        array[fieldIndex] = value;
+        return array;
+    }
+
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
      * value. If the specified locale is null, the default locale is used.
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 30be9cc6b..122f052bf 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -193,6 +193,10 @@ public long set(long instant, String text) {
         return iField.set(instant, text);
     }
 
+    public int[] set(PartialInstant instant, int fieldIndex, int value) {
+        return iField.set(instant, fieldIndex, value);
+    }
+
     public DurationField getDurationField() {
         return iField.getDurationField();
     }
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index ccf4852c4..98113f8be 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -238,6 +238,15 @@ public long set(long instant, int value) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int[] set(PartialInstant instant, int fieldIndex, int value) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
diff --git a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
index e1daee0cc..c7af3c0cb 100644
--- a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
@@ -70,14 +70,49 @@
  */
 public interface PartialInstant {
 
+    /**
+     * Gets the number of fields that this instant supports.
+     *
+     * @return the number of fields supported
+     */
+    int getFieldSize();
+
+    /**
+     * Gets the field at the specified index.
+     *
+     * @param index  the index to retrieve
+     * @return the field at the specified index
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    DateTimeField getField(int index);
+
     /**
      * Gets an array of the fields that this partial instant supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      *
-     * @return the fields supported, largest to smallest
+     * @return the fields supported (cloned), largest to smallest
+     */
+    DateTimeField[] getFields();
+
+    /**
+     * Gets the value at the specified index.
+     *
+     * @param index  the index to retrieve
+     * @return the value of the field at the specified index
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    int getValue(int index);
+
+    /**
+     * Gets an array of the value of each of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     * Each value corresponds to the same array index as <code>getFields()</code>
+     *
+     * @return the current values of each field (cloned), largest to smallest
      */
-    DateTimeField[] getSupportedFields();
+    int[] getValues();
 
     /**
      * Gets the chronology of the partial which is never null.
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 766b3e6e5..d78cb5d20 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -101,13 +101,13 @@
     private static final long serialVersionUID = 3633353405803318660L;
 
     /** The index of the hourOfDay field in the field array */
-    private static final int HOUR_OF_DAY = 0;
+    public static final int HOUR_OF_DAY = 0;
     /** The index of the minuteOfHour field in the field array */
-    private static final int MINUTE_OF_HOUR = 1;
+    public static final int MINUTE_OF_HOUR = 1;
     /** The index of the secondOfMinute field in the field array */
-    private static final int SECOND_OF_MINUTE = 2;
+    public static final int SECOND_OF_MINUTE = 2;
     /** The index of the millisOfSecond field in the field array */
-    private static final int MILLIS_OF_SECOND = 3;
+    public static final int MILLIS_OF_SECOND = 3;
 
     /** The chronology in use */
     private final Chronology iChronology;
@@ -292,13 +292,23 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
     }
 
     //-----------------------------------------------------------------------
+    /**
+     * Gets the number of fields in TimeOfDay.
+     * 
+     * @return the field count
+     */
+    public int getFieldSize() {
+        return 4;
+    }
+
     /**
      * Gets the field at the specifed index.
      * 
      * @param index  the index
      * @return the field
+     * @throws IndexOutOfBoundsException if the index is invalid
      */
-    DateTimeField getField(int index) {
+    public DateTimeField getField(int index) {
         switch (index) {
             case HOUR_OF_DAY:
                 return iChronology.hourOfDay();
@@ -309,29 +319,33 @@ DateTimeField getField(int index) {
             case MILLIS_OF_SECOND:
                 return iChronology.millisOfSecond();
             default:
-                throw new IllegalArgumentException();
+                throw new IllegalArgumentException(Integer.toString(index));
         }
     }
-    
+
     /**
      * Gets the value of the field at the specifed index.
      * 
      * @param index  the index
      * @return the value
+     * @throws IndexOutOfBoundsException if the index is invalid
      */
-    int getValue(int index) {
+    public int getValue(int index) {
+        if (index < 0 || index > 4) {
+            throw new IllegalArgumentException(Integer.toString(index));
+        }
         return iValues[index];
     }
-    
+
     //-----------------------------------------------------------------------
     /**
      * Gets an array of the fields that this partial instant supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      *
-     * @return the fields supported, largest to smallest
+     * @return the fields supported (cloned), largest to smallest
      */
-    public DateTimeField[] getSupportedFields() {
+    public DateTimeField[] getFields() {
         return new DateTimeField[] {
             iChronology.hourOfDay(),
             iChronology.minuteOfHour(),
@@ -340,6 +354,18 @@ int getValue(int index) {
         };
     }
 
+    /**
+     * Gets an array of the value of each of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     * Each value corresponds to the same array index as <code>getFields()</code>
+     *
+     * @return the current values of each field (cloned), largest to smallest
+     */
+    public int[] getValues() {
+        return (int[]) iValues.clone();
+    }
+
     /**
      * Gets the chronology of the partial which is never null.
      * <p>
@@ -645,21 +671,21 @@ public int get() {
 //            return new TimeOfDay(getInstant(), newValues);
 //        }
 //
-//        //-----------------------------------------------------------------------
-//        /**
-//         * Sets this field in a copy of the TimeOfDay.
-//         * <p>
-//         * The TimeOfDay attached to this property is unchanged by this call.
-//         * 
-//         * @param value  the value to set the field in the copy to
-//         * @return a copy of the TimeOfDay with the field value changed
-//         * @throws IllegalArgumentException if the value isn't valid
-//         */
-//        public TimeOfDay setCopy(int value) {
-//            int[] newValues = getField().set(getInstant(), value);
-//            return new TimeOfDay(getInstant(), newValues);
-//        }
-//    
+        //-----------------------------------------------------------------------
+        /**
+         * Sets this field in a copy of the TimeOfDay.
+         * <p>
+         * The TimeOfDay attached to this property is unchanged by this call.
+         * 
+         * @param value  the value to set the field in the copy to
+         * @return a copy of the TimeOfDay with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public TimeOfDay setCopy(int value) {
+            int[] newValues = getField().set(iInstant, iFieldIndex, value);
+            return new TimeOfDay(iInstant, newValues);
+        }
+
 //        /**
 //         * Sets this field in a copy of the TimeOfDay to a parsed text value.
 //         * <p>
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 86e303b62..78a4e25d9 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -195,7 +195,7 @@ public void testConstructor_intintintintChronology() throws Throwable {
         assertEquals(40, test.getMillisOfSecond());
     }
 
-    public void testGetField() {
+    public void testGet() {
         TimeOfDay test = new TimeOfDay();
         assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));
         assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));
@@ -220,15 +220,57 @@ public void testGetField() {
 //        } catch (IllegalArgumentException ex) {}
     }
 
-    public void testGetSupportedFields() {
+    public void testGetFieldSize() {
         TimeOfDay test = new TimeOfDay();
-        DateTimeField[] fields = test.getSupportedFields();
+        assertEquals(4, test.getFieldSize());
+    }
+
+    public void testGetField() {
+        TimeOfDay test = new TimeOfDay();
+        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));
+        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));
+        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));
+        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));
+        try {
+            test.getField(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getField(5);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetFields() {
+        TimeOfDay test = new TimeOfDay();
+        DateTimeField[] fields = test.getFields();
         assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);
         assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);
         assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);
         assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);
     }
 
+    public void testGetValue() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(10, test.getValue(0));
+        assertEquals(20, test.getValue(1));
+        assertEquals(30, test.getValue(2));
+        assertEquals(40, test.getValue(3));
+        try {
+            test.getValue(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getValue(5);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetValues() {
+        TimeOfDay test = new TimeOfDay();
+        int[] values = test.getValues();
+        assertEquals(10, values[0]);
+        assertEquals(20, values[1]);
+        assertEquals(30, values[2]);
+        assertEquals(40, values[3]);
+    }
+
     public void testIsSupported() {
         TimeOfDay test = new TimeOfDay();
         assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));
@@ -312,4 +354,13 @@ public void testProperty() {
         assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
     }
 
+    public void testPropertySet() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.hourOfDay().setCopy(12);
+        assertEquals(12, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
 }

From e962cbde6f664bb68e7df67703d77ef660ef0de4 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 16 May 2004 16:08:46 +0000
Subject: [PATCH 0055/1934] PartialInstant getMax/getMin methods

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@205 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 16 ++++
 .../time/chrono/AbstractGJChronology.java     | 10 +++
 .../chrono/CopticDayOfMonthDateTimeField.java | 16 ++++
 .../chrono/GJDayOfMonthDateTimeField.java     | 13 +++
 .../time/chrono/GJDayOfYearDateTimeField.java | 14 +++-
 .../chrono/GJWeekOfWeekyearDateTimeField.java | 14 +++-
 .../joda/time/field/BaseDateTimeField.java    | 26 +++++-
 .../time/field/DelegatedDateTimeField.java    |  8 ++
 .../joda/time/field/NonZeroDateTimeField.java | 20 +++++
 .../time/field/UnsupportedDateTimeField.java  | 18 +++++
 .../partial/AbstractPartialFieldProperty.java | 79 +++++++++----------
 .../joda/test/time/partial/TestTimeOfDay.java |  6 +-
 12 files changed, 192 insertions(+), 48 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 66a8ec1f2..25978dbfb 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -418,6 +418,14 @@ public long set(long instant, String text) {
      */
     public abstract int getMinimumValue(long instant);
 
+    /**
+     * Get the minimum value for this field evaluated at the specified time.
+     * 
+     * @param instant  the partial instant to query
+     * @return the minimum value for this field, in the units of the field
+     */
+    public abstract int getMinimumValue(PartialInstant instant);
+
     /**
      * Get the maximum allowable value for this field.
      * 
@@ -434,6 +442,14 @@ public long set(long instant, String text) {
      */
     public abstract int getMaximumValue(long instant);
 
+    /**
+     * Get the maximum value for this field evaluated at the specified time.
+     * 
+     * @param instant  the partial instant to query
+     * @return the maximum value for this field, in the units of the field
+     */
+    public abstract int getMaximumValue(PartialInstant instant);
+
     /**
      * Get the maximum text value for this field.
      * 
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 7721bfcd4..9bc424585 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -434,6 +434,16 @@ final int getDaysInYearMonth(int year, int month) {
         }
     }
 
+    /**
+     * Gets the maximum days in the specified month.
+     * 
+     * @param month  the month
+     * @return the max days
+     */
+    final int getDaysInMonthMax(int month) {
+        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];
+    }
+
     /**
      * Returns the total number of milliseconds elapsed in the year, by the end
      * of the month.
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
index ccc443c55..5d310cdcc 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
@@ -55,6 +55,7 @@
 
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -99,6 +100,21 @@ public int getMaximumValue(long instant) {
 		return iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;
     }
 
+    public int getMaximumValue(PartialInstant instant) {
+        if (instant.isSupported(iChronology.monthOfYear())) {
+            int month = instant.get(iChronology.monthOfYear());
+            if (month <= 12) {
+                return 30;
+            }
+            if (instant.isSupported(iChronology.year())) {
+                int year = instant.get(iChronology.year());
+                return iChronology.isLeapYear(year) ? 6 : 5;
+            }
+            return 6;
+        }
+        return 30;
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
index 092424f09..0139b6f76 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
@@ -55,6 +55,7 @@
 
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -106,6 +107,18 @@ public int getMaximumValue(long instant) {
         return iChronology.getDaysInYearMonth(thisYear, thisMonth);
     }
 
+    public int getMaximumValue(PartialInstant instant) {
+        if (instant.isSupported(iChronology.monthOfYear())) {
+            int month = instant.get(iChronology.monthOfYear());
+            if (instant.isSupported(iChronology.year())) {
+                int year = instant.get(iChronology.year());
+                return iChronology.getDaysInYearMonth(year, month);
+            }
+            return iChronology.getDaysInMonthMax(month);
+        }
+        return 31;
+    }
+
     protected int getMaximumValueForSet(long instant, int value) {
         return value > 28 ? getMaximumValue(instant) : 28;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
index 45ad5b696..7733889ea 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
@@ -53,9 +53,9 @@
  */
 package org.joda.time.chrono;
 
-import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Provides time calculations for the day of the year component of time.
@@ -102,8 +102,16 @@ public int getMaximumValue() {
     }
 
     public int getMaximumValue(long instant) {
-        int thisYear = iChronology.getYear(instant);
-        return iChronology.getDaysInYear(thisYear);
+        int year = iChronology.getYear(instant);
+        return iChronology.getDaysInYear(year);
+    }
+
+    public int getMaximumValue(PartialInstant instant) {
+        if (instant.isSupported(iChronology.year())) {
+            int year = instant.get(iChronology.year());
+            return iChronology.getDaysInYear(year);
+        }
+        return 366;
     }
 
     protected int getMaximumValueForSet(long instant, int value) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
index 074fb4031..c00bbeee9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
@@ -54,9 +54,9 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Provides time calculations for the week of a week based year component of time.
@@ -122,8 +122,16 @@ public int getMaximumValue() {
     }
 
     public int getMaximumValue(long instant) {
-        int thisYear = iChronology.getWeekyear(instant);
-        return iChronology.getWeeksInYear(thisYear);
+        int weekyear = iChronology.getWeekyear(instant);
+        return iChronology.getWeeksInYear(weekyear);
+    }
+
+    public int getMaximumValue(PartialInstant instant) {
+        if (instant.isSupported(iChronology.weekyear())) {
+            int weekyear = instant.get(iChronology.weekyear());
+            return iChronology.getWeeksInYear(weekyear);
+        }
+        return 53;
     }
 
     protected int getMaximumValueForSet(long instant, int value) {
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 67f9ba3e6..88c58ba88 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -364,7 +364,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public int[] set(PartialInstant instant, int fieldIndex, int value) {
-        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(instant), getMaximumValue(instant));
         int[] array = instant.getValues();
         array[fieldIndex] = value;
         return array;
@@ -470,6 +470,18 @@ public int getMinimumValue(long instant) {
         return getMinimumValue();
     }
 
+    /**
+     * Get the minimum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMinimumValue()}.
+     * 
+     * @param instant  the partial instant to query
+     * @return the minimum value for this field, in the units of the field
+     */
+    public int getMinimumValue(PartialInstant instant) {
+        return getMinimumValue();
+    }
+
     /**
      * Get the maximum allowable value for this field.
      * 
@@ -490,6 +502,18 @@ public int getMaximumValue(long instant) {
         return getMaximumValue();
     }
 
+    /**
+     * Get the maximum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMaximumValue()}.
+     * 
+     * @param instant  the partial instant to query
+     * @return the maximum value for this field, in the units of the field
+     */
+    public int getMaximumValue(PartialInstant instant) {
+        return getMaximumValue();
+    }
+
     /**
      * Get the maximum text value for this field. The default implementation
      * returns the equivalent of Integer.toString(getMaximumValue()).length().
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 122f052bf..6fdaf9869 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -225,6 +225,10 @@ public int getMinimumValue(long instant) {
         return iField.getMinimumValue(instant);
     }
 
+    public int getMinimumValue(PartialInstant instant) {
+        return iField.getMinimumValue(instant);
+    }
+
     public int getMaximumValue() {
         return iField.getMaximumValue();
     }
@@ -233,6 +237,10 @@ public int getMaximumValue(long instant) {
         return iField.getMaximumValue(instant);
     }
 
+    public int getMaximumValue(PartialInstant instant) {
+        return iField.getMaximumValue(instant);
+    }
+
     public int getMaximumTextLength(Locale locale) {
         return iField.getMaximumTextLength(locale);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index fdf4d6f3b..6f3d263b2 100644
--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -55,6 +55,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Wraps another field such that zero values are replaced with one more than
@@ -148,6 +149,15 @@ public int getMinimumValue(long instant) {
         return 1;
     }
 
+    /**
+     * Always returns 1.
+     * 
+     * @return the minimum value of 1
+     */
+    public int getMinimumValue(PartialInstant instant) {
+        return 1;
+    }
+
     /**
      * Get the maximum value for the field, which is one more than the wrapped
      * field's maximum value.
@@ -168,6 +178,16 @@ public int getMaximumValue(long instant) {
         return getWrappedField().getMaximumValue(instant) + 1;
     }
 
+    /**
+     * Get the maximum value for the field, which is one more than the wrapped
+     * field's maximum value.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue(PartialInstant instant) {
+        return getWrappedField().getMaximumValue(instant) + 1;
+    }
+
     public long roundFloor(long instant) {
         return getWrappedField().roundFloor(instant);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index 98113f8be..340c266cb 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -320,6 +320,15 @@ public int getMinimumValue(long instant) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue(PartialInstant instant) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
@@ -338,6 +347,15 @@ public int getMaximumValue(long instant) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue(PartialInstant instant) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
index 22e258192..3b545b663 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -175,46 +175,45 @@ public DurationField getRangeDurationField() {
     }
 
     //-----------------------------------------------------------------------
-// TODO
-//    /**
-//     * Gets the minimum value for the field ignoring the current time.
-//     * 
-//     * @return the minimum value
-//     * @see DateTimeField#getMinimumValue
-//     */
-//    public int getMinimumValueOverall() {
-//        return getField().getMinimumValue();
-//    }
-//
-//    /**
-//     * Gets the minimum value for the field.
-//     * 
-//     * @return the minimum value
-//     * @see DateTimeField#getMinimumValue
-//     */
-//    public int getMinimumValue() {
-//        return getField().getMinimumValue(getPartialInstant(), get());
-//    }
-//
-//    /**
-//     * Gets the maximum value for the field ignoring the current time.
-//     * 
-//     * @return the maximum value
-//     * @see DateTimeField#getMaximumValue
-//     */
-//    public int getMaximumValueOverall() {
-//        return getField().getMaximumValue();
-//    }
-//
-//    /**
-//     * Gets the maximum value for the field.
-//     * 
-//     * @return the maximum value
-//     * @see DateTimeField#getMaximumValue
-//     */
-//    public int getMaximumValue() {
-//        return getField().getMaximumValue(getPartialInstant(), get());
-//    }
+    /**
+     * Gets the minimum value for the field ignoring the current time.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValueOverall() {
+        return getField().getMinimumValue();
+    }
+
+    /**
+     * Gets the minimum value for this field given the current field values.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValue() {
+        return getField().getMinimumValue(getPartialInstant());
+    }
+
+    /**
+     * Gets the maximum value for the field ignoring the current time.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValueOverall() {
+        return getField().getMaximumValue();
+    }
+
+    /**
+     * Gets the maximum value for this field given the current field values.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValue() {
+        return getField().getMaximumValue(getPartialInstant());
+    }
 
     /**
      * Gets the maximum text length for the field.
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 78a4e25d9..7e1912ee5 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -337,7 +337,7 @@ public void testResolve_RI() {
         assertEquals("1970-01-01T10:20:30.040Z", result.toString());
     }
 
-    public void testProperty() {
+    public void testPropertyGet() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
         assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());
         assertEquals("hourOfDay", test.hourOfDay().getName());
@@ -352,6 +352,10 @@ public void testProperty() {
         assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());
         assertEquals(2, test.hourOfDay().getMaximumTextLength(null));
         assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
+        assertEquals(0, test.hourOfDay().getMinimumValue());
+        assertEquals(0, test.hourOfDay().getMinimumValueOverall());
+        assertEquals(23, test.hourOfDay().getMaximumValue());
+        assertEquals(23, test.hourOfDay().getMaximumValueOverall());
     }
 
     public void testPropertySet() {

From d5aa189126dc33a5edfbbc79189a711ebf280f65 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Wed, 19 May 2004 16:34:34 +0000
Subject: [PATCH 0056/1934] Typo fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@206 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/faq.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/faq.xml b/JodaTime/xdocs/faq.xml
index 27a32cba0..84558e884 100644
--- a/JodaTime/xdocs/faq.xml
+++ b/JodaTime/xdocs/faq.xml
@@ -108,7 +108,7 @@ This would severely compromise the performance of the whole API for a very limit
 <p>
 Joda-Time is      designed for performance. Compared to java.util.Calendar,
 java.text.SimpleDateFormat, and java.util.TimeZone, nearly all equivalent
-operations in Java-Time are faster. The significant exceptions are operations
+operations in Joda-Time are faster. The significant exceptions are operations
 to get or set an individual field.
 </p>
 <p>

From 2dc985890a094c36b34c25c7fd6c4b7eaacf05dd Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 25 May 2004 14:52:22 +0000
Subject: [PATCH 0057/1934] Removed double 'it'

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@207 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index d2c7a126b..a64e9fc2f 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -21,7 +21,7 @@ Supporting classes include time zone, duration, format and parsing.
 
 <p>
 The decision to create a cleanroom date implementation to replace Java's is based on the flaws in the JDK code.
-Date should have been immutable, like String, instead it it is mutable and has many deprecated methods.
+Date should have been immutable, like String, instead it is mutable and has many deprecated methods.
 Calendar makes accessing 'normal' dates difficult, due to the lack of simple methods.
 It also has some strange performance characteristics as it recalculates fields at unexpected moments.
 </p>

From 7d66f03134a4376940815785716d95e3e79b806a Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 28 May 2004 02:44:16 +0000
Subject: [PATCH 0058/1934] Fix javadoc param tags

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@208 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 88c58ba88..2454a69d1 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -155,7 +155,7 @@ public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
      * Note: subclasses that override this method should also override
      * getMaximumTextLength.
      *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param fieldValue  the numeric value to convert to text
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
@@ -202,7 +202,7 @@ public String getAsShortText(PartialInstant partial, int fieldValue, Locale loca
      * Note: subclasses that override this method should also override
      * getMaximumShortTextLength.
      *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param fieldValue  the numeric value to convert to text
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */

From 6a138f4f359bcd1e2575fa2ec1e477e1fab5af80 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 28 May 2004 02:44:56 +0000
Subject: [PATCH 0059/1934] Updated to version 2004a

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@209 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/tz/src/Readme.txt  |  2 +-
 JodaTime/src/java/org/joda/time/tz/src/asia   | 30 +++++++++++--------
 .../src/java/org/joda/time/tz/src/backward    |  4 +--
 JodaTime/src/java/org/joda/time/tz/src/europe |  5 +++-
 .../java/org/joda/time/tz/src/northamerica    | 19 ++++++++----
 .../java/org/joda/time/tz/src/southamerica    | 17 +++++++----
 6 files changed, 50 insertions(+), 27 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
index d4a52c7aa..12210d136 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
+++ b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
@@ -1,2 +1,2 @@
 The data files in this directory were obtained from the public tz database,
-http://www.twinsun.com/tz/tz-link.htm, version 2003e.
+http://www.twinsun.com/tz/tz-link.htm, version 2004a.
diff --git a/JodaTime/src/java/org/joda/time/tz/src/asia b/JodaTime/src/java/org/joda/time/tz/src/asia
index 97a7b1377..923526fda 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/asia
+++ b/JodaTime/src/java/org/joda/time/tz/src/asia
@@ -1,4 +1,4 @@
-# @(#)asia	7.73
+# @(#)asia	7.74
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -380,7 +380,7 @@ Zone	Asia/Dili	8:22:20 -	LMT	1912
 
 # India
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	Asia/Calcutta	5:53:28 -	LMT	1880
+Zone	Asia/Calcutta	5:53:28 -	LMT	1880	# Kolkata
 			5:53:20	-	HMT	1941 Oct    # Howrah Mean Time?
 			6:30	-	BURT	1942 May 15 # Burma Time
 			5:30	-	IST	1942 Sep
@@ -1012,17 +1012,13 @@ Rule	NBorneo	1935	1941	-	Sep	14	0:00	0:20	TS # one-Third Summer
 Rule	NBorneo	1935	1941	-	Dec	14	0:00	0	-
 #
 # peninsular Malaysia
-# From Paul Eggert (2003-11-01):
 # The data here are taken from Mok Ly Yng (2003-10-30)
 # <http://www.math.nus.edu.sg/aslaksen/teaching/timezone.html>.
-# Before 1901, Penang, Malacca and Singapore each had their own time zone;
-# assume Kuala Lumpur used Malaccan time.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone Asia/Kuala_Lumpur	6:46:48 -	LMT	1880
-			6:49:00	-	MMT	1901 Jan  1 # Malacca Mean Time
+Zone Asia/Kuala_Lumpur	6:46:46 -	LMT	1901 Jan  1
 			6:55:25	-	SMT	1905 Jun  1 # Singapore M.T.
 			7:00	-	MALT	1933 Jan  1 # Malaya Time
-			7:00	0:20	MALST	1936
+			7:00	0:20	MALST	1936 Jan  1
 			7:20	-	MALT	1941 Sep  1
 			7:30	-	MALT	1942 Feb 16
 			9:00	-	JST	1945 Sep 12
@@ -1089,6 +1085,15 @@ Zone	Indian/Maldives	4:54:00 -	LMT	1880	# Male
 #
 # [The province of Selenge is omitted from the above lists.]
 
+# From Ganbold Ts., Ulaanbaatar <ganbold@micom.mng.net> (2004-04-17):
+# Daylight saving occurs at 02:00 local time last Saturday of March.
+# It will change back to normal at 02:00 local time last Saturday of
+# September.... As I remember this rule was changed in 2001.
+#
+# From Paul Eggert (2004-04-17):
+# For now, assume Rives McDow's informant got confused about Friday vs
+# Saturday, and that his 2001 dates should have 1 added to them.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Mongol	1983	1984	-	Apr	1	0:00	1:00	S
 Rule	Mongol	1983	only	-	Oct	1	0:00	0	-
@@ -1098,8 +1103,9 @@ Rule	Mongol	1983	only	-	Oct	1	0:00	0	-
 Rule	Mongol	1985	1998	-	Mar	lastSun	2:00s	1:00	S
 Rule	Mongol	1984	1998	-	Sep	lastSun	2:00s	0	-
 # IATA SSIM (1999-09) says Mongolia no longer observes DST.
-Rule	Mongol	2001	only	-	Apr	27	2:00s	1:00	S
-Rule	Mongol	2001	only	-	Sep	28	2:00s	0	-
+Rule	Mongol	2001	only	-	Apr	lastSat	2:00	1:00	S
+Rule	Mongol	2001	max	-	Sep	lastSat	2:00	0	-
+Rule	Mongol	2002	max	-	Mar	lastSat	2:00	1:00	S
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 # Hovd, a.k.a. Chovd, Dund-Us, Dzhargalant, Khovd, Jirgalanta
@@ -1309,10 +1315,10 @@ Zone	Asia/Riyadh	3:06:52 -	LMT	1950
 # The data here are taken from Mok Ly Yng (2003-10-30)
 # <http://www.math.nus.edu.sg/aslaksen/teaching/timezone.html>.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	Asia/Singapore	6:55:25 -	LMT	1880
+Zone	Asia/Singapore	6:55:25 -	LMT	1901 Jan  1
 			6:55:25	-	SMT	1905 Jun  1 # Singapore M.T.
 			7:00	-	MALT	1933 Jan  1 # Malaya Time
-			7:00	0:20	MALST	1936
+			7:00	0:20	MALST	1936 Jan  1
 			7:20	-	MALT	1941 Sep  1
 			7:30	-	MALT	1942 Feb 16
 			9:00	-	JST	1945 Sep 12
diff --git a/JodaTime/src/java/org/joda/time/tz/src/backward b/JodaTime/src/java/org/joda/time/tz/src/backward
index 766a1e32d..c72e946d5 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/backward
+++ b/JodaTime/src/java/org/joda/time/tz/src/backward
@@ -1,4 +1,4 @@
-# @(#)backward	7.24
+# @(#)backward	7.25
 
 # This file provides links between current names for time zones
 # and their old names.  Many names changed in late 1993.
@@ -65,7 +65,7 @@ Link	Africa/Tripoli		Libya
 Link	America/Tijuana		Mexico/BajaNorte
 Link	America/Mazatlan	Mexico/BajaSur
 Link	America/Mexico_City	Mexico/General
-Link	America/Denver		Navajo
+Link	America/Shiprock	Navajo
 Link	Pacific/Auckland	NZ
 Link	Pacific/Chatham		NZ-CHAT
 Link	Pacific/Pago_Pago	Pacific/Samoa
diff --git a/JodaTime/src/java/org/joda/time/tz/src/europe b/JodaTime/src/java/org/joda/time/tz/src/europe
index dc7b78052..8fc653973 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/europe
+++ b/JodaTime/src/java/org/joda/time/tz/src/europe
@@ -1,4 +1,4 @@
-# @(#)europe	7.86
+# @(#)europe	7.87
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -707,6 +707,9 @@ Zone	Europe/Sofia	1:33:16 -	LMT	1880
 # Croatia
 # see Serbia and Montenegro
 
+# Cyprus
+# See the `asia' file.
+
 # Czech Republic
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Czech	1945	only	-	Apr	 8	2:00s	1:00	S
diff --git a/JodaTime/src/java/org/joda/time/tz/src/northamerica b/JodaTime/src/java/org/joda/time/tz/src/northamerica
index 61058bb76..93cac8dd1 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/northamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/northamerica
@@ -1,4 +1,4 @@
-# @(#)northamerica	7.67
+# @(#)northamerica	7.69
 # also includes Central America and the Caribbean
 
 # This data is by no means authoritative; if you think you know better,
@@ -193,10 +193,6 @@ Rule	US	1987	max	-	Apr	Sun>=1	2:00	1:00	D
 #	Samoa standard time
 # The law doesn't give abbreviations.
 #
-# From Paul Eggert (1995-12-19):
-# Shanks uses 1983-10-30, not 1983-11-30, for the 1983 transitions.
-# Go with Shanks.
-#
 # From Paul Eggert (2000-01-08), following a heads-up from Rives McDow:
 # Public law 106-564 (2000-12-23) introduced the abbreviation
 # "Chamorro Standard Time" for time in Guam and the Northern Marianas.
@@ -323,13 +319,14 @@ Zone America/Juneau	 15:02:19 -	LMT	1867 Oct 18
 			 -8:00	US	P%sT	1946
 			 -8:00	-	PST	1969
 			 -8:00	US	P%sT	1983 Oct 30 2:00
+			 -9:00	US	Y%sT	1983 Nov 30
 			 -9:00	US	AK%sT
 Zone America/Yakutat	 14:41:05 -	LMT	1867 Oct 18
 			 -9:18:55 -	LMT	1900 Aug 20 12:00
 			 -9:00	-	YST	1942
 			 -9:00	US	Y%sT	1946
 			 -9:00	-	YST	1969
-			 -9:00	US	Y%sT	1983 Oct 30 2:00
+			 -9:00	US	Y%sT	1983 Nov 30
 			 -9:00	US	AK%sT
 Zone America/Anchorage	 14:00:24 -	LMT	1867 Oct 18
 			 -9:59:36 -	LMT	1900 Aug 20 12:00
@@ -338,6 +335,7 @@ Zone America/Anchorage	 14:00:24 -	LMT	1867 Oct 18
 			-10:00	-	CAT	1967 Apr
 			-10:00	-	AHST	1969
 			-10:00	US	AH%sT	1983 Oct 30 2:00
+			 -9:00	US	Y%sT	1983 Nov 30
 			 -9:00	US	AK%sT
 Zone America/Nome	 12:58:21 -	LMT	1867 Oct 18
 			-11:01:38 -	LMT	1900 Aug 20 12:00
@@ -346,6 +344,7 @@ Zone America/Nome	 12:58:21 -	LMT	1867 Oct 18
 			-11:00	-	NST	1967 Apr
 			-11:00	-	BST	1969
 			-11:00	US	B%sT	1983 Oct 30 2:00
+			 -9:00	US	Y%sT	1983 Nov 30
 			 -9:00	US	AK%sT
 Zone America/Adak	 12:13:21 -	LMT	1867 Oct 18
 			-11:46:38 -	LMT	1900 Aug 20 12:00
@@ -354,6 +353,7 @@ Zone America/Adak	 12:13:21 -	LMT	1867 Oct 18
 			-11:00	-	NST	1967 Apr
 			-11:00	-	BST	1969
 			-11:00	US	B%sT	1983 Oct 30 2:00
+			-10:00	US	AH%sT	1983 Nov 30
 			-10:00	US	HA%sT
 # Shanks writes that part of southwest Alaska (e.g. Aniak)
 # switched from -11:00 to -10:00 on 1968-09-22 at 02:00,
@@ -989,6 +989,13 @@ Rule	Toronto	1922	1923	-	May	Sun>=8	2:00	1:00	D
 # Shanks says 1923-09-19; assume it's a typo and that "-16" was meant.
 Rule	Toronto	1922	1926	-	Sep	Sun>=15	2:00	0	S
 Rule	Toronto	1924	1927	-	May	Sun>=1	2:00	1:00	D
+# The 1927-to-1939 rules can be expressed more simply as
+# Rule	Toronto	1927	1937	-	Sep	Sun>=25	2:00	0	S
+# Rule	Toronto	1928	1937	-	Apr	Sun>=25	2:00	1:00	D
+# Rule	Toronto	1938	1940	-	Apr	lastSun	2:00	1:00	D
+# Rule	Toronto	1938	1939	-	Sep	lastSun	2:00	0	S
+# The rules below avoid use of Sun>=25
+# (which pre-2004 versions of zic cannot handle).
 Rule	Toronto	1927	1932	-	Sep	lastSun	2:00	0	S
 Rule	Toronto	1928	1931	-	Apr	lastSun	2:00	1:00	D
 Rule	Toronto	1932	only	-	May	1	2:00	1:00	D
diff --git a/JodaTime/src/java/org/joda/time/tz/src/southamerica b/JodaTime/src/java/org/joda/time/tz/src/southamerica
index 3373756f8..3c7f6385f 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/southamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/southamerica
@@ -1,4 +1,4 @@
-# @(#)southamerica	7.50
+# @(#)southamerica	7.51
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -141,6 +141,13 @@ Rule	Arg	2000	only	-	Mar	Sun>=1	0:00	0	-
 # This kind of things had always been done this way in Argentina.
 # We are still -03:00 all year round in all of the country.
 #
+# From Mariano Absatz (2004-05-21):
+# Today it was officially published that the Province of Mendoza is changing
+# its timezone this winter... starting tomorrow night....
+# http://www.gobernac.mendoza.gov.ar/boletin/pdf/20040521-27158-normas.pdf
+# From Paul Eggert (2004-05-24):
+# It's Law No. 7,210.  This change is due to a public power emergency, so for
+# now we'll assume it's for this year only.
 #
 # From Paul Eggert (2002-01-22):
 # <a href="http://www.spicasc.net/horvera.html">
@@ -232,6 +239,8 @@ Zone America/Mendoza	-4:35:16 -	LMT	1894 Oct 31
 			-4:00	-	WART	1992 Oct 18
 			-3:00	Arg	AR%sT	1999 Oct  3
 			-4:00	Arg	AR%sT	2000 Mar  3
+			-3:00	-	ART	2004 May 23
+			-4:00	-	WART	2004 Oct 17
 			-3:00	-	ART
 
 # Aruba
@@ -389,8 +398,8 @@ Rule	Brazil	1992	only	-	Oct	25	 0:00	1:00	S
 Rule	Brazil	1993	only	-	Jan	31	 0:00	0	-
 # Decree <a href="http://pcdsh01.on.br/HV942.htm">942</a> (1993-09-28)
 # adopted by same states, plus AM.
-# Decree <a href="http://pcdsh01.on.br/HV1252.htm">1,252</a> (1994-09-22)
-# adopted by same states, minus AM and MT.
+# Decree <a href="http://pcdsh01.on.br/HV1252.htm">1,252</a> (1994-09-22;
+# web page corrected 2004-01-07) adopted by same states, minus AM.
 # Decree <a href="http://pcdsh01.on.br/HV1636.htm">1,636</a> (1995-09-14)
 # adopted by same states, plus MT and TO.
 # Decree <a href="http://pcdsh01.on.br/HV1674.htm">1,674</a> (1995-10-13)
@@ -536,8 +545,6 @@ Zone America/Campo_Grande -3:38:28 -	LMT	1914
 #
 # Mato Grosso (MT)
 Zone America/Cuiaba	-3:44:20 -	LMT	1914
-			-4:00	Brazil	AM%sT	1994 Sep 22
-			-4:00	-	AMT	1995 Sep 14
 			-4:00	Brazil	AM%sT	2003 Sep 24
 			-4:00	-	AMT
 #

From 7db787317115fc706deb42cdc623d0b5324375d0 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 31 May 2004 10:57:59 +0000
Subject: [PATCH 0060/1934] Add validate() to Chronology for PartialInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@210 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/Chronology.java    | 10 +++++
 .../joda/time/chrono/AbstractChronology.java  | 40 +++++++++++++++++--
 2 files changed, 47 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index 16054f151..dd3a9ca77 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -53,6 +53,8 @@
  */
 package org.joda.time;
 
+import org.joda.time.partial.PartialInstant;
+
 /**
  * Chronology provides access to the individual date time fields for a
  * chronological calendar system. Various chronologies are supported by
@@ -231,6 +233,14 @@ long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                            int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException;
 
+    /**
+     * Validates whether the fields stored in a partial instant are valid.
+     *
+     * @param instant  the partial instant to validate
+     * @throws IllegalArgumentException if the instant is invalid
+     */
+    void validate(PartialInstant instant);
+
     // Millis
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
index 9f685130f..2e11cd330 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
@@ -56,13 +56,12 @@
 import java.io.Serializable;
 
 import org.joda.time.Chronology;
-// Import for @link support
-import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.UnsupportedDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * AbstractChronology provides a skeleton implementation for chronology
@@ -273,6 +272,40 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
         return millisOfSecond().set(instant, millisOfSecond);
     }
 
+    /**
+     * Validates whether the fields stored in a partial instant are valid.
+     * <p>
+     * This implementation uses {@link DateTimeField#getMinimumValue()} and
+     * {@link DateTimeField#getMaximumValue()}.
+     *
+     * @param instant  the partial instant to validate
+     * @throws IllegalArgumentException if the instant is invalid
+     */
+    public void validate(PartialInstant instant) {
+        DateTimeField[] fields = instant.getFields();
+        int[] values = instant.getValues();
+        for (int i = 0; i < fields.length; i++) {
+            if (values[i] < fields[i].getMinimumValue()) {
+                throw new IllegalArgumentException("Value " + values[i] +
+                        " for " + fields[i].getName() + " is less than minimum");
+            }
+            if (values[i] > fields[i].getMaximumValue()) {
+                throw new IllegalArgumentException("Value " + values[i] +
+                        " for " + fields[i].getName() + " is greater than maximum");
+            }
+        }
+        for (int i = 0; i < fields.length; i++) {
+            if (values[i] < fields[i].getMinimumValue(instant)) {
+                throw new IllegalArgumentException("Value " + values[i] +
+                        " for " + fields[i].getName() + " is less than minimum");
+            }
+            if (values[i] > fields[i].getMaximumValue(instant)) {
+                throw new IllegalArgumentException("Value " + values[i] +
+                        " for " + fields[i].getName() + " is greater than maximum");
+            }
+        }
+    }
+
     // Millis
     //-----------------------------------------------------------------------
     /**
@@ -431,7 +464,8 @@ public DurationField days() {
     /**
      * Get the day of week field for this chronology.
      *
-     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.
+     * <p>DayOfWeek values are defined in
+     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.
      * They use the ISO definitions, where 1 is Monday and 7 is Sunday.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported

From bfbc8b64f9e0d290073a6b4f9b7916be6d4a1094 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 31 May 2004 10:58:40 +0000
Subject: [PATCH 0061/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@211 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/partial/AbstractPartialFieldProperty.java | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
index 3b545b663..85335b893 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -215,6 +215,7 @@ public int getMaximumValue() {
         return getField().getMaximumValue(getPartialInstant());
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Gets the maximum text length for the field.
      * 

From ec6e7dd1d7d9e0261542c56e148739583f785562 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 31 May 2004 10:59:34 +0000
Subject: [PATCH 0062/1934] Add new constructors and validate

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@212 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/partial/TimeOfDay.java |  64 +++++-
 .../joda/test/time/partial/TestTimeOfDay.java | 209 +++++++++++++++++-
 2 files changed, 270 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index d78cb5d20..50e18e134 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -223,6 +223,68 @@ public TimeOfDay(Object instant, Chronology chronology) {
         iChronology = chronology.withUTC();
     }
 
+    /**
+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds
+     * using <code>ISOChronology</code> in the default zone.
+     * <p>
+     * The constructor uses the no time zone initialising the fields as provided.
+     * Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour) {
+        this(hourOfDay, minuteOfHour, 0, 0, null);
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {
+        this(hourOfDay, minuteOfHour, 0, 0, chronology);
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified time field values and zero milliseconds
+     * using <code>ISOChronology</code> in the default zone.
+     * <p>
+     * The constructor uses the no time zone initialising the fields as provided.
+     * Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {
+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);
+    }
+
+    /**
+     * Constructs a TimeOfDay with specified time field values and zero milliseconds.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {
+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);
+    }
+
     /**
      * Constructs a TimeOfDay with specified time field values using
      * <code>ISOChronology</code> in the default zone.
@@ -259,9 +321,9 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
-        // TODO: Validate
         iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};
         iChronology = chronology.withUTC();
+        chronology.validate(this);
     }
 
     /**
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 7e1912ee5..2d29dda47 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -53,6 +53,7 @@
  */
 package org.joda.test.time.partial;
 
+import java.util.Date;
 import java.util.Locale;
 
 import junit.framework.TestCase;
@@ -161,14 +162,154 @@ public void testConstructor_longChronology() throws Throwable {
      * Test constructor (Object)
      */
     public void testConstructor_Object() throws Throwable {
-        // TODO
+        Date date = new Date(TEST_TIME);
+        TimeOfDay test = new TimeOfDay(date);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
     }
 
     /**
      * Test constructor (Object, Chronology)
      */
     public void testConstructor_ObjectChronology() throws Throwable {
-        // TODO
+        Date date = new Date(TEST_TIME);
+        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (int, int)
+     */
+    public void testConstructor_intint() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_intintChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int)
+     */
+    public void testConstructor_intintint() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_intintintChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     /**
@@ -181,6 +322,38 @@ public void testConstructor_intintintint() throws Throwable {
         assertEquals(20, test.getMinuteOfHour());
         assertEquals(30, test.getSecondOfMinute());
         assertEquals(40, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, 1000);
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     /**
@@ -193,6 +366,38 @@ public void testConstructor_intintintintChronology() throws Throwable {
         assertEquals(20, test.getMinuteOfHour());
         assertEquals(30, test.getSecondOfMinute());
         assertEquals(40, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     public void testGet() {

From 787255cddc1f6ad36d5e62dcb787e68cb4d2ca83 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 31 May 2004 11:58:36 +0000
Subject: [PATCH 0063/1934] Improve support for setting partial instant values

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@213 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 46 +++++++++++---
 .../time/chrono/GJDayOfWeekDateTimeField.java | 14 ++---
 .../chrono/GJMonthOfYearDateTimeField.java    | 12 +++-
 .../joda/time/field/BaseDateTimeField.java    | 60 +++++++++++++-----
 .../time/field/DelegatedDateTimeField.java    |  8 ++-
 .../time/field/UnsupportedDateTimeField.java  | 11 +++-
 .../java/org/joda/time/partial/TimeOfDay.java | 63 ++++++++++---------
 .../joda/test/time/partial/TestTimeOfDay.java | 13 ++++
 8 files changed, 161 insertions(+), 66 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 25978dbfb..4a21615cc 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -327,28 +327,56 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      * 
      * @param instant  the partial instant
      * @param fieldIndex  the index of this field in the instant
-     * @param value  the value to set, in the units of the field
-     * @return the updated milliseconds
+     * @param values  the values of the partial instant which should be updated
+     * @param newValue  the value to set, in the units of the field
+     * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public abstract int[] set(PartialInstant instant, int fieldIndex, int value);
+    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue);
 
     /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. If the specified locale is null, the default locale is used.
+     * Sets a value in the milliseconds supplied from a human-readable, text value.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param text  the text value to set
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
+     * @param locale the locale to use for selecting a text symbol, null for default
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
     public abstract long set(long instant, String text, Locale locale);
 
     /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value.
+     * Sets a value in the milliseconds supplied from a human-readable, text value.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
+     *
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param text  the text value to set
+     * @param locale the locale to use for selecting a text symbol, null for default
+     * @return the passed in values
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale);
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text value.
+     * <p>
+     * If setting this field would make other fields invalid, then those fields
+     * may be changed. For example if the current date is the 31st January, and
+     * the month is set to February, the day would be invalid. Instead, the day
+     * would be changed to the closest value - the 28th/29th February as appropriate.
      * 
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param text  the text value to set
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
index a91f8c8ec..b08306c86 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
@@ -116,15 +116,15 @@ protected String getAsShortText(int fieldValue, Locale locale) {
     }
 
     /**
-     * Set the value of the specified time instant from text.
+     * Convert the specified text and locale into a value.
      * 
-     * @param instant  the time instant in millis to update
-     * @param text  the text to set from
-     * @param locale  the locale to use
-     * @return the updated millis
+     * @param text  the text to convert
+     * @param locale  the locale to convert using
+     * @return the value extracted from the text
+     * @throws IllegalArgumentException if the text is invalid
      */
-    public long set(long instant, String text, Locale locale) {
-        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));
+    protected int convertText(String text, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text);
     }
 
     public DurationField getRangeDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
index 454a7210d..05cb3f279 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
@@ -319,8 +319,16 @@ public long set(long instant, int month) {
             iChronology.getMillisOfDay(instant);
     }
 
-    public long set(long instant, String text, Locale locale) {
-        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));
+    /**
+     * Convert the specified text and locale into a value.
+     * 
+     * @param text  the text to convert
+     * @param locale  the locale to convert using
+     * @return the value extracted from the text
+     * @throws IllegalArgumentException if the text is invalid
+     */
+    protected int convertText(String text, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text);
     }
 
     public DurationField getRangeDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 2454a69d1..4d951574e 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -359,37 +359,69 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * 
      * @param instant  the partial instant
      * @param fieldIndex  the index of this field in the instant
-     * @param value  the value to set, in the units of the field
-     * @return the updated milliseconds
+     * @param values  the values to update
+     * @param newValue  the value to set, in the units of the field
+     * @return the updated values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int value) {
-        FieldUtils.verifyValueBounds(this, value, getMinimumValue(instant), getMaximumValue(instant));
-        int[] array = instant.getValues();
-        array[fieldIndex] = value;
-        return array;
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
+        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant));
+        values[fieldIndex] = newValue;
+        return values;
     }
 
     /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. If the specified locale is null, the default locale is used.
+     * Sets a value in the milliseconds supplied from a human-readable, text value.
+     * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation returns set(instant,
-     * Integer.parseInt(instant)).
+     * This implementation uses {@link #convertText(String, Locale)} and
+     * {@link #set(long, int)}.
      * <p>
      * Note: subclasses that override this method should also override
      * getAsText.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param text  the text value to set
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
+     * @param locale the locale to use for selecting a text symbol, null for default
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
     public long set(long instant, String text, Locale locale) {
+        int value = convertText(text, locale);
+        return set(instant, value);
+    }
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text value.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * This implementation uses {@link #convertText(String, Locale)} and
+     * {@link #set(PartialInstant, int, int[], int)}.
+     *
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param text  the text value to set
+     * @param locale the locale to use for selecting a text symbol, null for default
+     * @return the passed in values
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+        int value = convertText(text, locale);
+        return set(instant, fieldIndex, values, value);
+    }
+
+    /**
+     * Convert the specified text and locale into a value.
+     * 
+     * @param text  the text to convert
+     * @param locale  the locale to convert using
+     * @return the value extracted from the text
+     * @throws IllegalArgumentException if the text is invalid
+     */
+    protected int convertText(String text, Locale locale) {
         try {
-            return set(instant, Integer.parseInt(text));
+            return Integer.parseInt(text);
         } catch (NumberFormatException ex) {
             throw new IllegalArgumentException("Invalid " + getName() + " text: " + text);
         }
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 6fdaf9869..ff95cfcf7 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -193,8 +193,12 @@ public long set(long instant, String text) {
         return iField.set(instant, text);
     }
 
-    public int[] set(PartialInstant instant, int fieldIndex, int value) {
-        return iField.set(instant, fieldIndex, value);
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
+        return iField.set(instant, fieldIndex, values, newValue);
+    }
+
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+        return iField.set(instant, fieldIndex, values, text, locale);
     }
 
     public DurationField getDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index 340c266cb..703c0db4f 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -243,7 +243,7 @@ public long set(long instant, int value) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int value) {
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
         throw unsupported();
     }
 
@@ -256,6 +256,15 @@ public long set(long instant, String text, Locale locale) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+        throw unsupported();
+    }
+
     /**
      * Even though this DateTimeField is unsupported, the duration field might
      * be supported.
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 50e18e134..bd74a141f 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -55,6 +55,7 @@
 
 import java.io.Serializable;
 import java.util.Arrays;
+import java.util.Locale;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -744,41 +745,41 @@ public int get() {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public TimeOfDay setCopy(int value) {
-            int[] newValues = getField().set(iInstant, iFieldIndex, value);
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, iFieldIndex, newValues, value);
             return new TimeOfDay(iInstant, newValues);
         }
 
-//        /**
-//         * Sets this field in a copy of the TimeOfDay to a parsed text value.
-//         * <p>
-//         * The TimeOfDay attached to this property is unchanged by this call.
-//         * 
-//         * @param text  the text value to set
-//         * @param locale  optional locale to use for selecting a text symbol
-//         * @return a copy of the TimeOfDay with the field value changed
-//         * @throws IllegalArgumentException if the text value isn't valid
-//         */
-//        public TimeOfDay setCopy(String text, Locale locale) {
-//            int[] newValues = getField().set(getInstant(), text, locale);
-//            return new TimeOfDay(getInstant(), newValues);
-//        }
-//
-//        /**
-//         * Sets this field in a copy of the TimeOfDay to a parsed text value.
-//         * <p>
-//         * The TimeOfDay attached to this property is unchanged by this call.
-//         * This operation is faster than converting a TimeOfDay to a MutableTimeOfDay
-//         * and back again when setting one field. When setting multiple fields,
-//         * it is generally quicker to make the conversion to MutableTimeOfDay.
-//         * 
-//         * @param text  the text value to set
-//         * @return a copy of the TimeOfDay with the field value changed
-//         * @throws IllegalArgumentException if the text value isn't valid
-//         */
-//        public final TimeOfDay setCopy(String text) {
-//            return setCopy(text, null);
-//        }
+        /**
+         * Sets this field in a copy of the TimeOfDay to a parsed text value.
+         * <p>
+         * The TimeOfDay attached to this property is unchanged by this call.
+         * 
+         * @param text  the text value to set
+         * @param locale  optional locale to use for selecting a text symbol
+         * @return a copy of the TimeOfDay with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public TimeOfDay setCopy(String text, Locale locale) {
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, iFieldIndex, newValues, text, locale);
+            return new TimeOfDay(iInstant, newValues);
+        }
+
+        /**
+         * Sets this field in a copy of the TimeOfDay to a parsed text value.
+         * <p>
+         * The TimeOfDay attached to this property is unchanged by this call.
+         * 
+         * @param text  the text value to set
+         * @return a copy of the TimeOfDay with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public TimeOfDay setCopy(String text) {
+            return setCopy(text, null);
+        }
 
+// TODO
 //        //-----------------------------------------------------------------------
 //        /**
 //         * Rounds to the lowest whole unit of this field on a copy of this TimeOfDay.
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 2d29dda47..4d1e1f622 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -557,6 +557,10 @@ public void testPropertyGet() {
         assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());
         assertEquals(2, test.hourOfDay().getMaximumTextLength(null));
         assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValues() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
         assertEquals(0, test.hourOfDay().getMinimumValue());
         assertEquals(0, test.hourOfDay().getMinimumValueOverall());
         assertEquals(23, test.hourOfDay().getMaximumValue());
@@ -572,4 +576,13 @@ public void testPropertySet() {
         assertEquals(40, set.getMillisOfSecond());
     }
 
+    public void testPropertySetText() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.hourOfDay().setCopy("12");
+        assertEquals(12, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
 }

From 412b356bf4e6f21d2160417ee7d2c94f032f791b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 3 Jun 2004 15:32:17 +0000
Subject: [PATCH 0064/1934] Fixed bug parsing time zone offset where zero
 offset text is an empty string.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@214 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java     | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 16bcc1a03..9095f8aa0 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1637,7 +1637,21 @@ public int estimateParsedLength() {
         }
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+            int limit = text.length() - position;
+
+            zeroOffset:
             if (iZeroOffsetText != null) {
+                if (iZeroOffsetText.length() == 0) {
+                    // Peek ahead, looking for sign character.
+                    if (limit > 0) {
+                        char c = text.charAt(position);
+                        if (c == '-' || c == '+') {
+                            break zeroOffset;
+                        }
+                    }
+                    bucket.setOffset(0);
+                    return position;
+                }
                 if (text.regionMatches(true, position, iZeroOffsetText, 0,
                                        iZeroOffsetText.length())) {
                     bucket.setOffset(0);
@@ -1647,7 +1661,6 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
             // Format to expect is sign character followed by at least one digit.
 
-            int limit = text.length() - position;
             if (limit <= 1) {
                 return ~position;
             }

From cbf530938f51338e2d4267fbb536c177683dba19 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 5 Jun 2004 05:25:02 +0000
Subject: [PATCH 0065/1934] Added method for supporting special parsing of two
 digit years.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@215 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java | 110 ++++++++++++++++++
 1 file changed, 110 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 9095f8aa0..a8b2cdbf2 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -730,6 +730,28 @@ public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDig
         return appendSignedDecimal(iChronoUTC.year(), minDigits, maxDigits);
     }
 
+    /**
+     * Instructs the printer to emit a numeric year field which always prints
+     * and parses two digits. A pivot year is used during parsing to determine
+     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.
+     *
+     * <pre>
+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is
+     * ---------------------------------------------------------------
+     * 1950      1900..1999      1900    1920    1940    1960    1980
+     * 1975      1925..2024      2000    2020    1940    1960    1980
+     * 2000      1950..2049      2000    2020    2040    1960    1980
+     * 2025      1975..2074      2000    2020    2040    2060    1980
+     * 2050      2000..2099      2000    2020    2040    2060    2080
+     * </pre>
+     *
+     * @param pivot pivot year to use when parsing
+     * @return this DateTimeFormatterBuilder
+     */
+    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {
+        return append0(new TwoDigitYear(iChrono, iChronoUTC.year(), pivot));
+    }
+
     /**
      * Instructs the printer to emit a numeric yearOfEra field.
      *
@@ -1195,6 +1217,94 @@ public void printTo(Writer out, long instant,
         }
     }
 
+    private static class TwoDigitYear extends AbstractFormatter
+        implements DateTimeFormatter
+    {
+        private final DateTimeField iField;
+        private final int iPivot;
+
+        TwoDigitYear(Chronology chrono, DateTimeField field, int pivot) {
+            super(chrono);
+            iField = field;
+            iPivot = pivot;
+        }
+
+        public int estimateParsedLength() {
+            return 2;
+        }
+
+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+            int limit = Math.min(2, text.length() - position);
+            if (limit < 2) {
+                return ~position;
+            }
+
+            int year;
+            char c = text.charAt(position);
+            if (c < '0' || c > '9') {
+                return ~position;
+            }
+            year = c - '0';
+            c = text.charAt(position + 1);
+            if (c < '0' || c > '9') {
+                return ~position;
+            }
+            year = ((year << 3) + (year << 1)) + c - '0';
+
+            int low = iPivot - 50;
+
+            int t;
+            if (low >= 0) {
+                t = low % 100;
+            } else {
+                t = 99 + ((low + 1) % 100);
+            }
+
+            year += low + ((year < t) ? 100 : 0) - t;
+
+            bucket.saveField(iField, year);
+            return position + 2;
+        }
+        
+        public int estimatePrintedLength() {
+            return 2;
+        }
+
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
+            int year = getTwoDigitYear(instantLocal);
+            if (year < 0) {
+                buf.append('\ufffd');
+                buf.append('\ufffd');
+            } else {
+                FormatUtils.appendPaddedInteger(buf, year, 2);
+            }
+        }
+
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            int year = getTwoDigitYear(instantLocal);
+            if (year < 0) {
+                out.write('\ufffd');
+                out.write('\ufffd');
+            } else {
+                FormatUtils.writePaddedInteger(out, year, 2);
+            }
+        }
+
+        private int getTwoDigitYear(long instantLocal) {
+            try {
+                int year = iField.get(instantLocal);
+                if (year < 0) {
+                    year = -year;
+                }
+                return year % 100;
+            } catch (RuntimeException e) {
+                return -1;
+            }
+        }
+    }
+
     private static class TextField extends AbstractFormatter
         implements DateTimeFormatter
     {

From a7a93c8b7027e0efee85e509f6cd260a37f53e09 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 6 Jun 2004 11:42:21 +0000
Subject: [PATCH 0066/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@216 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTime.java | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index ef4737e2c..b11aa4c82 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -78,8 +78,10 @@
  * <li>numeric value
  * <li>text value
  * <li>short text value
- * <li>maximum value
- * <li>minimum value
+ * <li>maximum/minimum values
+ * <li>add/subtract
+ * <li>set
+ * <li>rounding
  * </ul>
  *
  * <p>

From bf5e60bdc89c03e22a1cae8a3537368810068765 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 6 Jun 2004 11:44:58 +0000
Subject: [PATCH 0067/1934] Add AbstractPartialInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@217 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/partial/AbstractPartialInstant.java  | 478 ++++++++++++++++++
 .../java/org/joda/time/partial/TimeOfDay.java | 290 +----------
 2 files changed, 506 insertions(+), 262 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
new file mode 100644
index 000000000..c3ca34557
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
@@ -0,0 +1,478 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.io.Serializable;
+import java.util.Arrays;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadWritableInstant;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.InstantConverter;
+
+/**
+ * AbstractPartialInstant provides a standard base implementation of most methods
+ * in the PartialInstant interface.
+ * <p>
+ * Calculations on are performed using a {@link Chronology}.
+ * This chronology is set to be in the UTC time zone for all calculations.
+ * <p>
+ * AbstractPartialInstant allows subclasses may be mutable and not thread-safe.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public abstract class AbstractPartialInstant implements PartialInstant, Serializable {
+
+    /** Serialization version */
+    private static final long serialVersionUID = 2353678632973660L;
+
+    /** The chronology in use */
+    protected Chronology iChronology;
+    /** The values of each field in this partial instant */
+    protected int[] iValues;
+    /** The values of each field in this partial instant */
+    protected transient DateTimeField[] iFields;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a AbstractPartialInstant with the current time, using ISOChronology in
+     * the default zone to extract the fields.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     */
+    public AbstractPartialInstant() {
+        this(DateTimeUtils.currentTimeMillis(), null);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant with the current time, using the specified chronology
+     * and zone to extract the fields.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public AbstractPartialInstant(Chronology chronology) {
+        this(DateTimeUtils.currentTimeMillis(), chronology);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant extracting the partial fields from the specified
+     * milliseconds using the ISOChronology in the default zone.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public AbstractPartialInstant(long instant) {
+        this(instant, null);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant extracting the partial fields from the specified
+     * milliseconds using the chronology provided.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public AbstractPartialInstant(long instant, Chronology chronology) {
+        super();
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology.withUTC();
+        iFields = initFields(iChronology);
+        iValues = initValues(instant, chronology);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public AbstractPartialInstant(Object instant) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        Chronology chronology = converter.getChronology(instant);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology.withUTC();
+        iFields = initFields(iChronology);
+        iValues = initValues(converter.getInstantMillis(instant), chronology);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the date is null
+     */
+    public AbstractPartialInstant(Object instant, Chronology chronology) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology.withUTC();
+        iFields = initFields(iChronology);
+        iValues = initValues(converter.getInstantMillis(instant, chronology), chronology);
+    }
+
+    /**
+     * Constructs a AbstractPartialInstant with specified time field values and chronology.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param values  the new set of values
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public AbstractPartialInstant(int[] values, Chronology chronology) {
+        super();
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology.withUTC();
+        iFields = initFields(iChronology);
+        iValues = values;
+        chronology.validate(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Initialize the array of fields.
+     * The field and value arrays must match.
+     * 
+     * @param chrono  the chronology to use
+     */
+    protected abstract DateTimeField[] initFields(Chronology chrono);
+
+    /**
+     * Initialize the array of values.
+     * The field and value arrays must match.
+     * 
+     * @param instant  the instant to use
+     * @param chrono  the chronology to use
+     */
+    protected abstract int[] initValues(long instant, Chronology chrono);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the number of fields in this instant.
+     * 
+     * @return the field count
+     */
+    public int getFieldSize() {
+        return iFields.length;
+    }
+
+    /**
+     * Gets the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the field
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public DateTimeField getField(int index) {
+        if (index < 0 || index >= iFields.length) {
+            throw new IllegalArgumentException(Integer.toString(index));
+        }
+        return iFields[index];
+    }
+
+    /**
+     * Gets the value of the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the value
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public int getValue(int index) {
+        if (index < 0 || index >= iValues.length) {
+            throw new IllegalArgumentException(Integer.toString(index));
+        }
+        return iValues[index];
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets an array of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     *
+     * @return the fields supported (cloned), largest to smallest
+     */
+    public DateTimeField[] getFields() {
+        return (DateTimeField[]) iFields.clone();
+    }
+
+    /**
+     * Gets an array of the value of each of the fields that this partial instant supports.
+     * <p>
+     * The fields are returned largest to smallest, for example Hour, Minute, Second.
+     * Each value corresponds to the same array index as <code>getFields()</code>
+     *
+     * @return the current values of each field (cloned), largest to smallest
+     */
+    public int[] getValues() {
+        return (int[]) iValues.clone();
+    }
+
+    /**
+     * Gets the chronology of the partial which is never null.
+     * <p>
+     * The {@link Chronology} is the calculation engine behind the partial and
+     * provides conversion and validation of the fields in a particular calendar system.
+     * 
+     * @return the chronology
+     */
+    public Chronology getChronology() {
+        return iChronology;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value of one of the fields of a datetime.
+     * <p>
+     * The field specified must be one of those that is supported by the partial instant.
+     *
+     * @param field  a DateTimeField instance that is supported by this partial
+     * @return the value of that field
+     * @throws IllegalArgumentException if the field is null or not supported
+     */
+    public int get(DateTimeField field) {
+        for (int i = 0; i < iFields.length; i++) {
+            if (iFields[i] == field) {
+                return iValues[i];
+            }
+        }
+        throw new IllegalArgumentException("Field '" + field + "' is not supported");
+    }
+
+    /**
+     * Checks whether the field specified is supported by this partial instant.
+     *
+     * @param field  the field to check, may be null which returns false
+     * @return true if the field is supported
+     */
+    public boolean isSupported(DateTimeField field) {
+        for (int i = 0; i < iFields.length; i++) {
+            if (iFields[i] == field) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param baseMillis  source of missing fields
+     * @param zone  the zone to use, null means default
+     * @return the combined instant in milliseconds
+     */
+    public long resolve(long baseMillis, DateTimeZone zone) {
+        Chronology chrono = iChronology.withZone(zone);
+        return resolve(baseMillis, chrono);
+    }
+
+    /**
+     * Resolves this partial into another complete instant setting the relevant fields
+     * on the writable instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the input writable instant
+     * will be updated with the time from this instant.
+     *
+     * @param base  the instant to set into, must not be null
+     * @throws IllegalArgumentException if the base instant is null
+     */
+    public void resolveInto(ReadWritableInstant base) {
+        if (base == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        Chronology chrono = base.getChronology();
+        long resolved = resolve(base.getMillis(), chrono);
+        base.setMillis(resolved);
+    }
+
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param base  the instant that provides the missing fields, null means now
+     * @return the combined datetime
+     */
+    public DateTime resolveDateTime(ReadableInstant base) {
+        long resolved;
+        Chronology chrono;
+        if (base == null) {
+            chrono = ISOChronology.getInstance();
+            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);
+        } else {
+            chrono = base.getChronology();
+            resolved = resolve(base.getMillis(), chrono);
+        }
+        return new DateTime(resolved, chrono);
+    }
+
+    /**
+     * Resolve this partial instant into the base millis using the specified chronology.
+     * 
+     * @param baseMillis  the base millis
+     * @param chrono  the chronology
+     * @return the new resolved millis
+     */
+    protected long resolve(long baseMillis, Chronology chrono) {
+        long millis = baseMillis;
+        for (int i = 0; i < iFields.length; i++) {
+            millis = iFields[i].set(millis, iValues[i]);
+        }
+        return millis;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this PartialInstant with another returning true if the chronology,
+     * fields and values are equal.
+     *
+     * @param AbstractPartialInstant  an object to check against
+     * @return true if fields and values are equal
+     */
+    public boolean equals(Object instant) {
+        if (instant instanceof AbstractPartialInstant) {
+            AbstractPartialInstant other = (AbstractPartialInstant) instant;
+            return Arrays.equals(iValues, other.iValues) &&
+                   Arrays.equals(iFields, other.iFields) &&
+                   iChronology == other.iChronology;
+        } else if (instant instanceof PartialInstant) {
+            PartialInstant other = (PartialInstant) instant;
+            return Arrays.equals(iValues, other.getValues()) &&
+                   Arrays.equals(iFields, other.getFields()) &&
+                   iChronology == other.getChronology();
+        }
+        return false;
+    }
+
+    /**
+     * Gets a hash code for the PartialInstant that is compatible with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    public int hashCode() {
+        int total = 157;
+        for (int i = 0; i < iFields.length; i++) {
+            total = 23 * total + iValues[i];
+            total = 23 * total + iFields[i].hashCode();
+        }
+        total += iChronology.hashCode();
+        return total;
+    }
+
+    /**
+     * Output the time in an ISO8601 format.
+     * 
+     * @return ISO8601 formatted string
+     */
+    public String toString() {
+        // TODO
+        return "";
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index bd74a141f..c54643764 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -54,18 +54,10 @@
 package org.joda.time.partial;
 
 import java.io.Serializable;
-import java.util.Arrays;
 import java.util.Locale;
 
 import org.joda.time.Chronology;
-import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeUtils;
-import org.joda.time.DateTimeZone;
-import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.ConverterManager;
-import org.joda.time.convert.InstantConverter;
 
 /**
  * TimeOfDay is an immutable partial instant supporting the hour, minute, second
@@ -85,8 +77,10 @@
  * <li>numeric value
  * <li>text value
  * <li>short text value
- * <li>maximum value
- * <li>minimum value
+ * <li>maximum/minimum values
+ * <li>add/subtract
+ * <li>set
+ * <li>rounding
  * </ul>
  * <p>
  * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.
@@ -96,7 +90,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class TimeOfDay implements PartialInstant, Serializable {
+public final class TimeOfDay extends AbstractPartialInstant implements PartialInstant, Serializable {
 
     /** Serialization version */
     private static final long serialVersionUID = 3633353405803318660L;
@@ -110,11 +104,6 @@
     /** The index of the millisOfSecond field in the field array */
     public static final int MILLIS_OF_SECOND = 3;
 
-    /** The chronology in use */
-    private final Chronology iChronology;
-    /** The values of each field in this partial instant */
-    private final int[] iValues;
-
     // Constructors
     //-----------------------------------------------------------------------
     /**
@@ -126,7 +115,7 @@
      * are performed without reference to a timezone (by switching to UTC).
      */
     public TimeOfDay() {
-        this(DateTimeUtils.currentTimeMillis(), null);
+        super();
     }
 
     /**
@@ -140,7 +129,7 @@ public TimeOfDay() {
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
     public TimeOfDay(Chronology chronology) {
-        this(DateTimeUtils.currentTimeMillis(), chronology);
+        super(chronology);
     }
 
     /**
@@ -154,7 +143,7 @@ public TimeOfDay(Chronology chronology) {
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
     public TimeOfDay(long instant) {
-        this(instant, null);
+        super(instant);
     }
 
     /**
@@ -169,12 +158,7 @@ public TimeOfDay(long instant) {
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
     public TimeOfDay(long instant, Chronology chronology) {
-        super();
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        iValues = initValues(instant, chronology);
-        iChronology = chronology.withUTC();
+        super(instant, chronology);
     }
 
     /**
@@ -188,14 +172,7 @@ public TimeOfDay(long instant, Chronology chronology) {
      * @throws IllegalArgumentException if the date is null
      */
     public TimeOfDay(Object instant) {
-        super();
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        Chronology chronology = converter.getChronology(instant);
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        iValues = initValues(converter.getInstantMillis(instant), chronology);
-        iChronology = chronology.withUTC();
+        super(instant);
     }
 
     /**
@@ -215,13 +192,7 @@ public TimeOfDay(Object instant) {
      * @throws IllegalArgumentException if the date is null
      */
     public TimeOfDay(Object instant, Chronology chronology) {
-        super();
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        iValues = initValues(converter.getInstantMillis(instant, chronology), chronology);
-        iChronology = chronology.withUTC();
+        super(instant, chronology);
     }
 
     /**
@@ -318,13 +289,7 @@ public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millis
      */
     public TimeOfDay(int hourOfDay, int minuteOfHour,
             int secondOfMinute, int millisOfSecond, Chronology chronology) {
-        super();
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};
-        iChronology = chronology.withUTC();
-        chronology.validate(this);
+        super(new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond}, chronology);
     }
 
     /**
@@ -339,13 +304,28 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
         iValues = values;
     }
 
+    //-----------------------------------------------------------------------
+    /**
+     * Initialize the array of fields.
+     * 
+     * @param chrono  the chronology to use
+     */
+    protected DateTimeField[] initFields(Chronology chrono) {
+        return new DateTimeField[] {
+            chrono.hourOfDay(),
+            chrono.minuteOfHour(),
+            chrono.secondOfMinute(),
+            chrono.millisOfSecond(),
+        };
+    }
+
     /**
      * Initialize the array of values.
      * 
      * @param instant  the instant to use
      * @param chrono  the chronology to use
      */
-    private int[] initValues(long instant, Chronology chrono) {
+    protected int[] initValues(long instant, Chronology chrono) {
         return new int[] {
             chrono.hourOfDay().get(instant),
             chrono.minuteOfHour().get(instant),
@@ -354,178 +334,6 @@ public TimeOfDay(int hourOfDay, int minuteOfHour,
         };
     }
 
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the number of fields in TimeOfDay.
-     * 
-     * @return the field count
-     */
-    public int getFieldSize() {
-        return 4;
-    }
-
-    /**
-     * Gets the field at the specifed index.
-     * 
-     * @param index  the index
-     * @return the field
-     * @throws IndexOutOfBoundsException if the index is invalid
-     */
-    public DateTimeField getField(int index) {
-        switch (index) {
-            case HOUR_OF_DAY:
-                return iChronology.hourOfDay();
-            case MINUTE_OF_HOUR:
-                return iChronology.minuteOfHour();
-            case SECOND_OF_MINUTE:
-                return iChronology.secondOfMinute();
-            case MILLIS_OF_SECOND:
-                return iChronology.millisOfSecond();
-            default:
-                throw new IllegalArgumentException(Integer.toString(index));
-        }
-    }
-
-    /**
-     * Gets the value of the field at the specifed index.
-     * 
-     * @param index  the index
-     * @return the value
-     * @throws IndexOutOfBoundsException if the index is invalid
-     */
-    public int getValue(int index) {
-        if (index < 0 || index > 4) {
-            throw new IllegalArgumentException(Integer.toString(index));
-        }
-        return iValues[index];
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets an array of the fields that this partial instant supports.
-     * <p>
-     * The fields are returned largest to smallest, for example Hour, Minute, Second.
-     *
-     * @return the fields supported (cloned), largest to smallest
-     */
-    public DateTimeField[] getFields() {
-        return new DateTimeField[] {
-            iChronology.hourOfDay(),
-            iChronology.minuteOfHour(),
-            iChronology.secondOfMinute(),
-            iChronology.millisOfSecond(),
-        };
-    }
-
-    /**
-     * Gets an array of the value of each of the fields that this partial instant supports.
-     * <p>
-     * The fields are returned largest to smallest, for example Hour, Minute, Second.
-     * Each value corresponds to the same array index as <code>getFields()</code>
-     *
-     * @return the current values of each field (cloned), largest to smallest
-     */
-    public int[] getValues() {
-        return (int[]) iValues.clone();
-    }
-
-    /**
-     * Gets the chronology of the partial which is never null.
-     * <p>
-     * The {@link Chronology} is the calculation engine behind the partial and
-     * provides conversion and validation of the fields in a particular calendar system.
-     * 
-     * @return the chronology
-     */
-    public Chronology getChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Get the value of one of the fields of a datetime.
-     * <p>
-     * The field specified must be one of those that is supported by the partial instant.
-     *
-     * @param field  a DateTimeField instance that is supported by this partial
-     * @return the value of that field
-     * @throws IllegalArgumentException if the field is null or not supported
-     */
-    public int get(DateTimeField field) {
-        if (iChronology.hourOfDay() == field) {
-            return getValue(HOUR_OF_DAY);
-        }
-        if (iChronology.minuteOfHour() == field) {
-            return getValue(MINUTE_OF_HOUR);
-        }
-        if (iChronology.secondOfMinute() == field) {
-            return getValue(SECOND_OF_MINUTE);
-        }
-        if (iChronology.millisOfSecond() == field) {
-            return getValue(MILLIS_OF_SECOND);
-        }
-        throw new IllegalArgumentException("Field '" + field + "' is not supported by TimeOfDay");
-    }
-
-    /**
-     * Checks whether the field specified is supported by this partial instant.
-     *
-     * @param field  the field to check, may be null which returns false
-     * @return true if the field is supported
-     */
-    public boolean isSupported(DateTimeField field) {
-        return 
-            iChronology.hourOfDay() == field ||
-            iChronology.minuteOfHour() == field ||
-            iChronology.secondOfMinute() == field ||
-            iChronology.millisOfSecond() == field;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
-     * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
-     *
-     * @param baseMillis  source of missing fields
-     * @param zone  the zone to use, null means default
-     * @return the combined instant in milliseconds
-     */
-    public long resolve(long baseMillis, DateTimeZone zone) {
-        Chronology chrono = iChronology.withZone(zone);
-        long millis = baseMillis;
-        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));
-        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));
-        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));
-        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));
-        return millis;
-    }
-
-    /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant. The combination is performed using the chronology of the
-     * specified instant.
-     * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
-     *
-     * @param base  the instant that provides the missing fields, null means now
-     * @return the combined datetime
-     */
-    public DateTime resolveDateTime(ReadableInstant base) {
-        if (base == null) {
-            base = new DateTime();
-        }
-        Chronology chrono = base.getChronology();
-        long millis = base.getMillis();
-        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));
-        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));
-        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));
-        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));
-        return new DateTime(millis, chrono);
-    }
-
     //-----------------------------------------------------------------------
     /**
      * Get the hour of day (0-23) field value.
@@ -600,48 +408,6 @@ public Property millisOfSecond() {
         return new Property(this, MILLIS_OF_SECOND);
     }
 
-    //-----------------------------------------------------------------------
-    /**
-     * Compares this TimeOfDay with another returning true if the fields and
-     * values are equal.
-     *
-     * @param timeOfDay  an object to check against
-     * @return true if fields and values are equal
-     */
-    public boolean equals(Object timeOfDay) {
-        if (timeOfDay instanceof TimeOfDay == false) {
-            return false;
-        }
-        TimeOfDay other = (TimeOfDay) timeOfDay;
-        return Arrays.equals(iValues, other.iValues) &&
-               iChronology == other.iChronology;
-    }
-
-    /**
-     * Gets a hash code for the TimeOfDay that is compatible with the 
-     * equals method.
-     *
-     * @return a suitable hash code
-     */
-    public int hashCode() {
-        int total = 157;
-        for (int i = 0; i < iValues.length; i++) {
-            total = 23 * total + getValue(i);
-        }
-        total += iChronology.hashCode();
-        return total;
-    }
-
-    /**
-     * Output the time in ISO8601 time only format (hh:mm:ss.SSS).
-     * 
-     * @return ISO8601 time formatted string
-     */
-    public String toString() {
-        // TODO
-        return "";
-    }
-    
     //-----------------------------------------------------------------------
     /**
      * The property class for TimeOfDay.

From ed60692b4491e2c7cca98b673687d1d4a3383156 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 6 Jun 2004 11:49:07 +0000
Subject: [PATCH 0068/1934] Ensure deserialization works

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@218 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/partial/AbstractPartialInstant.java    | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
index c3ca34557..84d38be9d 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
@@ -53,6 +53,8 @@
  */
 package org.joda.time.partial;
 
+import java.io.IOException;
+import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.util.Arrays;
 
@@ -225,6 +227,16 @@ public AbstractPartialInstant(int[] values, Chronology chronology) {
     }
 
     //-----------------------------------------------------------------------
+    /**
+     * Recreates the state of this object after deserialization.
+     * 
+     * @param in  the input stream
+     */
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        iFields = initFields(iChronology);
+    }
+
     /**
      * Initialize the array of fields.
      * The field and value arrays must match.

From 0d7b62128ccbbab4dcc955c8fe26f59b9cb24f50 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 8 Jun 2004 22:49:25 +0000
Subject: [PATCH 0069/1934] Add addInField to PartialInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@219 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 26 ++++++++
 .../time/chrono/GJYearOfEraDateTimeField.java | 27 ++-------
 .../chrono/ISOYearOfEraDateTimeField.java     |  5 ++
 .../joda/time/field/BaseDateTimeField.java    | 34 +++++++++++
 .../time/field/DelegatedDateTimeField.java    |  4 ++
 .../joda/time/field/NonZeroDateTimeField.java |  4 ++
 .../time/field/UnsupportedDateTimeField.java  |  9 +++
 .../java/org/joda/time/partial/TimeOfDay.java | 59 +++++++++++--------
 .../joda/test/time/partial/TestTimeOfDay.java | 14 +++++
 9 files changed, 137 insertions(+), 45 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 4a21615cc..736ca2aa9 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -254,6 +254,32 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      */
     public abstract long addWrapped(long instant, int value) ;
 
+    /**
+     * Adds a value (which may be negative) to the partial instant,
+     * wrapping within this field.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field then it wraps. Larger fields are always
+     * unaffected. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 addInField six months is 2000-02-20<br>
+     * 2000-08-20 addInField twenty months is 2000-04-20<br>
+     * 2000-08-20 addInField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addInField one month  is 2001-02-28<br>
+     * 2001-01-31 addInField two months is 2001-03-31<br>
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param valueToAdd  the value to add, in the units of the field
+     * @return the passed in values
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public abstract int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);
+
     /**
      * Computes the difference between two instants, as measured in the units
      * of this field. Any fractional units are dropped from the result. Calling
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index 799c60b50..c166ea453 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -56,6 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * Provides time calculations for the year of era component of time.
@@ -76,12 +77,6 @@
         iChronology = chronology;
     }
 
-    /**
-     * Get the year of era component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the year of era extracted from the input.
-     */
     public int get(long instant) {
         int year = getWrappedField().get(instant);
         if (year <= 0) {
@@ -90,14 +85,6 @@ public int get(long instant) {
         return year;
     }
 
-    /**
-     * Add the specified year to the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
     public long add(long instant, int years) {
         return getWrappedField().add(instant, years);
     }
@@ -106,18 +93,14 @@ public long add(long instant, long years) {
         return getWrappedField().add(instant, years);
     }
 
-    /**
-     * Add to the year component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
     public long addWrapped(long instant, int years) {
         return getWrappedField().addWrapped(instant, years);
     }
 
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {
+        return getWrappedField().addInField(instant, fieldIndex, values, years);
+    }
+
     public int getDifference(long minuendInstant, long subtrahendInstant) {
         return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
index 6b5ca45a1..6c11eaa3f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
@@ -56,6 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.partial.PartialInstant;
 
 /**
  * This field is not publicy exposed by ISOChronology, but rather it is used to
@@ -98,6 +99,10 @@ public long addWrapped(long instant, int years) {
         return getWrappedField().addWrapped(instant, years);
     }
 
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {
+        return getWrappedField().addInField(instant, fieldIndex, values, years);
+    }
+
     public int getDifference(long minuendInstant, long subtrahendInstant) {
         return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 4d951574e..f9f2797c3 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -281,6 +281,40 @@ public long addWrapped(long instant, int value) {
         return set(instant, wrapped);
     }
 
+    /**
+     * Adds a value (which may be negative) to the partial instant,
+     * wrapping within this field.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field then it wraps. Larger fields are always
+     * unaffected. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 addInField six months is 2000-02-20<br>
+     * 2000-08-20 addInField twenty months is 2000-04-20<br>
+     * 2000-08-20 addInField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addInField one month  is 2001-02-28<br>
+     * 2001-01-31 addInField two months is 2001-03-31<br>
+     * <p>
+     * The default implementation internally calls set. Subclasses are
+     * encouraged to provide a more efficient implementation.
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param valueToAdd  the value to add, in the units of the field
+     * @return the passed in values
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        int current = values[fieldIndex];
+        int wrapped = FieldUtils.getWrappedValue
+            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
+        return set(instant, fieldIndex, values, wrapped);
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Computes the difference between two instants, as measured in the units
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index ff95cfcf7..a95a935e7 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -173,6 +173,10 @@ public long addWrapped(long instant, int value) {
         return iField.addWrapped(instant, value);
     }
 
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        return iField.addInField(instant, fieldIndex, values, valueToAdd);
+    }
+
     public int getDifference(long minuendInstant, long subtrahendInstant) {
         return iField.getDifference(minuendInstant, subtrahendInstant);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index 6f3d263b2..e3f7b250e 100644
--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -102,6 +102,10 @@ public long addWrapped(long instant, int value) {
         return getWrappedField().addWrapped(instant, value);
     }
 
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        return getWrappedField().addInField(instant, fieldIndex, values, valueToAdd);
+    }
+
     public int getDifference(long minuendInstant, long subtrahendInstant) {
         return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index 703c0db4f..a7477cf55 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -211,6 +211,15 @@ public long addWrapped(long instant, int value) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        throw unsupported();
+    }
+
     /**
      * Delegates to the duration field.
      *
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index c54643764..2756601d8 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -74,13 +74,12 @@
  * The second technique also provides access to other useful methods on the
  * field:
  * <ul>
- * <li>numeric value
- * <li>text value
- * <li>short text value
- * <li>maximum/minimum values
- * <li>add/subtract
- * <li>set
- * <li>rounding
+ * <li>numeric value - <code>hourOfDay().get()</code>
+ * <li>text value - <code>hourOfDay().getAsText()</code>
+ * <li>short text value - <code>hourOfDay().getAsShortText()</code>
+ * <li>maximum/minimum values - <code>hourOfDay().getMaximumValue()</code>
+ * <li>add/subtract - <code>hourOfDay().addToCopy()</code>
+ * <li>set - <code>hourOfDay().setCopy()</code>
  * </ul>
  * <p>
  * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.
@@ -474,6 +473,7 @@ public int get() {
 //         * Adds to this field in a copy of this TimeOfDay.
 //         * <p>
 //         * The TimeOnly attached to this property is unchanged by this call.
+//        * Instead, a new instance is returned.
 //         * 
 //         * @param value  the value to add to the field in the copy
 //         * @return a copy of the TimeOnly with the field value changed
@@ -484,27 +484,38 @@ public int get() {
 //            return new TimeOfDay(getInstant(), newValues);
 //        }
 //
-//        /**
-//         * Adds to this field, possibly wrapped, in a copy of this TimeOfDay.
-//         * A wrapped operation only changes this field.
-//         * Thus 12:59:00 addWrapped one minute goes to 12:00:00.
-//         * <p>
-//         * The TimeOfDay attached to this property is unchanged by this call.
-//         * 
-//         * @param value  the value to add to the field in the copy
-//         * @return a copy of the TimeOfDay with the field value changed
-//         * @throws IllegalArgumentException if the value isn't valid
-//         */
-//        public TimeOfDay addWrappedToCopy(int value) {
-//            int[] newValues = getField().addWrapped(getInstant(), value);
-//            return new TimeOfDay(getInstant(), newValues);
-//        }
-//
+        /**
+         * Adds to the value of this field in a copy of this TimeOfDay wrapping
+         * within this field if the maximum value is reached.
+         * <p>
+         * The value will be added to this field. If the value is too large to be
+         * added solely to this field then it wraps. Larger fields are always
+         * unaffected. Smaller fields should be unaffected, except where the
+         * result would be an invalid value for a smaller field. In this case the
+         * smaller field is adjusted to be in range.
+         * <p>
+         * For example,
+         * <code>12:59:37</code> addInField one minute returns <code>12:00:37</code>.
+         * <p>
+         * The TimeOfDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the TimeOfDay with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public TimeOfDay addInFieldCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);
+            return new TimeOfDay(iInstant, newValues);
+        }
+
         //-----------------------------------------------------------------------
         /**
          * Sets this field in a copy of the TimeOfDay.
          * <p>
          * The TimeOfDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
          * 
          * @param value  the value to set the field in the copy to
          * @return a copy of the TimeOfDay with the field value changed
@@ -520,6 +531,7 @@ public TimeOfDay setCopy(int value) {
          * Sets this field in a copy of the TimeOfDay to a parsed text value.
          * <p>
          * The TimeOfDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
          * 
          * @param text  the text value to set
          * @param locale  optional locale to use for selecting a text symbol
@@ -536,6 +548,7 @@ public TimeOfDay setCopy(String text, Locale locale) {
          * Sets this field in a copy of the TimeOfDay to a parsed text value.
          * <p>
          * The TimeOfDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
          * 
          * @param text  the text value to set
          * @return a copy of the TimeOfDay with the field value changed
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
index 4d1e1f622..69c363d40 100644
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
@@ -567,6 +567,20 @@ public void testPropertyGetMaxMinValues() {
         assertEquals(23, test.hourOfDay().getMaximumValueOverall());
     }
 
+    public void testPropertyAddInField() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);
+        assertEquals(19, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+        updated = updated.hourOfDay().addInFieldCopy(9);
+        assertEquals(4, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+    }
+
     public void testPropertySet() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
         TimeOfDay set = test.hourOfDay().setCopy(12);

From 9be879e558515f40ab79ce55944919f370f5c865 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 10:54:25 +0000
Subject: [PATCH 0070/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@220 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/test/org/joda/test/time/ClassLoadTest.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
index 0386534a1..5991fd087 100644
--- a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
+++ b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
@@ -60,8 +60,8 @@
 import org.joda.time.ReadableDateTime;
 
 /**
- * This class is a Junit unit test base class for
- * Instant implementations.
+ * This class displays what the ClassLoader is up to.
+ * Run using JVM -verbose:class.
  *
  * @author Stephen Colebourne
  */

From 3f1abe6f2e681b49f72b4bf8bcf896ffbd149334 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:00:56 +0000
Subject: [PATCH 0071/1934] Fix ObjectChronology constructor to use converter
 properly

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@221 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/partial/AbstractPartialInstant.java   | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
index 84d38be9d..76a2b809e 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
@@ -197,6 +197,7 @@ public AbstractPartialInstant(Object instant) {
     public AbstractPartialInstant(Object instant, Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        chronology = converter.getChronology(instant, chronology);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }

From c52cb86eb06d1b40382f9048aa49a44d86da2fad Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:01:22 +0000
Subject: [PATCH 0072/1934] Add NullConverter that returns current time

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@222 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/ConverterManager.java   |   1 +
 .../org/joda/time/convert/NullConverter.java  | 100 ++++++++++++++++++
 .../java/org/joda/time/partial/TimeOfDay.java |   4 +-
 3 files changed, 103 insertions(+), 2 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/convert/NullConverter.java

diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index fcf14fb8e..e3095c089 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -125,6 +125,7 @@ protected ConverterManager() {
             CalendarConverter.INSTANCE,
             DateConverter.INSTANCE,
             LongConverter.INSTANCE,
+            NullConverter.INSTANCE,
         });
 
         iDurationConverters = new ConverterSet(new Converter[] {
diff --git a/JodaTime/src/java/org/joda/time/convert/NullConverter.java b/JodaTime/src/java/org/joda/time/convert/NullConverter.java
new file mode 100644
index 000000000..4c7d19551
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java
@@ -0,0 +1,100 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.DateTimeUtils;
+
+/**
+ * NullConverter converts null to milliseconds (now) in the ISOChronology.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+class NullConverter extends AbstractConverter implements InstantConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final NullConverter INSTANCE = new NullConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected NullConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millisecond instant, which is now.
+     * 
+     * @param object  the object to convert
+     * @return the millisecond instant of now
+     */
+    public long getInstantMillis(Object object) {
+        return DateTimeUtils.currentTimeMillis();
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns null.
+     * 
+     * @return null
+     */
+    public Class getSupportedType() {
+        return null;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 2756601d8..e1bf571b1 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -167,7 +167,7 @@ public TimeOfDay(long instant, Chronology chronology) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
-     * @param instant  the datetime object, must not be null
+     * @param instant  the datetime object, null means now
      * @throws IllegalArgumentException if the date is null
      */
     public TimeOfDay(Object instant) {
@@ -186,7 +186,7 @@ public TimeOfDay(Object instant) {
      * Once the constructor is complete, all further calculations are performed
      * without reference to a timezone (by switching to UTC).
      *
-     * @param instant  the datetime object, must not be null
+     * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology
      * @throws IllegalArgumentException if the date is null
      */

From d6bd052764758922341876a9d8716139b16eb9b0 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:02:19 +0000
Subject: [PATCH 0073/1934] Allow clover/jcoverage reports to work

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@223 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 40e602474..c1edc72e1 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -90,12 +90,17 @@
     <unitTestSourceDirectory>src/test</unitTestSourceDirectory>
     <unitTest>
       <includes>
-        <include>org/joda/time/**/Test*.java</include>
+        <include>org/joda/time/**/TestAll.java</include>
       </includes>
-      <excludes>
-        <exclude>org/joda/time/**/TestSuite*.java</exclude>
-      </excludes>
     </unitTest>
+    <resources>
+      <resource>
+        <directory>${basedir}/target/classes</directory>
+        <includes>
+          <include>org/joda/time/tz/data/**</include>
+        </includes>
+      </resource>
+    </resources>
   </build>
 
   <reports>
@@ -103,7 +108,7 @@
      <report>maven-changes-plugin</report>
      <report>maven-checkstyle-plugin</report>
      <!-- <report>maven-clover-plugin</report> -->
-     <!-- report>maven-jcoverage-plugin</report -->
+     <!-- <report>maven-jcoverage-plugin</report> -->
      <report>maven-developer-activity-plugin</report>
      <report>maven-file-activity-plugin</report>
      <report>maven-javadoc-plugin</report>

From 234861794362a0194bf8f2b850b7f8d3df21afe2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:03:14 +0000
Subject: [PATCH 0074/1934] Reorganize test classes, factoring out older ones

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@224 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../test/time/AbstractTestDateTimeField.java  |   14 +-
 .../src/test/org/joda/test/time/BulkTest.java |    2 +-
 .../test/org/joda/test/time/TestInstant.java  |    1 +
 .../joda/test/time/partial/TestTimeOfDay.java |  602 ---------
 .../joda/{test => }/time/ClassLoadTest.java   |    2 +-
 JodaTime/src/test/org/joda/time/TestAll.java  |   87 ++
 .../test/org/joda/time/TestAllPackages.java   |   88 ++
 .../time/TestDateTimeComparator.java          |    3 +-
 .../joda/{test => }/time/TestParseISO.java    |    3 +-
 .../chrono/gj/MainTest.java}                  |  110 +-
 .../test/org/joda/time/chrono/gj/TestAll.java |   87 ++
 .../time/chrono/gj/TestGJChronology.java      |    2 +-
 .../time/chrono/gj/TestGJDateTimeField.java   |    2 +-
 .../time/chrono/gj/TestGJDayOfMonthField.java |    2 +-
 .../time/chrono/gj/TestGJDayOfWeekField.java  |    2 +-
 .../time/chrono/gj/TestGJDayOfYearField.java  |    2 +-
 .../chrono/gj/TestGJMonthOfYearField.java     |    2 +-
 .../chrono/gj/TestGJWeekOfWeekyearField.java  |    2 +-
 .../time/chrono/gj/TestGJWeekyearField.java   |    2 +-
 .../time/chrono/gj/TestGJYearField.java       |    2 +-
 .../chrono/gj/TestGregorianChronology.java    |    2 +-
 .../time/chrono/gj/TestJulianChronology.java  |    2 +-
 .../chrono/gj/TestJulianDayOfMonthField.java  |    2 +-
 .../chrono/gj/TestJulianMonthOfYearField.java |    2 +-
 .../chrono/gj/TestJulianWeekyearField.java    |    2 +-
 .../time/chrono/gj/TestJulianYearField.java   |    2 +-
 .../joda/time/partial/MockPartialInstant.java |  102 ++
 .../test/org/joda/time/partial/TestAll.java   |   86 ++
 .../org/joda/time/partial/TestTimeOfDay.java  | 1133 +++++++++++++++++
 29 files changed, 1673 insertions(+), 677 deletions(-)
 delete mode 100644 JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
 rename JodaTime/src/test/org/joda/{test => }/time/ClassLoadTest.java (99%)
 create mode 100644 JodaTime/src/test/org/joda/time/TestAll.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestAllPackages.java
 rename JodaTime/src/test/org/joda/{test => }/time/TestDateTimeComparator.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/TestParseISO.java (99%)
 rename JodaTime/src/test/org/joda/{test/time/chrono/gj/Test.java => time/chrono/gj/MainTest.java} (94%)
 create mode 100644 JodaTime/src/test/org/joda/time/chrono/gj/TestAll.java
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJChronology.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJDateTimeField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJDayOfMonthField.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJDayOfWeekField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJDayOfYearField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJMonthOfYearField.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJWeekOfWeekyearField.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJWeekyearField.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGJYearField.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestGregorianChronology.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestJulianChronology.java (99%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestJulianDayOfMonthField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestJulianMonthOfYearField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestJulianWeekyearField.java (98%)
 rename JodaTime/src/test/org/joda/{test => }/time/chrono/gj/TestJulianYearField.java (98%)
 create mode 100644 JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java
 create mode 100644 JodaTime/src/test/org/joda/time/partial/TestAll.java
 create mode 100644 JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java

diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
index f15d4b794..75409d87e 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
@@ -477,19 +477,19 @@ public void testGetDifference() throws Exception {
         for (int i = 0; i < var.length; i++) {
             long millis = var[i];
             long sum = field.add(millis, 1);
-            assertEquals(var, i, 1, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, 1, field.getDifference(sum, millis));
             sum = field.add(millis, -1);
-            assertEquals(var, i, -1, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, -1, field.getDifference(sum, millis));
             sum = field.add(millis, 0);
-            assertEquals(var, i, 0, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, 0, field.getDifference(sum, millis));
             sum = field.add(millis, 2);
-            assertEquals(var, i, 2, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, 2, field.getDifference(sum, millis));
             sum = field.add(millis, 8);
-            assertEquals(var, i, 8, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, 8, field.getDifference(sum, millis));
             sum = field.add(millis, 9);
-            assertEquals(var, i, 9, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, 9, field.getDifference(sum, millis));
             sum = field.add(millis, -13);
-            assertEquals(var, i, -13, (int)field.getDifference(sum, millis));
+            assertEquals(var, i, -13, field.getDifference(sum, millis));
         }
     }
 
diff --git a/JodaTime/src/test/org/joda/test/time/BulkTest.java b/JodaTime/src/test/org/joda/test/time/BulkTest.java
index 72320da4e..2aed3cb29 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time ;
+package org.joda.test.time;
 //
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
diff --git a/JodaTime/src/test/org/joda/test/time/TestInstant.java b/JodaTime/src/test/org/joda/test/time/TestInstant.java
index 8385c4b4f..51055cc2c 100644
--- a/JodaTime/src/test/org/joda/test/time/TestInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/TestInstant.java
@@ -60,6 +60,7 @@
 
 import junit.framework.TestSuite;
 
+import org.joda.test.time.*;
 import org.joda.time.AbstractInstant;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DateTime;
diff --git a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
deleted file mode 100644
index 69c363d40..000000000
--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java
+++ /dev/null
@@ -1,602 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time.partial;
-
-import java.util.Date;
-import java.util.Locale;
-
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-import org.joda.time.DateTime;
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeUtils;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.chrono.JulianChronology;
-import org.joda.time.partial.TimeOfDay;
-
-/**
- * This class is a Junit unit test for TimeOfDay.
- *
- * @author Stephen Colebourne
- */
-public class TestTimeOfDay extends TestCase {
-
-    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
-    
-    private long TEST_TIME =
-            10L * DateTimeConstants.MILLIS_PER_HOUR
-            + 20L * DateTimeConstants.MILLIS_PER_MINUTE
-            + 30L * DateTimeConstants.MILLIS_PER_SECOND
-            + 40L;
-            
-    private DateTimeZone zone = null;
-
-    public static void main(String[] args) {
-        junit.textui.TestRunner.run(suite());
-    }
-
-    public static TestSuite suite() {
-        return new TestSuite(TestTimeOfDay.class);
-    }
-
-    public TestTimeOfDay(String name) {
-        super(name);
-    }
-
-    protected void setUp() throws Exception {
-        DateTimeUtils.setCurrentMillisFixed(TEST_TIME);
-        zone = DateTimeZone.getDefault();
-        DateTimeZone.setDefault(DateTimeZone.UTC);
-    }
-
-    protected void tearDown() throws Exception {
-        DateTimeUtils.setCurrentMillisSystem();
-        DateTimeZone.setDefault(zone);
-        zone = null;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Test constructor ()
-     */
-    public void testConstructor() throws Throwable {
-        TimeOfDay test = new TimeOfDay();
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (Chronology)
-     */
-    public void testConstructor_Chronology() throws Throwable {
-        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (long)
-     */
-    public void testConstructor_long() throws Throwable {
-        TimeOfDay test = new TimeOfDay(TEST_TIME);
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (long, Chronology)
-     */
-    public void testConstructor_longChronology() throws Throwable {
-        TimeOfDay test = new TimeOfDay(TEST_TIME, JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (Object)
-     */
-    public void testConstructor_Object() throws Throwable {
-        Date date = new Date(TEST_TIME);
-        TimeOfDay test = new TimeOfDay(date);
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (Object, Chronology)
-     */
-    public void testConstructor_ObjectChronology() throws Throwable {
-        Date date = new Date(TEST_TIME);
-        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-    }
-
-    /**
-     * Test constructor (int, int)
-     */
-    public void testConstructor_intint() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20);
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(0, test.getSecondOfMinute());
-        assertEquals(0, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    /**
-     * Test constructor (int, int, int, Chronology)
-     */
-    public void testConstructor_intintChronology() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(0, test.getSecondOfMinute());
-        assertEquals(0, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    /**
-     * Test constructor (int, int, int)
-     */
-    public void testConstructor_intintint() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20, 30);
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(0, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20, 30);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20, 30);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1, 30);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60, 30);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, -1);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 60);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    /**
-     * Test constructor (int, int, int, Chronology)
-     */
-    public void testConstructor_intintintChronology() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(0, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    /**
-     * Test constructor (int, int, int, int)
-     */
-    public void testConstructor_intintintint() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20, 30, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20, 30, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1, 30, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60, 30, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, -1, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 60, 40);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 30, -1);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 30, 1000);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    /**
-     * Test constructor (int, int, int, int, Chronology)
-     */
-    public void testConstructor_intintintintChronology() throws Throwable {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());
-        assertEquals(JulianChronology.getInstance(), test.getChronology());
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        try {
-            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    public void testGet() {
-        TimeOfDay test = new TimeOfDay();
-        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));
-        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));
-        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));
-        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));
-        try {
-            test.get(null);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            test.get(ISOChronology.getInstance().dayOfMonth());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            test.get(ISOChronology.getInstance(PARIS).hourOfDay());
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        // TODO: Should this fail or suceed - by succeeding it exposes out implementation
-//        try {
-//            test.get(JulianChronology.getInstance().hourOfDay());
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-    }
-
-    public void testGetFieldSize() {
-        TimeOfDay test = new TimeOfDay();
-        assertEquals(4, test.getFieldSize());
-    }
-
-    public void testGetField() {
-        TimeOfDay test = new TimeOfDay();
-        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));
-        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));
-        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));
-        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));
-        try {
-            test.getField(-1);
-        } catch (IllegalArgumentException ex) {}
-        try {
-            test.getField(5);
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    public void testGetFields() {
-        TimeOfDay test = new TimeOfDay();
-        DateTimeField[] fields = test.getFields();
-        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);
-        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);
-        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);
-        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);
-    }
-
-    public void testGetValue() {
-        TimeOfDay test = new TimeOfDay();
-        assertEquals(10, test.getValue(0));
-        assertEquals(20, test.getValue(1));
-        assertEquals(30, test.getValue(2));
-        assertEquals(40, test.getValue(3));
-        try {
-            test.getValue(-1);
-        } catch (IllegalArgumentException ex) {}
-        try {
-            test.getValue(5);
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    public void testGetValues() {
-        TimeOfDay test = new TimeOfDay();
-        int[] values = test.getValues();
-        assertEquals(10, values[0]);
-        assertEquals(20, values[1]);
-        assertEquals(30, values[2]);
-        assertEquals(40, values[3]);
-    }
-
-    public void testIsSupported() {
-        TimeOfDay test = new TimeOfDay();
-        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));
-        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));
-        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));
-        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));
-        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));
-        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));
-    }
-
-    public void testEqualsHashCode() {
-        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(true, test1.equals(test2));
-        assertEquals(true, test2.equals(test1));
-        assertEquals(true, test1.equals(test1));
-        assertEquals(true, test2.equals(test2));
-        assertEquals(test1.hashCode(), test2.hashCode());
-        assertEquals(test1.hashCode(), test1.hashCode());
-        assertEquals(test2.hashCode(), test2.hashCode());
-        
-        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);
-        assertEquals(false, test1.equals(test3));
-        assertEquals(false, test2.equals(test3));
-        assertEquals(false, test3.equals(test1));
-        assertEquals(false, test3.equals(test2));
-        assertTrue(test1.hashCode() != test3.hashCode());
-        assertTrue(test2.hashCode() != test3.hashCode());
-    }
-
-    public void testResolve_long() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        DateTime dt = new DateTime(0L);
-        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
-        
-        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
-        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
-    }
-
-    public void testResolve_RI() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        DateTime dt = new DateTime(0L);
-        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
-        
-        DateTime result = test.resolveDateTime(dt);
-        assertEquals(10, test.getHourOfDay());
-        assertEquals(20, test.getMinuteOfHour());
-        assertEquals(30, test.getSecondOfMinute());
-        assertEquals(40, test.getMillisOfSecond());
-        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
-        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
-    }
-
-    public void testPropertyGet() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());
-        assertEquals("hourOfDay", test.hourOfDay().getName());
-        assertSame(test, test.hourOfDay().getPartialInstant());
-        assertSame(test, test.hourOfDay().getTimeOfDay());
-        assertEquals(10, test.hourOfDay().get());
-        assertEquals("10", test.hourOfDay().getAsText());
-        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));
-        assertEquals("10", test.hourOfDay().getAsShortText());
-        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));
-        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());
-        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());
-        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));
-        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
-    }
-
-    public void testPropertyGetMaxMinValues() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(0, test.hourOfDay().getMinimumValue());
-        assertEquals(0, test.hourOfDay().getMinimumValueOverall());
-        assertEquals(23, test.hourOfDay().getMaximumValue());
-        assertEquals(23, test.hourOfDay().getMaximumValueOverall());
-    }
-
-    public void testPropertyAddInField() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);
-        assertEquals(19, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
-        updated = updated.hourOfDay().addInFieldCopy(9);
-        assertEquals(4, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
-    }
-
-    public void testPropertySet() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.hourOfDay().setCopy(12);
-        assertEquals(12, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
-    }
-
-    public void testPropertySetText() {
-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.hourOfDay().setCopy("12");
-        assertEquals(12, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
-    }
-
-}
diff --git a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java b/JodaTime/src/test/org/joda/time/ClassLoadTest.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
rename to JodaTime/src/test/org/joda/time/ClassLoadTest.java
index 5991fd087..af1bf4d8c 100644
--- a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
+++ b/JodaTime/src/test/org/joda/time/ClassLoadTest.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time;
+package org.joda.time;
 
 import org.joda.time.AbstractDateTime;
 import org.joda.time.AbstractInstant;
diff --git a/JodaTime/src/test/org/joda/time/TestAll.java b/JodaTime/src/test/org/joda/time/TestAll.java
new file mode 100644
index 000000000..5cd67d197
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestAll.java
@@ -0,0 +1,87 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * Entry point for all tests in this package.
+ * 
+ * @version $Revision$ $Date$
+ * 
+ * @author Stephen Colebourne
+ */
+public class TestAll extends TestCase {
+
+    public TestAll(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        suite.addTest(TestDateTimeComparator.suite());
+        suite.addTest(TestParseISO.suite());
+        return suite;
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = {
+            TestAll.class.getName()
+        };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+}
\ No newline at end of file
diff --git a/JodaTime/src/test/org/joda/time/TestAllPackages.java b/JodaTime/src/test/org/joda/time/TestAllPackages.java
new file mode 100644
index 000000000..34789494b
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestAllPackages.java
@@ -0,0 +1,88 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * Entry point for all tests in Joda Time.
+ * 
+ * @version $Revision$ $Date$
+ * 
+ * @author Stephen Colebourne
+ */
+public class TestAllPackages extends TestCase {
+
+    public TestAllPackages(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        suite.addTest(org.joda.time.TestAll.suite());
+        suite.addTest(org.joda.time.chrono.gj.TestAll.suite());
+        suite.addTest(org.joda.time.partial.TestAll.suite());
+        return suite;
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = {
+            TestAllPackages.class.getName()
+        };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+}
\ No newline at end of file
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
rename to JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
index c615597df..42eaed214 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time;
+package org.joda.time;
 
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -62,6 +62,7 @@
 
 import junit.framework.TestSuite;
 
+import org.joda.test.time.*;
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeComparator;
diff --git a/JodaTime/src/test/org/joda/test/time/TestParseISO.java b/JodaTime/src/test/org/joda/time/TestParseISO.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/TestParseISO.java
rename to JodaTime/src/test/org/joda/time/TestParseISO.java
index eecb53608..2162b1f80 100644
--- a/JodaTime/src/test/org/joda/test/time/TestParseISO.java
+++ b/JodaTime/src/test/org/joda/time/TestParseISO.java
@@ -51,11 +51,12 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time;
+package org.joda.time;
 
 import junit.framework.Assert;
 import junit.framework.TestSuite;
 
+import org.joda.test.time.*;
 import org.joda.time.DateTimeZone;
 import org.joda.time.MutableDateTime;
 import org.joda.time.format.DateTimeParser;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
similarity index 94%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
index 8652a73f4..4818f88cb 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
@@ -51,14 +51,15 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import java.util.Random;
 
+import junit.framework.TestCase;
+
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
 import org.joda.time.chrono.GregorianChronology;
 import org.joda.time.chrono.JulianChronology;
 
@@ -84,7 +85,7 @@
  *
  * @author Brian S O'Neill
  */
-public class Test {
+public class MainTest extends TestCase {
     public static final int GREGORIAN_MODE = 0;
     public static final int JULIAN_MODE = 1;
 
@@ -122,17 +123,44 @@ public static void main(String[] args) throws Exception {
             }
         }
 
-        test(iterations, mode, seed);
+        new MainTest(iterations, mode, seed).testChronology();
     }
 
+    //-----------------------------------------------------------------------
+    private final int iIterations;
+    private final int iMode;
+    private final long iSeed;
+    private final Chronology iTest;
+    private final Chronology iActual;
+
     /**
      * @param iterations number of test iterations to perform
-     * @param mode GREGORIAN_MODE or JULIAN_MODE
+     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian
      * @param seed seed for random number generator
      */
-    public static void test(final int iterations, int mode, long seed) {
-        String modeStr;
+    public MainTest(int iterations, int mode, long seed) {
+        super("testChronology");
+        iIterations = iterations;
+        iMode = mode;
+        iSeed = seed;
         if (mode == GREGORIAN_MODE) {
+            iTest = new TestGregorianChronology();
+            iActual = GregorianChronology.getInstanceUTC();
+        } else {
+            iTest = new TestJulianChronology();
+            iActual = JulianChronology.getInstanceUTC();
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Main junit test
+     */
+    public void testChronology() {
+        int iterations = iIterations;
+        long seed = iSeed;
+        String modeStr;
+        if (iMode == GREGORIAN_MODE) {
             modeStr = "Gregorian";
         } else {
             modeStr = "Julian";
@@ -140,7 +168,6 @@ public static void test(final int iterations, int mode, long seed) {
 
         System.out.println("Testing " + modeStr + " chronology over " + iterations + " iterations");
 
-        Test t = new Test(mode);
         Random rnd = new Random(seed);
         long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;
 
@@ -160,58 +187,21 @@ public static void test(final int iterations, int mode, long seed) {
             long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;
 
             try {
-                t.testFields(millis, value, millis2);
+                testFields(millis, value, millis2);
             } catch (RuntimeException e) {
                 System.out.println("Failure index: " + i);
                 System.out.println("Test millis: " + millis);
                 System.out.println("Test value: " + value);
                 System.out.println("Test millis2: " + millis2);
-                throw e;
+                fail(e.getMessage());
             }
         }
 
         System.out.println("100% complete (i=" + iterations + ")");
     }
 
-    private static long randomMillis(Random rnd) {
-        long millis = rnd.nextLong();
-        if (millis >= 0) {
-            millis = millis % MAX_MILLIS;
-        } else {
-            millis = millis % -MIN_MILLIS;
-        }
-        return millis;
-    }
-
-    private static void dump(Chronology chrono, long millis) {
-        System.out.println("year:           " + chrono.year().get(millis));
-        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));
-        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));
-        System.out.println("weekyear:       " + chrono.weekyear().get(millis));
-        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));
-        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));
-        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));
-    }
-
-    private final int iMode;
-    private final Chronology iTest;
-    private final Chronology iActual;
-
-    /**
-     * @param mode 0=Gregorian, 1=Julian
-     */
-    public Test(int mode) {
-        iMode = mode;
-        if (mode == GREGORIAN_MODE) {
-            iTest = new TestGregorianChronology();
-            iActual = GregorianChronology.getInstanceUTC();
-        } else {
-            iTest = new TestJulianChronology();
-            iActual = JulianChronology.getInstanceUTC();
-        }
-    }
-
-    public void testFields(long millis, int value, long millis2) {
+    //-----------------------------------------------------------------------
+    private void testFields(long millis, int value, long millis2) {
         testField(iTest.year(), iActual.year(), millis, value, millis2);
         testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);
         testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);
@@ -467,4 +457,26 @@ private String makeDate(long millis, Chronology chrono) {
             chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +
             "-" + chrono.dayOfWeek().get(millis);
     }
+
+    //-----------------------------------------------------------------------
+    private static long randomMillis(Random rnd) {
+        long millis = rnd.nextLong();
+        if (millis >= 0) {
+            millis = millis % MAX_MILLIS;
+        } else {
+            millis = millis % -MIN_MILLIS;
+        }
+        return millis;
+    }
+
+    private static void dump(Chronology chrono, long millis) {
+        System.out.println("year:           " + chrono.year().get(millis));
+        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));
+        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));
+        System.out.println("weekyear:       " + chrono.weekyear().get(millis));
+        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));
+        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));
+        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));
+    }
+
 }
diff --git a/JodaTime/src/test/org/joda/time/chrono/gj/TestAll.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestAll.java
new file mode 100644
index 000000000..53c3fb70d
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestAll.java
@@ -0,0 +1,87 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono.gj;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * Entry point for all tests in this package.
+ * 
+ * @version $Revision$ $Date$
+ * 
+ * @author Stephen Colebourne
+ */
+public class TestAll extends TestCase {
+
+    public TestAll(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        suite.addTest(new MainTest(200, 0, 1345435247779935L));
+        suite.addTest(new MainTest(200, 1, 1345435247779935L));
+        return suite;
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = {
+            TestAll.class.getName()
+        };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+}
\ No newline at end of file
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java
index 4bf02ae27..943322fcc 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java
index 819e08a55..b563adf98 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.field.ImpreciseDateTimeField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
index 6fc31f622..e145e1bd9 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java
index 08f1025d2..0d23079c1 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java
index efd4e4967..9d81bdd7d 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java
index 4f5e1f542..7ec90bc5c 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java
index a45f84e59..15224ad78 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java
index 7ea50de43..c02ec97a4 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java
index 93e4c3809..721ebc72d 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestGregorianChronology.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestGregorianChronology.java
index bbaafc46a..bd794bc68 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGregorianChronology.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianChronology.java
similarity index 99%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestJulianChronology.java
index a81eb712a..39268b617 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianChronology.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianDayOfMonthField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestJulianDayOfMonthField.java
index 4c5a3181e..3c1081486 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianDayOfMonthField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 /**
  * 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianMonthOfYearField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestJulianMonthOfYearField.java
index c154238d5..7113c8437 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianMonthOfYearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 /**
  * 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
index 13361cb19..4f506161c 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.field.FieldUtils;
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
similarity index 98%
rename from JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
rename to JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
index 616a2fa75..a9779cfb7 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.test.time.chrono.gj;
+package org.joda.time.chrono.gj;
 
 import org.joda.time.field.FieldUtils;
 
diff --git a/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java b/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java
new file mode 100644
index 000000000..0e42a267f
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java
@@ -0,0 +1,102 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+
+/**
+ * A basic mock testing class for a PartialInstant that doesn't extend AbstractPartialInstant.
+ *
+ * @author Stephen Colebourne
+ */
+public class MockPartialInstant implements PartialInstant {
+    
+    public static final PartialInstant EMPTY_INSTANCE = new MockPartialInstant();
+    
+    public Chronology getChronology() {
+        return ISOChronology.getInstance();
+    }
+    public int getFieldSize() {
+        return 0;
+    }
+    public DateTimeField getField(int index) {
+        return null;
+    }
+    public int getValue(int index) {
+        return 0;
+    }
+    public int get(DateTimeField field) {
+        return 0;
+    }
+    public boolean isSupported(DateTimeField field) {
+        return false;
+    }
+    public long resolve(long baseMillis, DateTimeZone tz) {
+        return 0L;
+    }
+    public DateTime resolveDateTime(ReadableInstant base) {
+        return null;
+    }
+    public DateTimeField[] getFields() {
+        return new DateTimeField[0];
+    }
+    public int[] getValues() {
+        return new int[0];
+    }
+}
diff --git a/JodaTime/src/test/org/joda/time/partial/TestAll.java b/JodaTime/src/test/org/joda/time/partial/TestAll.java
new file mode 100644
index 000000000..e43b40112
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/partial/TestAll.java
@@ -0,0 +1,86 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * Entry point for all tests in this package.
+ * 
+ * @version $Revision$ $Date$
+ * 
+ * @author Stephen Colebourne
+ */
+public class TestAll extends TestCase {
+
+    public TestAll(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        suite.addTest(TestTimeOfDay.suite());
+        return suite;
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = {
+            TestAll.class.getName()
+        };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+}
\ No newline at end of file
diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
new file mode 100644
index 000000000..6515d4a99
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -0,0 +1,1133 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.MockZeroNullIntegerConverter;
+
+/**
+ * This class is a Junit unit test for TimeOfDay.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestTimeOfDay extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    
+    private long TEST_TIME_NOW =
+            10L * DateTimeConstants.MILLIS_PER_HOUR
+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE
+            + 30L * DateTimeConstants.MILLIS_PER_SECOND
+            + 40L;
+            
+    private long TEST_TIME1 =
+        1L * DateTimeConstants.MILLIS_PER_HOUR
+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE
+        + 3L * DateTimeConstants.MILLIS_PER_SECOND
+        + 4L;
+        
+    private long TEST_TIME2 =
+        1L * DateTimeConstants.MILLIS_PER_DAY
+        + 5L * DateTimeConstants.MILLIS_PER_HOUR
+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE
+        + 7L * DateTimeConstants.MILLIS_PER_SECOND
+        + 8L;
+        
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestTimeOfDay.class);
+    }
+
+    public TestTimeOfDay(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        DateTimeZone.setDefault(DateTimeZone.UTC);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Chronology)
+     */
+    public void testConstructor_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Chronology=null)
+     */
+    public void testConstructor_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay((Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long1() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME1);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long2() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME2);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(5, test.getHourOfDay());
+        assertEquals(6, test.getMinuteOfHour());
+        assertEquals(7, test.getSecondOfMinute());
+        assertEquals(8, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long1_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long2_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(5, test.getHourOfDay());
+        assertEquals(6, test.getMinuteOfHour());
+        assertEquals(7, test.getSecondOfMinute());
+        assertEquals(8, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (long, Chronology=null)
+     */
+    public void testConstructor_long_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        TimeOfDay test = new TimeOfDay(date);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_nullObject() throws Throwable {
+        TimeOfDay test = new TimeOfDay(null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            TimeOfDay test = new TimeOfDay(new Integer(0));
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0, test.getHourOfDay());
+            assertEquals(0, test.getMinuteOfHour());
+            assertEquals(0, test.getSecondOfMinute());
+            assertEquals(0, test.getMillisOfSecond());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_Object_Chronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology)
+     */
+    public void testConstructor_nullObject_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object, Chronology=null)
+     */
+    public void testConstructor_Object_nullChronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        TimeOfDay test = new TimeOfDay(date, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology=null)
+     */
+    public void testConstructor_nullObject_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay((Object) null, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject_Chronology() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0, test.getHourOfDay());
+            assertEquals(0, test.getMinuteOfHour());
+            assertEquals(0, test.getSecondOfMinute());
+            assertEquals(0, test.getMillisOfSecond());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (int, int)
+     */
+    public void testConstructor_int_int() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (int, int, int)
+     */
+    public void testConstructor_int_int_int() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_int_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_int_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(0, test.getMillisOfSecond());
+    }
+
+    /**
+     * Test constructor (int, int, int, int)
+     */
+    public void testConstructor_int_int_int_int() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, -1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, 1000);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_int_int_Chronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());
+        assertEquals(JulianChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        try {
+            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGet() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));
+        try {
+            test.get(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance().dayOfMonth());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance(PARIS).hourOfDay());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation
+//        try {
+//            test.get(JulianChronology.getInstance().hourOfDay());
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetFieldSize() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(4, test.getFieldSize());
+    }
+
+    public void testGetField() {
+        TimeOfDay test = new TimeOfDay();
+        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));
+        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));
+        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));
+        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));
+        try {
+            test.getField(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getField(5);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetFields() {
+        TimeOfDay test = new TimeOfDay();
+        DateTimeField[] fields = test.getFields();
+        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);
+        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);
+        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);
+        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);
+    }
+
+    public void testGetValue() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(10, test.getValue(0));
+        assertEquals(20, test.getValue(1));
+        assertEquals(30, test.getValue(2));
+        assertEquals(40, test.getValue(3));
+        try {
+            test.getValue(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getValue(5);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetValues() {
+        TimeOfDay test = new TimeOfDay();
+        int[] values = test.getValues();
+        assertEquals(10, values[0]);
+        assertEquals(20, values[1]);
+        assertEquals(30, values[2]);
+        assertEquals(40, values[3]);
+    }
+
+    public void testIsSupported() {
+        TimeOfDay test = new TimeOfDay();
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));
+    }
+
+    public void testEqualsHashCode() {
+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(true, test1.equals(test2));
+        assertEquals(true, test2.equals(test1));
+        assertEquals(true, test1.equals(test1));
+        assertEquals(true, test2.equals(test2));
+        assertEquals(true, test1.hashCode() == test2.hashCode());
+        assertEquals(true, test1.hashCode() == test1.hashCode());
+        assertEquals(true, test2.hashCode() == test2.hashCode());
+        
+        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);
+        assertEquals(false, test1.equals(test3));
+        assertEquals(false, test2.equals(test3));
+        assertEquals(false, test3.equals(test1));
+        assertEquals(false, test3.equals(test2));
+        assertEquals(false, test1.hashCode() == test3.hashCode());
+        assertEquals(false, test2.hashCode() == test3.hashCode());
+        
+        assertEquals(false, test1.equals("Hello"));
+        assertEquals(true, test1.equals(new MockInstant()));
+        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));
+    }
+    
+    class MockInstant extends MockPartialInstant {
+        public DateTimeField[] getFields() {
+            return new DateTimeField[] {
+                ISOChronology.getInstance().hourOfDay(),
+                ISOChronology.getInstance().minuteOfHour(),
+                ISOChronology.getInstance().secondOfMinute(),
+                ISOChronology.getInstance().millisOfSecond(),
+            };
+        }
+        public int[] getValues() {
+            return new int[] {10, 20, 30, 40};
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    public void testResolve_long() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        DateTime dt = new DateTime(0L);
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        
+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
+    }
+
+    public void testResolveDateTime_RI() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        DateTime dt = new DateTime(0L);
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        
+        DateTime result = test.resolveDateTime(dt);
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());
+        assertEquals("1970-01-01T10:20:30.040Z", result.toString());
+    }
+
+    public void testResolveDateTime_nullRI() {
+        TimeOfDay test = new TimeOfDay(1, 2, 3, 4);
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);
+        
+        DateTime result = test.resolveDateTime(null);
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(2, test.getMinuteOfHour());
+        assertEquals(3, test.getSecondOfMinute());
+        assertEquals(4, test.getMillisOfSecond());
+        assertEquals("1970-01-02T01:02:03.004Z", result.toString());
+    }
+
+    public void testResolveInto_RWI() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        MutableDateTime mdt = new MutableDateTime(0L);
+        assertEquals("1970-01-01T00:00:00.000Z", mdt.toString());
+        
+        test.resolveInto(mdt);
+        assertEquals(10, test.getHourOfDay());
+        assertEquals(20, test.getMinuteOfHour());
+        assertEquals(30, test.getSecondOfMinute());
+        assertEquals(40, test.getMillisOfSecond());
+        assertEquals("1970-01-01T10:20:30.040Z", mdt.toString());
+    }
+
+    public void testResolveInto_nullRWI() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        
+        try {
+            test.resolveInto(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSerialization() throws Exception {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject(test);
+        byte[] bytes = baos.toByteArray();
+        oos.close();
+        
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        ObjectInputStream ois = new ObjectInputStream(bais);
+        TimeOfDay result = (TimeOfDay) ois.readObject();
+        ois.close();
+        
+        assertEquals(test, result);
+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));
+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));
+        assertEquals(test.getChronology(), result.getChronology());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        // TODO
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());
+        assertEquals("hourOfDay", test.hourOfDay().getName());
+        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());
+        assertSame(test, test.hourOfDay().getPartialInstant());
+        assertSame(test, test.hourOfDay().getTimeOfDay());
+        assertEquals(10, test.hourOfDay().get());
+        assertEquals("10", test.hourOfDay().getAsText());
+        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));
+        assertEquals("10", test.hourOfDay().getAsShortText());
+        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());
+        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());
+        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));
+        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(0, test.hourOfDay().getMinimumValue());
+        assertEquals(0, test.hourOfDay().getMinimumValueOverall());
+        assertEquals(23, test.hourOfDay().getMaximumValue());
+        assertEquals(23, test.hourOfDay().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddInFieldHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);
+        assertEquals(19, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+        updated = updated.hourOfDay().addInFieldCopy(9);
+        assertEquals(4, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+    }
+
+    public void testPropertySetHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.hourOfDay().setCopy(12);
+        assertEquals(12, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertySetTextHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.hourOfDay().setCopy("12");
+        assertEquals(12, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertyCompareToHour() {
+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);
+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);
+        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);
+        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);
+        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);
+        try {
+            test1.hourOfDay().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);
+        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);
+        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);
+        try {
+            test1.hourOfDay().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());
+        assertEquals("minuteOfHour", test.minuteOfHour().getName());
+        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());
+        assertSame(test, test.minuteOfHour().getPartialInstant());
+        assertSame(test, test.minuteOfHour().getTimeOfDay());
+        assertEquals(20, test.minuteOfHour().get());
+        assertEquals("20", test.minuteOfHour().getAsText());
+        assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH));
+        assertEquals("20", test.minuteOfHour().getAsShortText());
+        assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());
+        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());
+        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));
+        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(0, test.minuteOfHour().getMinimumValue());
+        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());
+        assertEquals(59, test.minuteOfHour().getMaximumValue());
+        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddInFieldMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay updated = test.minuteOfHour().addInFieldCopy(9);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(29, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+        updated = updated.minuteOfHour().addInFieldCopy(49);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(18, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+    }
+
+    public void testPropertySetMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.minuteOfHour().setCopy(12);
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(12, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertySetTextMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.minuteOfHour().setCopy("12");
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(12, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertyCompareToMinute() {
+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);
+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);
+        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);
+        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);
+        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);
+        try {
+            test1.minuteOfHour().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);
+        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);
+        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);
+        try {
+            test1.minuteOfHour().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());
+        assertEquals("secondOfMinute", test.secondOfMinute().getName());
+        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());
+        assertSame(test, test.secondOfMinute().getPartialInstant());
+        assertSame(test, test.secondOfMinute().getTimeOfDay());
+        assertEquals(30, test.secondOfMinute().get());
+        assertEquals("30", test.secondOfMinute().getAsText());
+        assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH));
+        assertEquals("30", test.secondOfMinute().getAsShortText());
+        assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());
+        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());
+        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));
+        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(0, test.secondOfMinute().getMinimumValue());
+        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());
+        assertEquals(59, test.secondOfMinute().getMaximumValue());
+        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddInFieldSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay updated = test.secondOfMinute().addInFieldCopy(9);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(39, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+        updated = updated.secondOfMinute().addInFieldCopy(49);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(28, updated.getSecondOfMinute());
+        assertEquals(40, updated.getMillisOfSecond());
+    }
+
+    public void testPropertySetSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.secondOfMinute().setCopy(12);
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(12, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertySetTextSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.secondOfMinute().setCopy("12");
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(12, set.getSecondOfMinute());
+        assertEquals(40, set.getMillisOfSecond());
+    }
+
+    public void testPropertyCompareToSecond() {
+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);
+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);
+        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);
+        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);
+        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);
+        try {
+            test1.secondOfMinute().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);
+        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);
+        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);
+        try {
+            test1.secondOfMinute().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());
+        assertEquals("millisOfSecond", test.millisOfSecond().getName());
+        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());
+        assertSame(test, test.millisOfSecond().getPartialInstant());
+        assertSame(test, test.millisOfSecond().getTimeOfDay());
+        assertEquals(40, test.millisOfSecond().get());
+        assertEquals("40", test.millisOfSecond().getAsText());
+        assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH));
+        assertEquals("40", test.millisOfSecond().getAsShortText());
+        assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());
+        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());
+        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));
+        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals(0, test.millisOfSecond().getMinimumValue());
+        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());
+        assertEquals(999, test.millisOfSecond().getMaximumValue());
+        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddInFieldMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay updated = test.millisOfSecond().addInFieldCopy(9);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(49, updated.getMillisOfSecond());
+        updated = updated.millisOfSecond().addInFieldCopy(990);
+        assertEquals(10, updated.getHourOfDay());
+        assertEquals(20, updated.getMinuteOfHour());
+        assertEquals(30, updated.getSecondOfMinute());
+        assertEquals(39, updated.getMillisOfSecond());
+    }
+
+    public void testPropertySetMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.millisOfSecond().setCopy(12);
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(12, set.getMillisOfSecond());
+    }
+
+    public void testPropertySetTextMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay set = test.millisOfSecond().setCopy("12");
+        assertEquals(10, set.getHourOfDay());
+        assertEquals(20, set.getMinuteOfHour());
+        assertEquals(30, set.getSecondOfMinute());
+        assertEquals(12, set.getMillisOfSecond());
+    }
+
+    public void testPropertyCompareToMilli() {
+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);
+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);
+        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);
+        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);
+        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);
+        try {
+            test1.millisOfSecond().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);
+        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);
+        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);
+        try {
+            test1.millisOfSecond().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+}

From 9010b04f02adce656b9fe295dd25301326ffacfb Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:46:14 +0000
Subject: [PATCH 0075/1934] Mock converter

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@225 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../convert/MockZeroNullIntegerConverter.java | 96 +++++++++++++++++++
 1 file changed, 96 insertions(+)
 create mode 100644 JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java

diff --git a/JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java b/JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java
new file mode 100644
index 000000000..793e9d0da
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java
@@ -0,0 +1,96 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+
+/**
+ * A basic mock testing class for a converter.
+ * This converter returns zero and null for an Integer input.
+ *
+ * @author Stephen Colebourne
+ */
+public class MockZeroNullIntegerConverter implements InstantConverter {
+    
+    public static final InstantConverter INSTANCE = new MockZeroNullIntegerConverter();
+
+    public long getInstantMillis(Object object) {
+        return 0;
+    }
+
+    public long getInstantMillis(Object object, DateTimeZone zone) {
+        return 0;
+    }
+
+    public long getInstantMillis(Object object, Chronology chrono) {
+        return 0;
+    }
+
+    public Chronology getChronology(Object object) {
+        return null;
+    }
+
+    public Chronology getChronology(Object object, DateTimeZone zone) {
+        return null;
+    }
+
+    public Chronology getChronology(Object object, Chronology chrono) {
+        return null;
+    }
+
+    public Class getSupportedType() {
+        return Integer.class;
+    }
+}

From af91631a3cb2b98dc26f2b2a980e0dc3bf19dccf Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 15:46:39 +0000
Subject: [PATCH 0076/1934] Tests for converter package

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@226 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../test/org/joda/time/convert/TestAll.java   |  86 ++++++++++
 .../joda/time/convert/TestLongConverter.java  | 154 ++++++++++++++++++
 2 files changed, 240 insertions(+)
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestAll.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestLongConverter.java

diff --git a/JodaTime/src/test/org/joda/time/convert/TestAll.java b/JodaTime/src/test/org/joda/time/convert/TestAll.java
new file mode 100644
index 000000000..50439037c
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestAll.java
@@ -0,0 +1,86 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * Entry point for all tests in this package.
+ * 
+ * @version $Revision$ $Date$
+ * 
+ * @author Stephen Colebourne
+ */
+public class TestAll extends TestCase {
+
+    public TestAll(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        suite.addTest(TestLongConverter.suite());
+        return suite;
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = {
+            TestAll.class.getName()
+        };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+}
\ No newline at end of file
diff --git a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
new file mode 100644
index 000000000..2c9cc8c86
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
@@ -0,0 +1,154 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for TimeOfDay.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestLongConverter extends TestCase {
+
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final Chronology ISO = ISOChronology.getInstance();
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestLongConverter.class);
+    }
+
+    public TestLongConverter(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = LongConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(Long.class, LongConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetInstantMillis_Object() throws Exception {
+        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L)));
+    }
+
+    public void testGetInstantMillis_Object_Zone() throws Exception {
+        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), PARIS));
+        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (DateTimeZone) null));
+    }
+
+    public void testGetInstantMillis_Object_Chronology() throws Exception {
+        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN));
+        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetChronology_Object() throws Exception {
+        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L)));
+    }
+
+    public void testGetChronology_Object_Zone() throws Exception {
+        assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS));
+        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null));
+    }
+
+    public void testGetChronology_Object_Chronology() throws Exception {
+        assertEquals(JULIAN, LongConverter.INSTANCE.getChronology(new Long(123L), JULIAN));
+        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    // TODO duration tests
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());
+    }
+
+}

From 516a6f5614a7a1d6559faab629fd9db7df36ca50 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 26 Jun 2004 17:07:38 +0000
Subject: [PATCH 0077/1934] Fixed @param doc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@227 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/partial/AbstractPartialInstant.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
index 76a2b809e..87f940150 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
@@ -444,7 +444,7 @@ protected long resolve(long baseMillis, Chronology chrono) {
      * Compares this PartialInstant with another returning true if the chronology,
      * fields and values are equal.
      *
-     * @param AbstractPartialInstant  an object to check against
+     * @param instant  an object to check against
      * @return true if fields and values are equal
      */
     public boolean equals(Object instant) {

From 8dd8b3d70aa140e4a6cf5675531ba414d7545e4a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 19:13:59 +0000
Subject: [PATCH 0078/1934] Add toString

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@228 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/convert/AbstractConverter.java    | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
index a988194a2..2561f1c3b 100644
--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -162,4 +162,13 @@ public Chronology getChronology(Object object, Chronology chrono) {
         return chrono;
     }
     
+    /**
+     * Gets a debugging string version of this converter.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        return "Converter[" + getSupportedType() + "]";
+    }
+
 }

From ea67740bc7bdfe700ec02bb27e5670541b1ecbf2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 19:17:10 +0000
Subject: [PATCH 0079/1934] Add support for PartialInstant field add()

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@229 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java |  49 +++
 .../chrono/CopticDayOfMonthDateTimeField.java |  21 ++
 .../chrono/GJDayOfMonthDateTimeField.java     |  18 +
 .../time/chrono/GJDayOfYearDateTimeField.java |  12 +
 .../chrono/GJWeekOfWeekyearDateTimeField.java |  12 +
 .../joda/time/field/BaseDateTimeField.java    | 108 +++++-
 .../time/field/DelegatedDateTimeField.java    |  12 +
 .../joda/time/field/NonZeroDateTimeField.java |  19 ++
 .../time/field/UnsupportedDateTimeField.java  |  27 ++
 .../java/org/joda/time/partial/TimeOfDay.java |  45 +--
 .../org/joda/time/partial/TestTimeOfDay.java  | 307 +++++++++++++-----
 11 files changed, 528 insertions(+), 102 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 736ca2aa9..4bc678304 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -231,6 +231,35 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      */
     public abstract long add(long instant, long value);
 
+    /**
+     * Adds a value (which may be negative) to the partial instant,
+     * throwing an exception if the maximum size of the instant is reached.
+     * <p>
+     * The value will be added to this field, overflowing into larger fields
+     * if necessary. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * Partial instants only contain some fields. This may result in a maximum
+     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this
+     * limit is breached by the add an exception is thrown.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 add six months is 2000-02-20<br>
+     * 2000-08-20 add twenty months is 2000-04-20<br>
+     * 2000-08-20 add minus nine months is 2000-11-20<br>
+     * 2001-01-31 add one month  is 2001-02-28<br>
+     * 2001-01-31 add two months is 2001-03-31<br>
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param valueToAdd  the value to add, in the units of the field
+     * @return the passed in values
+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
+     */
+    public abstract int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);
+
     /**
      * Adds a value (which may be negative) to the millis value,
      * wrapping within this field.
@@ -480,6 +509,16 @@ public long set(long instant, String text) {
      */
     public abstract int getMinimumValue(PartialInstant instant);
 
+    /**
+     * Get the minimum value for this field using the partial instant and
+     * the specified values.
+     * 
+     * @param instant  the partial instant to query
+     * @param values  the values to use
+     * @return the minimum value for this field, in the units of the field
+     */
+    public abstract int getMinimumValue(PartialInstant instant, int[] values);
+
     /**
      * Get the maximum allowable value for this field.
      * 
@@ -504,6 +543,16 @@ public long set(long instant, String text) {
      */
     public abstract int getMaximumValue(PartialInstant instant);
 
+    /**
+     * Get the maximum value for this field using the partial instant and
+     * the specified values.
+     * 
+     * @param instant  the partial instant to query
+     * @param values  the values to use
+     * @return the maximum value for this field, in the units of the field
+     */
+    public abstract int getMaximumValue(PartialInstant instant, int[] values);
+
     /**
      * Get the maximum text value for this field.
      * 
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
index 5d310cdcc..e03dd4448 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono;
 
+import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 import org.joda.time.partial.PartialInstant;
@@ -115,6 +116,26 @@ public int getMaximumValue(PartialInstant instant) {
         return 30;
     }
 
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        DateTimeField[] fields = instant.getFields();
+        for (int i = 0; i < fields.length; i++) {
+            if (fields[i] == iChronology.monthOfYear()) {
+                int month = values[i];
+                if (month <= 12) {
+                    return 30;
+                }
+                for (int j = 0; j < fields.length; j++) {
+                    if (fields[j] == iChronology.year()) {
+                        int year = values[j];
+                        return iChronology.isLeapYear(year) ? 6 : 5;
+                    }
+                }
+                return 6;
+            }
+        }
+        return 30;
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
index 0139b6f76..613ed84de 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono;
 
+import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 import org.joda.time.partial.PartialInstant;
@@ -119,6 +120,23 @@ public int getMaximumValue(PartialInstant instant) {
         return 31;
     }
 
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        DateTimeField[] fields = instant.getFields();
+        for (int i = 0; i < fields.length; i++) {
+            if (fields[i] == iChronology.monthOfYear()) {
+                int month = values[i];
+                for (int j = 0; j < fields.length; j++) {
+                    if (fields[j] == iChronology.year()) {
+                        int year = values[j];
+                        return iChronology.getDaysInYearMonth(year, month);
+                    }
+                }
+                return iChronology.getDaysInMonthMax(month);
+            }
+        }
+        return 31;
+    }
+
     protected int getMaximumValueForSet(long instant, int value) {
         return value > 28 ? getMaximumValue(instant) : 28;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
index 7733889ea..36e93e53a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono;
 
+import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 import org.joda.time.partial.PartialInstant;
@@ -114,6 +115,17 @@ public int getMaximumValue(PartialInstant instant) {
         return 366;
     }
 
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        DateTimeField[] fields = instant.getFields();
+        for (int i = 0; i < fields.length; i++) {
+            if (fields[i] == iChronology.year()) {
+                int year = values[i];
+                return iChronology.getDaysInYear(year);
+            }
+        }
+        return 366;
+    }
+
     protected int getMaximumValueForSet(long instant, int value) {
         return value > 365 ? getMaximumValue(instant) : 365;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
index c00bbeee9..ff55f2b84 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 import org.joda.time.partial.PartialInstant;
@@ -134,6 +135,17 @@ public int getMaximumValue(PartialInstant instant) {
         return 53;
     }
 
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        DateTimeField[] fields = instant.getFields();
+        for (int i = 0; i < fields.length; i++) {
+            if (fields[i] == iChronology.weekyear()) {
+                int weekyear = values[i];
+                return iChronology.getWeeksInYear(weekyear);
+            }
+        }
+        return 53;
+    }
+
     protected int getMaximumValueForSet(long instant, int value) {
         return value > 52 ? getMaximumValue(instant) : 52;
     }
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index f9f2797c3..d14071197 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -250,6 +250,82 @@ public long add(long instant, long value) {
         return getDurationField().add(instant, value);
     }
 
+    /**
+     * Adds a value (which may be negative) to the partial instant,
+     * throwing an exception if the maximum size of the instant is reached.
+     * <p>
+     * The value will be added to this field, overflowing into larger fields
+     * if necessary. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * Partial instants only contain some fields. This may result in a maximum
+     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this
+     * limit is breached by the add an exception is thrown.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 add six months is 2000-02-20<br>
+     * 2000-08-20 add twenty months is 2000-04-20<br>
+     * 2000-08-20 add minus nine months is 2000-11-20<br>
+     * 2001-01-31 add one month  is 2001-02-28<br>
+     * 2001-01-31 add two months is 2001-03-31<br>
+     * 
+     * @param instant  the partial instant
+     * @param fieldIndex  the index of this field in the instant
+     * @param values  the values of the partial instant which should be updated
+     * @param valueToAdd  the value to add, in the units of the field
+     * @return the passed in values
+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
+     */
+    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        // there are more efficient algorithms than this (especially for time only fields)
+        // trouble is when dealing with days and months, so we use this technique of
+        // adding/removing one from the larger field at a time
+        DateTimeField nextField = null;
+        
+        while (valueToAdd > 0) {
+            int max = getMaximumValue(instant, values);
+            long proposed = values[fieldIndex] + valueToAdd;
+            if (proposed <= max) {
+                values[fieldIndex] = (int) proposed;
+                return values;
+            }
+            if (nextField == null) {
+                if (fieldIndex == 0) {
+                    throw new IllegalArgumentException("Maximum value exceeded for add");
+                }
+                nextField = instant.getField(fieldIndex - 1);
+                if (getRangeDurationField() != nextField.getDurationField()) {
+                    throw new IllegalArgumentException("Fields invalid for add");
+                }
+            }
+            valueToAdd -= (max + 1) - values[fieldIndex];
+            values = nextField.add(instant, fieldIndex - 1, values, 1);
+            values[fieldIndex] = getMinimumValue(instant, values);
+        }
+        while (valueToAdd < 0) {
+            int min = getMinimumValue(instant, values);
+            long proposed = values[fieldIndex] + valueToAdd;
+            if (proposed >= min) {
+                values[fieldIndex] = (int) proposed;
+                return values;
+            }
+            if (nextField == null) {
+                if (fieldIndex == 0) {
+                    throw new IllegalArgumentException("Maximum value exceeded for add");
+                }
+                nextField = instant.getField(fieldIndex - 1);
+                if (getRangeDurationField() != nextField.getDurationField()) {
+                    throw new IllegalArgumentException("Fields invalid for add");
+                }
+            }
+            valueToAdd -= (min - 1) - values[fieldIndex];
+            values = nextField.add(instant, fieldIndex - 1, values, -1);
+            values[fieldIndex] = getMaximumValue(instant, values);
+        }
+        return values;
+    }
+
     /**
      * Adds a value (which may be negative) to the instant value,
      * wrapping within this field.
@@ -537,7 +613,7 @@ public int getMinimumValue(long instant) {
     }
 
     /**
-     * Get the minimum value for this field evaluated at the specified time.
+     * Get the minimum value for this field evaluated at the specified instant.
      * <p>
      * This implementation returns the same as {@link #getMinimumValue()}.
      * 
@@ -548,6 +624,20 @@ public int getMinimumValue(PartialInstant instant) {
         return getMinimumValue();
     }
 
+    /**
+     * Get the minimum value for this field using the partial instant and
+     * the specified values.
+     * <p>
+     * This implementation returns the same as {@link #getMinimumValue(PartialInstant)}.
+     * 
+     * @param instant  the partial instant to query
+     * @param values  the values to use
+     * @return the minimum value for this field, in the units of the field
+     */
+    public int getMinimumValue(PartialInstant instant, int[] values) {
+        return getMinimumValue(instant);
+    }
+
     /**
      * Get the maximum allowable value for this field.
      * 
@@ -569,7 +659,7 @@ public int getMaximumValue(long instant) {
     }
 
     /**
-     * Get the maximum value for this field evaluated at the specified time.
+     * Get the maximum value for this field evaluated at the specified instant.
      * <p>
      * This implementation returns the same as {@link #getMaximumValue()}.
      * 
@@ -580,6 +670,20 @@ public int getMaximumValue(PartialInstant instant) {
         return getMaximumValue();
     }
 
+    /**
+     * Get the maximum value for this field using the partial instant and
+     * the specified values.
+     * <p>
+     * This implementation returns the same as {@link #getMaximumValue(PartialInstant)}.
+     * 
+     * @param instant  the partial instant to query
+     * @param values  the values to use
+     * @return the maximum value for this field, in the units of the field
+     */
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        return getMaximumValue(instant);
+    }
+
     /**
      * Get the maximum text value for this field. The default implementation
      * returns the equivalent of Integer.toString(getMaximumValue()).length().
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index a95a935e7..422fcdcef 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -169,6 +169,10 @@ public long add(long instant, long value) {
         return iField.add(instant, value);
     }
 
+    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        return iField.add(instant, fieldIndex, values, valueToAdd);
+    }
+
     public long addWrapped(long instant, int value) {
         return iField.addWrapped(instant, value);
     }
@@ -237,6 +241,10 @@ public int getMinimumValue(PartialInstant instant) {
         return iField.getMinimumValue(instant);
     }
 
+    public int getMinimumValue(PartialInstant instant, int[] values) {
+        return iField.getMinimumValue(instant, values);
+    }
+
     public int getMaximumValue() {
         return iField.getMaximumValue();
     }
@@ -249,6 +257,10 @@ public int getMaximumValue(PartialInstant instant) {
         return iField.getMaximumValue(instant);
     }
 
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        return iField.getMaximumValue(instant, values);
+    }
+
     public int getMaximumTextLength(Locale locale) {
         return iField.getMaximumTextLength(locale);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index e3f7b250e..a209e3e4b 100644
--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -162,6 +162,15 @@ public int getMinimumValue(PartialInstant instant) {
         return 1;
     }
 
+    /**
+     * Always returns 1.
+     * 
+     * @return the minimum value of 1
+     */
+    public int getMinimumValue(PartialInstant instant, int[] values) {
+        return 1;
+    }
+
     /**
      * Get the maximum value for the field, which is one more than the wrapped
      * field's maximum value.
@@ -192,6 +201,16 @@ public int getMaximumValue(PartialInstant instant) {
         return getWrappedField().getMaximumValue(instant) + 1;
     }
 
+    /**
+     * Get the maximum value for the field, which is one more than the wrapped
+     * field's maximum value.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        return getWrappedField().getMaximumValue(instant, values) + 1;
+    }
+
     public long roundFloor(long instant) {
         return getWrappedField().roundFloor(instant);
     }
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index a7477cf55..5cb6f6d63 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -202,6 +202,15 @@ public long add(long instant, long value) {
         return getDurationField().add(instant, value);
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
@@ -347,6 +356,15 @@ public int getMinimumValue(PartialInstant instant) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue(PartialInstant instant, int[] values) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
@@ -374,6 +392,15 @@ public int getMaximumValue(PartialInstant instant) {
         throw unsupported();
     }
 
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue(PartialInstant instant, int[] values) {
+        throw unsupported();
+    }
+
     /**
      * Always throws UnsupportedOperationException
      *
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index e1bf571b1..db04a222f 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -468,31 +468,36 @@ public int get() {
         }
 
         //-----------------------------------------------------------------------
-// TODO
-//        /**
-//         * Adds to this field in a copy of this TimeOfDay.
-//         * <p>
-//         * The TimeOnly attached to this property is unchanged by this call.
-//        * Instead, a new instance is returned.
-//         * 
-//         * @param value  the value to add to the field in the copy
-//         * @return a copy of the TimeOnly with the field value changed
-//         * @throws IllegalArgumentException if the value isn't valid
-//         */
-//        public TimeOfDay addToCopy(int value) {
-//            int[] newValues = getField().add(getInstant(), value);
-//            return new TimeOfDay(getInstant(), newValues);
-//        }
-//
+        /**
+         * Adds to the value of this field in a copy of this TimeOfDay.
+         * <p>
+         * The value will be added to this field. If the value is too large to be
+         * added solely to this field then it will affect larger fields.
+         * Smaller fields are unaffected.
+         * <p>
+         * If the result would be too large, beyond 23:59:59:999, then an
+         * IllegalArgumentException is thrown.
+         * <p>
+         * The TimeOnly attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the TimeOnly with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public TimeOfDay addCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);
+            return new TimeOfDay(iInstant, newValues);
+        }
+
         /**
          * Adds to the value of this field in a copy of this TimeOfDay wrapping
          * within this field if the maximum value is reached.
          * <p>
          * The value will be added to this field. If the value is too large to be
-         * added solely to this field then it wraps. Larger fields are always
-         * unaffected. Smaller fields should be unaffected, except where the
-         * result would be an invalid value for a smaller field. In this case the
-         * smaller field is adjusted to be in range.
+         * added solely to this field then it wraps within this field.
+         * Other fields are unaffected.
          * <p>
          * For example,
          * <code>12:59:37</code> addInField one minute returns <code>12:00:37</code>.
diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
index 6515d4a99..03662a379 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -833,36 +833,62 @@ public void testPropertyGetMaxMinValuesHour() {
         assertEquals(23, test.hourOfDay().getMaximumValueOverall());
     }
 
+    public void testPropertyAddHour() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay copy = test.hourOfDay().addCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 19, 20, 30, 40);
+        
+        copy = test.hourOfDay().addCopy(0);
+        check(copy, 10, 20, 30, 40);
+        
+        copy = test.hourOfDay().addCopy(13);
+        check(copy, 23, 20, 30, 40);
+        
+        try {
+            test.hourOfDay().addCopy(14);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+        
+        copy = test.hourOfDay().addCopy(-10);
+        check(copy, 0, 20, 30, 40);
+        
+        try {
+            test.hourOfDay().addCopy(-11);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+    }
+
     public void testPropertyAddInFieldHour() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);
-        assertEquals(19, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
-        updated = updated.hourOfDay().addInFieldCopy(9);
-        assertEquals(4, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
+        TimeOfDay copy = test.hourOfDay().addInFieldCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 19, 20, 30, 40);
+        
+        copy = test.hourOfDay().addInFieldCopy(0);
+        check(copy, 10, 20, 30, 40);
+        
+        copy = test.hourOfDay().addInFieldCopy(18);
+        check(copy, 4, 20, 30, 40);
+        
+        copy = test.hourOfDay().addInFieldCopy(-15);
+        check(copy, 19, 20, 30, 40);
     }
 
     public void testPropertySetHour() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.hourOfDay().setCopy(12);
-        assertEquals(12, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.hourOfDay().setCopy(12);
+        check(test, 10, 20, 30, 40);
+        check(copy, 12, 20, 30, 40);
     }
 
     public void testPropertySetTextHour() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.hourOfDay().setCopy("12");
-        assertEquals(12, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.hourOfDay().setCopy("12");
+        check(test, 10, 20, 30, 40);
+        check(copy, 12, 20, 30, 40);
     }
 
     public void testPropertyCompareToHour() {
@@ -914,36 +940,77 @@ public void testPropertyGetMaxMinValuesMinute() {
         assertEquals(59, test.minuteOfHour().getMaximumValueOverall());
     }
 
+    public void testPropertyAddMinute() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay copy = test.minuteOfHour().addCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 29, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(39);
+        check(copy, 10, 59, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(40);
+        check(copy, 11, 0, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(1 * 60 + 45);
+        check(copy, 12, 5, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(13 * 60 + 39);
+        check(copy, 23, 59, 30, 40);
+        
+        try {
+            test.minuteOfHour().addCopy(13 * 60 + 40);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(-9);
+        check(copy, 10, 11, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(-19);
+        check(copy, 10, 1, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(-20);
+        check(copy, 10, 0, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(-21);
+        check(copy, 9, 59, 30, 40);
+        
+        copy = test.minuteOfHour().addCopy(-(10 * 60 + 20));
+        check(copy, 0, 0, 30, 40);
+        
+        try {
+            test.minuteOfHour().addCopy(-(10 * 60 + 21));
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+    }
+
     public void testPropertyAddInFieldMinute() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay updated = test.minuteOfHour().addInFieldCopy(9);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(29, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
-        updated = updated.minuteOfHour().addInFieldCopy(49);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(18, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
+        TimeOfDay copy = test.minuteOfHour().addInFieldCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 29, 30, 40);
+        
+        copy = test.minuteOfHour().addInFieldCopy(49);
+        check(copy, 10, 9, 30, 40);
+        
+        copy = test.minuteOfHour().addInFieldCopy(-47);
+        check(copy, 10, 33, 30, 40);
     }
 
     public void testPropertySetMinute() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.minuteOfHour().setCopy(12);
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(12, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.minuteOfHour().setCopy(12);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 12, 30, 40);
     }
 
     public void testPropertySetTextMinute() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.minuteOfHour().setCopy("12");
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(12, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.minuteOfHour().setCopy("12");
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 12, 30, 40);
     }
 
     public void testPropertyCompareToMinute() {
@@ -995,36 +1062,74 @@ public void testPropertyGetMaxMinValuesSecond() {
         assertEquals(59, test.secondOfMinute().getMaximumValueOverall());
     }
 
+    public void testPropertyAddSecond() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay copy = test.secondOfMinute().addCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 39, 40);
+        
+        copy = test.secondOfMinute().addCopy(29);
+        check(copy, 10, 20, 59, 40);
+        
+        copy = test.secondOfMinute().addCopy(30);
+        check(copy, 10, 21, 0, 40);
+        
+        copy = test.secondOfMinute().addCopy(39 * 60 + 29);
+        check(copy, 10, 59, 59, 40);
+        
+        copy = test.secondOfMinute().addCopy(39 * 60 + 30);
+        check(copy, 11, 0, 0, 40);
+        
+        try {
+            test.secondOfMinute().addCopy(13 * 60 * 60 + 39 * 60 + 30);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+        
+        copy = test.secondOfMinute().addCopy(-9);
+        check(copy, 10, 20, 21, 40);
+        
+        copy = test.secondOfMinute().addCopy(-30);
+        check(copy, 10, 20, 0, 40);
+        
+        copy = test.secondOfMinute().addCopy(-31);
+        check(copy, 10, 19, 59, 40);
+        
+        copy = test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 30));
+        check(copy, 0, 0, 0, 40);
+        
+        try {
+            test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 31));
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+    }
+
     public void testPropertyAddInFieldSecond() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay updated = test.secondOfMinute().addInFieldCopy(9);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(39, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
-        updated = updated.secondOfMinute().addInFieldCopy(49);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(28, updated.getSecondOfMinute());
-        assertEquals(40, updated.getMillisOfSecond());
+        TimeOfDay copy = test.secondOfMinute().addInFieldCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 39, 40);
+        
+        copy = test.secondOfMinute().addInFieldCopy(49);
+        check(copy, 10, 20, 19, 40);
+        
+        copy = test.secondOfMinute().addInFieldCopy(-47);
+        check(copy, 10, 20, 43, 40);
     }
 
     public void testPropertySetSecond() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.secondOfMinute().setCopy(12);
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(12, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.secondOfMinute().setCopy(12);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 12, 40);
     }
 
     public void testPropertySetTextSecond() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.secondOfMinute().setCopy("12");
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(12, set.getSecondOfMinute());
-        assertEquals(40, set.getMillisOfSecond());
+        TimeOfDay copy = test.secondOfMinute().setCopy("12");
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 12, 40);
     }
 
     public void testPropertyCompareToSecond() {
@@ -1076,36 +1181,71 @@ public void testPropertyGetMaxMinValuesMilli() {
         assertEquals(999, test.millisOfSecond().getMaximumValueOverall());
     }
 
+    public void testPropertyAddMilli() {
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        TimeOfDay copy = test.millisOfSecond().addCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 30, 49);
+        
+        copy = test.millisOfSecond().addCopy(959);
+        check(copy, 10, 20, 30, 999);
+        
+        copy = test.millisOfSecond().addCopy(960);
+        check(copy, 10, 20, 31, 0);
+        
+        copy = test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);
+        check(copy, 23, 59, 59, 999);
+        
+        try {
+            test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+        
+        copy = test.millisOfSecond().addCopy(-9);
+        check(copy, 10, 20, 30, 31);
+        
+        copy = test.millisOfSecond().addCopy(-40);
+        check(copy, 10, 20, 30, 0);
+        
+        copy = test.millisOfSecond().addCopy(-41);
+        check(copy, 10, 20, 29, 999);
+        
+        copy = test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));
+        check(copy, 0, 0, 0, 0);
+        
+        try {
+            test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20, 30, 40);
+    }
+
     public void testPropertyAddInFieldMilli() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay updated = test.millisOfSecond().addInFieldCopy(9);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(49, updated.getMillisOfSecond());
-        updated = updated.millisOfSecond().addInFieldCopy(990);
-        assertEquals(10, updated.getHourOfDay());
-        assertEquals(20, updated.getMinuteOfHour());
-        assertEquals(30, updated.getSecondOfMinute());
-        assertEquals(39, updated.getMillisOfSecond());
+        TimeOfDay copy = test.millisOfSecond().addInFieldCopy(9);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 30, 49);
+        
+        copy = test.millisOfSecond().addInFieldCopy(995);
+        check(copy, 10, 20, 30, 35);
+        
+        copy = test.millisOfSecond().addInFieldCopy(-47);
+        check(copy, 10, 20, 30, 993);
     }
 
     public void testPropertySetMilli() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.millisOfSecond().setCopy(12);
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(12, set.getMillisOfSecond());
+        TimeOfDay copy = test.millisOfSecond().setCopy(12);
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 30, 12);
     }
 
     public void testPropertySetTextMilli() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay set = test.millisOfSecond().setCopy("12");
-        assertEquals(10, set.getHourOfDay());
-        assertEquals(20, set.getMinuteOfHour());
-        assertEquals(30, set.getSecondOfMinute());
-        assertEquals(12, set.getMillisOfSecond());
+        TimeOfDay copy = test.millisOfSecond().setCopy("12");
+        check(test, 10, 20, 30, 40);
+        check(copy, 10, 20, 30, 12);
     }
 
     public void testPropertyCompareToMilli() {
@@ -1130,4 +1270,11 @@ public void testPropertyCompareToMilli() {
         } catch (IllegalArgumentException ex) {}
     }
 
+    //-----------------------------------------------------------------------
+    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {
+        assertEquals(hour, test.getHourOfDay());
+        assertEquals(min, test.getMinuteOfHour());
+        assertEquals(sec, test.getSecondOfMinute());
+        assertEquals(milli, test.getMillisOfSecond());
+    }
 }

From 8aa06fb6af323a1e6ae5c03b29de6c69aa1e8def Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 21:32:42 +0000
Subject: [PATCH 0080/1934] Javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@230 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/partial/TimeOfDay.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index db04a222f..2260e5c73 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -478,11 +478,11 @@ public int get() {
          * If the result would be too large, beyond 23:59:59:999, then an
          * IllegalArgumentException is thrown.
          * <p>
-         * The TimeOnly attached to this property is unchanged by this call.
+         * The TimeOfDay attached to this property is unchanged by this call.
          * Instead, a new instance is returned.
          * 
          * @param valueToAdd  the value to add to the field in the copy
-         * @return a copy of the TimeOnly with the field value changed
+         * @return a copy of the TimeOfDay with the field value changed
          * @throws IllegalArgumentException if the value isn't valid
          */
         public TimeOfDay addCopy(int valueToAdd) {

From 7519034bdc4aceca95413ea3ac6186bb2bc2a46d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 23:29:29 +0000
Subject: [PATCH 0081/1934] Support setting month and dayOfWeek from numbers

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@231 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/GJLocaleSymbols.java  | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
index cea800537..e9be4f66f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -196,6 +196,15 @@ public int monthOfYearTextToValue(String text) {
                 return i;
             }
         }
+        try {
+            int month = Integer.parseInt(text);
+            if (month < 1 || month > 12) {
+                throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
+            }
+            return month;
+        } catch (Exception ex) {
+            // ignore
+        }
         throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
     }
 
@@ -228,6 +237,15 @@ public int dayOfWeekTextToValue(String text) {
                 return i;
             }
         }
+        try {
+            int day = Integer.parseInt(text);
+            if (day < 1 || day > 7) {
+                throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);
+            }
+            return day;
+        } catch (Exception ex) {
+            // ignore
+        }
         throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);
     }
 

From 655277bd2e7d783ce98fe22126ef45109e319770 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 23:30:33 +0000
Subject: [PATCH 0082/1934] Adjust smaller fields after a set/add

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@232 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/field/BaseDateTimeField.java    | 27 +++++++++++++++----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index d14071197..163c2c54a 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -278,6 +278,9 @@ public long add(long instant, long value) {
      * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
      */
     public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+        if (valueToAdd == 0) {
+            return values;
+        }
         // there are more efficient algorithms than this (especially for time only fields)
         // trouble is when dealing with days and months, so we use this technique of
         // adding/removing one from the larger field at a time
@@ -288,7 +291,7 @@ public long add(long instant, long value) {
             long proposed = values[fieldIndex] + valueToAdd;
             if (proposed <= max) {
                 values[fieldIndex] = (int) proposed;
-                return values;
+                break;
             }
             if (nextField == null) {
                 if (fieldIndex == 0) {
@@ -308,7 +311,7 @@ public long add(long instant, long value) {
             long proposed = values[fieldIndex] + valueToAdd;
             if (proposed >= min) {
                 values[fieldIndex] = (int) proposed;
-                return values;
+                break;
             }
             if (nextField == null) {
                 if (fieldIndex == 0) {
@@ -323,7 +326,8 @@ public long add(long instant, long value) {
             values = nextField.add(instant, fieldIndex - 1, values, -1);
             values[fieldIndex] = getMaximumValue(instant, values);
         }
-        return values;
+        
+        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields
     }
 
     /**
@@ -388,7 +392,7 @@ public long addWrapped(long instant, int value) {
         int current = values[fieldIndex];
         int wrapped = FieldUtils.getWrappedValue
             (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
-        return set(instant, fieldIndex, values, wrapped);
+        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields
     }
 
     //-----------------------------------------------------------------------
@@ -475,8 +479,21 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
-        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant));
+        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));
         values[fieldIndex] = newValue;
+        
+        // may need to adjust smaller fields
+        if (fieldIndex < instant.getFieldSize()) {
+            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {
+                DateTimeField field = instant.getField(i);
+                if (values[i] > field.getMaximumValue(instant, values)) {
+                    values[i] = field.getMaximumValue(instant, values);
+                }
+                if (values[i] < field.getMinimumValue(instant, values)) {
+                    values[i] = field.getMinimumValue(instant, values);
+                }
+            }
+        }
         return values;
     }
 

From 4ff49b3de99f36b4fabf9117fa2939eb5c5d4a6c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 23:31:23 +0000
Subject: [PATCH 0083/1934] Add YearMonthDay

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@233 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/partial/YearMonthDay.java   |  479 ++++++++
 .../test/org/joda/time/partial/TestAll.java   |    1 +
 .../joda/time/partial/TestYearMonthDay.java   | 1008 +++++++++++++++++
 3 files changed, 1488 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
 create mode 100644 JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java

diff --git a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
new file mode 100644
index 000000000..46370d663
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
@@ -0,0 +1,479 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeField;
+
+/**
+ * YearMonthDay is an immutable partial instant supporting the year, monthOfYear
+ * and dayOfMonth fields.
+ * <p>
+ * Calculations on YearMonthDay are performed using a {@link Chronology}.
+ * This chronology is set to be in the UTC time zone for all calculations.
+ * <p>
+ * Each individual field can be queried in two ways:
+ * <ul>
+ * <li><code>getMonthOfYear()</code>
+ * <li><code>monthOfYear().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>numeric value - <code>monthOfYear().get()</code>
+ * <li>text value - <code>monthOfYear().getAsText()</code>
+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>
+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>
+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>
+ * <li>set - <code>monthOfYear().setCopy()</code>
+ * </ul>
+ * <p>
+ * YearMonthDay is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class YearMonthDay extends AbstractPartialInstant implements PartialInstant, Serializable {
+
+    /** Serialization version */
+    private static final long serialVersionUID = 797544782896179L;
+
+    /** The index of the year field in the field array */
+    public static final int YEAR = 0;
+    /** The index of the monthOfYear field in the field array */
+    public static final int MONTH_OF_YEAR = 1;
+    /** The index of the dayOfMonth field in the field array */
+    public static final int DAY_OF_MONTH = 2;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a YearMonthDay with the current time, using ISOChronology in
+     * the default zone to extract the fields.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     */
+    public YearMonthDay() {
+        super();
+    }
+
+    /**
+     * Constructs a YearMonthDay with the current time, using the specified chronology
+     * and zone to extract the fields.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public YearMonthDay(Chronology chronology) {
+        super(chronology);
+    }
+
+    /**
+     * Constructs a YearMonthDay extracting the partial fields from the specified
+     * milliseconds using the ISOChronology in the default zone.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public YearMonthDay(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a YearMonthDay extracting the partial fields from the specified
+     * milliseconds using the chronology provided.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public YearMonthDay(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs a YearMonthDay from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, null means now
+     * @throws IllegalArgumentException if the date is null
+     */
+    public YearMonthDay(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a YearMonthDay from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the datetime object, null means now
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the date is null
+     */
+    public YearMonthDay(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs a YearMonthDay with specified time field values
+     * using <code>ISOChronology</code> in the default zone.
+     * <p>
+     * The constructor uses the no time zone initialising the fields as provided.
+     * Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     */
+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {
+        this(year, monthOfYear, dayOfMonth, null);
+    }
+
+    /**
+     * Constructs a YearMonthDay with specified time field values.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     */
+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {
+        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);
+    }
+
+    /**
+     * Constructs a YearMonthDay with specified fields, values and chronology.
+     *
+     * @param partial  the partial to base this new instance on
+     * @param values  the new set of values
+     */
+    YearMonthDay(YearMonthDay partial, int[] values) {
+        super();
+        iChronology = partial.iChronology;
+        iValues = values;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Initialize the array of fields.
+     * 
+     * @param chrono  the chronology to use
+     */
+    protected DateTimeField[] initFields(Chronology chrono) {
+        return new DateTimeField[] {
+            chrono.year(),
+            chrono.monthOfYear(),
+            chrono.dayOfMonth(),
+        };
+    }
+
+    /**
+     * Initialize the array of values.
+     * 
+     * @param instant  the instant to use
+     * @param chrono  the chronology to use
+     */
+    protected int[] initValues(long instant, Chronology chrono) {
+        return new int[] {
+            chrono.year().get(instant),
+            chrono.monthOfYear().get(instant),
+            chrono.dayOfMonth().get(instant),
+        };
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the year field value.
+     *
+     * @return the year
+     */
+    public int getYear() {
+        return getValue(YEAR);
+    }
+
+    /**
+     * Get the month of year field value.
+     *
+     * @return the month of year
+     */
+    public int getMonthOfYear() {
+        return getValue(MONTH_OF_YEAR);
+    }
+
+    /**
+     * Get the day of month field value.
+     *
+     * @return the day of month
+     */
+    public int getDayOfMonth() {
+        return getValue(DAY_OF_MONTH);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the year field property
+     * 
+     * @return the year property
+     */
+    public Property year() {
+        return new Property(this, YEAR);
+    }
+
+    /**
+     * Get the month of year field property
+     * 
+     * @return the month of year property
+     */
+    public Property monthOfYear() {
+        return new Property(this, MONTH_OF_YEAR);
+    }
+
+    /**
+     * Get the day of month field property
+     * 
+     * @return the day of month property
+     */
+    public Property dayOfMonth() {
+        return new Property(this, DAY_OF_MONTH);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The property class for YearMonthDay.
+     */
+    public static class Property extends AbstractPartialFieldProperty {
+
+        /** The instant */
+        private final YearMonthDay iInstant;
+        /** The field index */
+        private final int iFieldIndex;
+
+        /**
+         * Constructs a property.
+         * 
+         * @param instant  the partial instant
+         * @param field  the field
+         * @param fieldIndex  the index in the instant
+         */
+        Property(YearMonthDay instant, int fieldIndex) {
+            super();
+            iInstant = instant;
+            iFieldIndex = fieldIndex;
+        }
+
+        /**
+         * Gets the field that this property uses.
+         * 
+         * @return the field
+         */
+        public DateTimeField getField() {
+            return iInstant.getField(iFieldIndex);
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public PartialInstant getPartialInstant() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public YearMonthDay getYearMonthDay() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the value of the field that the partial instant is set to.
+         * 
+         * @return the field value
+         */
+        public int get() {
+            return iInstant.getValue(iFieldIndex);
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Adds to the value of this field in a copy of this YearMonthDay.
+         * <p>
+         * The value will be added to this field. If the value is too large to be
+         * added solely to this field then it will affect larger fields.
+         * Smaller fields are unaffected.
+         * <p>
+         * If the result would be too large, beyond the maximum year, then an
+         * IllegalArgumentException is thrown.
+         * <p>
+         * The YearMonthDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the YearMonthDay with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public YearMonthDay addCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);
+            return new YearMonthDay(iInstant, newValues);
+        }
+
+        /**
+         * Adds to the value of this field in a copy of this YearMonthDay wrapping
+         * within this field if the maximum value is reached.
+         * <p>
+         * The value will be added to this field. If the value is too large to be
+         * added solely to this field then it wraps within this field.
+         * Other fields are unaffected.
+         * <p>
+         * For example,
+         * <code>2004-12-20</code> addInField one month returns <code>2004-01-20</code>.
+         * <p>
+         * The YearMonthDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the YearMonthDay with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public YearMonthDay addInFieldCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);
+            return new YearMonthDay(iInstant, newValues);
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Sets this field in a copy of the YearMonthDay.
+         * <p>
+         * The YearMonthDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param value  the value to set the field in the copy to
+         * @return a copy of the YearMonthDay with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public YearMonthDay setCopy(int value) {
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, iFieldIndex, newValues, value);
+            return new YearMonthDay(iInstant, newValues);
+        }
+
+        /**
+         * Sets this field in a copy of the YearMonthDay to a parsed text value.
+         * <p>
+         * The YearMonthDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param text  the text value to set
+         * @param locale  optional locale to use for selecting a text symbol
+         * @return a copy of the YearMonthDay with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public YearMonthDay setCopy(String text, Locale locale) {
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, iFieldIndex, newValues, text, locale);
+            return new YearMonthDay(iInstant, newValues);
+        }
+
+        /**
+         * Sets this field in a copy of the YearMonthDay to a parsed text value.
+         * <p>
+         * The YearMonthDay attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param text  the text value to set
+         * @return a copy of the YearMonthDay with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public YearMonthDay setCopy(String text) {
+            return setCopy(text, null);
+        }
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/partial/TestAll.java b/JodaTime/src/test/org/joda/time/partial/TestAll.java
index e43b40112..23790079d 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestAll.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestAll.java
@@ -73,6 +73,7 @@ public TestAll(String testName) {
     public static Test suite() {
         TestSuite suite = new TestSuite();
         suite.addTest(TestTimeOfDay.suite());
+        suite.addTest(TestYearMonthDay.suite());
         return suite;
     }
 
diff --git a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
new file mode 100644
index 000000000..392b4ea0e
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
@@ -0,0 +1,1008 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.MockZeroNullIntegerConverter;
+
+/**
+ * This class is a Junit unit test for YearMonthDay.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestYearMonthDay extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestYearMonthDay.class);
+    }
+
+    public TestYearMonthDay(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        DateTimeZone.setDefault(DateTimeZone.UTC);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        YearMonthDay test = new YearMonthDay();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Chronology)
+     */
+    public void testConstructor_Chronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Chronology=null)
+     */
+    public void testConstructor_nullChronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay((Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long1() throws Throwable {
+        YearMonthDay test = new YearMonthDay(TEST_TIME1);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long2() throws Throwable {
+        YearMonthDay test = new YearMonthDay(TEST_TIME2);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1971, test.getYear());
+        assertEquals(5, test.getMonthOfYear());
+        assertEquals(7, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long1_Chronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(TEST_TIME1, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long2_Chronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(TEST_TIME2, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1971, test.getYear());
+        assertEquals(5, test.getMonthOfYear());
+        assertEquals(7, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (long, Chronology=null)
+     */
+    public void testConstructor_long_nullChronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        YearMonthDay test = new YearMonthDay(date);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_nullObject() throws Throwable {
+        YearMonthDay test = new YearMonthDay(null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            YearMonthDay test = new YearMonthDay(new Integer(0));
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(1970, test.getYear());
+            assertEquals(1, test.getMonthOfYear());
+            assertEquals(1, test.getDayOfMonth());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_Object_Chronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        YearMonthDay test = new YearMonthDay(date, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology)
+     */
+    public void testConstructor_nullObject_Chronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay((Object) null, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object, Chronology=null)
+     */
+    public void testConstructor_Object_nullChronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        YearMonthDay test = new YearMonthDay(date, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(4, test.getMonthOfYear());
+        assertEquals(6, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology=null)
+     */
+    public void testConstructor_nullObject_nullChronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay((Object) null, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject_Chronology() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            YearMonthDay test = new YearMonthDay(new Integer(0), GregorianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(1970, test.getYear());
+            assertEquals(1, test.getMonthOfYear());
+            assertEquals(1, test.getDayOfMonth());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (int, int, int)
+     */
+    public void testConstructor_int_int_int() throws Throwable {
+        YearMonthDay test = new YearMonthDay(1970, 6, 9);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        try {
+            new YearMonthDay(Integer.MIN_VALUE, 6, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(Integer.MAX_VALUE, 6, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 0, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 13, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 6, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 6, 31);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new YearMonthDay(1970, 7, 31);
+        try {
+            new YearMonthDay(1970, 7, 32);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_int_Chronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(1970, 6, 9, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        try {
+            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 0, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 13, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 6, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new YearMonthDay(1970, 6, 31, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new YearMonthDay(1970, 7, 31, GregorianChronology.getInstance());
+        try {
+            new YearMonthDay(1970, 7, 32, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_int_nullChronology() throws Throwable {
+        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGet() {
+        YearMonthDay test = new YearMonthDay();
+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));
+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));
+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));
+        try {
+            test.get(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance().hourOfDay());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.get(ISOChronology.getInstance(PARIS).year());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation
+//        try {
+//            test.get(GregorianChronology.getInstance().year());
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetFieldSize() {
+        YearMonthDay test = new YearMonthDay();
+        assertEquals(3, test.getFieldSize());
+    }
+
+    public void testGetField() {
+        YearMonthDay test = new YearMonthDay();
+        assertSame(ISOChronology.getInstance().year(), test.getField(0));
+        assertSame(ISOChronology.getInstance().monthOfYear(), test.getField(1));
+        assertSame(ISOChronology.getInstance().dayOfMonth(), test.getField(2));
+        try {
+            test.getField(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getField(3);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetFields() {
+        YearMonthDay test = new YearMonthDay();
+        DateTimeField[] fields = test.getFields();
+        assertSame(ISOChronology.getInstance().year(), fields[0]);
+        assertSame(ISOChronology.getInstance().monthOfYear(), fields[1]);
+        assertSame(ISOChronology.getInstance().dayOfMonth(), fields[2]);
+    }
+
+    public void testGetValue() {
+        YearMonthDay test = new YearMonthDay();
+        assertEquals(1970, test.getValue(0));
+        assertEquals(6, test.getValue(1));
+        assertEquals(9, test.getValue(2));
+        try {
+            test.getValue(-1);
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.getValue(3);
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetValues() {
+        YearMonthDay test = new YearMonthDay();
+        int[] values = test.getValues();
+        assertEquals(1970, values[0]);
+        assertEquals(6, values[1]);
+        assertEquals(9, values[2]);
+    }
+
+    public void testIsSupported() {
+        YearMonthDay test = new YearMonthDay();
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().year()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().monthOfYear()));
+        assertEquals(true, test.isSupported(ISOChronology.getInstance().dayOfMonth()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).year()));
+    }
+
+    public void testEqualsHashCode() {
+        YearMonthDay test1 = new YearMonthDay(1970, 6, 9);
+        YearMonthDay test2 = new YearMonthDay(1970, 6, 9);
+        assertEquals(true, test1.equals(test2));
+        assertEquals(true, test2.equals(test1));
+        assertEquals(true, test1.equals(test1));
+        assertEquals(true, test2.equals(test2));
+        assertEquals(true, test1.hashCode() == test2.hashCode());
+        assertEquals(true, test1.hashCode() == test1.hashCode());
+        assertEquals(true, test2.hashCode() == test2.hashCode());
+        
+        YearMonthDay test3 = new YearMonthDay(1971, 6, 9);
+        assertEquals(false, test1.equals(test3));
+        assertEquals(false, test2.equals(test3));
+        assertEquals(false, test3.equals(test1));
+        assertEquals(false, test3.equals(test2));
+        assertEquals(false, test1.hashCode() == test3.hashCode());
+        assertEquals(false, test2.hashCode() == test3.hashCode());
+        
+        assertEquals(false, test1.equals("Hello"));
+        assertEquals(true, test1.equals(new MockInstant()));
+        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));
+    }
+    
+    class MockInstant extends MockPartialInstant {
+        public DateTimeField[] getFields() {
+            return new DateTimeField[] {
+                ISOChronology.getInstance().year(),
+                ISOChronology.getInstance().monthOfYear(),
+                ISOChronology.getInstance().dayOfMonth(),
+            };
+        }
+        public int[] getValues() {
+            return new int[] {1970, 6, 9};
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    public void testResolve_long() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        DateTime dt = new DateTime(TEST_TIME1);
+        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());
+        
+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));
+        check(test, 1972, 6, 9);
+        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());
+        assertEquals("1972-06-09T12:24:00.000Z", result.toString());
+    }
+
+    public void testResolveDateTime_RI() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        DateTime dt = new DateTime(TEST_TIME1);
+        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());
+        
+        DateTime result = test.resolveDateTime(dt);
+        check(test, 1972, 6, 9);
+        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());
+        assertEquals("1972-06-09T12:24:00.000Z", result.toString());
+    }
+
+    public void testResolveDateTime_nullRI() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);
+        
+        DateTime result = test.resolveDateTime(null);
+        check(test, 1972, 6, 9);
+        assertEquals("1972-06-09T12:24:00.000Z", result.toString());
+    }
+
+    public void testResolveInto_RWI() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        MutableDateTime mdt = new MutableDateTime(TEST_TIME1);
+        assertEquals("1970-04-06T12:24:00.000Z", mdt.toString());
+        
+        test.resolveInto(mdt);
+        check(test, 1972, 6, 9);
+        assertEquals("1972-06-09T12:24:00.000Z", mdt.toString());
+    }
+
+    public void testResolveInto_nullRWI() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        
+        try {
+            test.resolveInto(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSerialization() throws Exception {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject(test);
+        byte[] bytes = baos.toByteArray();
+        oos.close();
+        
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        ObjectInputStream ois = new ObjectInputStream(bais);
+        YearMonthDay result = (YearMonthDay) ois.readObject();
+        ois.close();
+        
+        assertEquals(test, result);
+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));
+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));
+        assertEquals(test.getChronology(), result.getChronology());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        // TODO
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertSame(test.getChronology().year(), test.year().getField());
+        assertEquals("year", test.year().getName());
+        assertEquals("Property[year]", test.year().toString());
+        assertSame(test, test.year().getPartialInstant());
+        assertSame(test, test.year().getYearMonthDay());
+        assertEquals(1972, test.year().get());
+        assertEquals("1972", test.year().getAsText());
+        assertEquals("1972", test.year().getAsText(Locale.FRENCH));
+        assertEquals("1972", test.year().getAsShortText());
+        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().years(), test.year().getDurationField());
+        assertEquals(null, test.year().getRangeDurationField());
+        assertEquals(9, test.year().getMaximumTextLength(null));
+        assertEquals(9, test.year().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertEquals(-292275054, test.year().getMinimumValue());
+        assertEquals(-292275054, test.year().getMinimumValueOverall());
+        assertEquals(292277023, test.year().getMaximumValue());
+        assertEquals(292277023, test.year().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.year().addCopy(9);
+        check(test, 1972, 6, 9);
+        check(copy, 1981, 6, 9);
+        
+        copy = test.year().addCopy(0);
+        check(copy, 1972, 6, 9);
+        
+        copy = test.year().addCopy(292277023 - 1972);
+        check(copy, 292277023, 6, 9);
+        
+        try {
+            test.year().addCopy(292277023 - 1972 + 1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 1972, 6, 9);
+        
+        copy = test.year().addCopy(-1972);
+        check(copy, 0, 6, 9);
+        
+        copy = test.year().addCopy(-1973);
+        check(copy, -1, 6, 9);
+        
+        try {
+            test.year().addCopy(-292275054 - 1972 - 1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 1972, 6, 9);
+    }
+
+    public void testPropertyAddInFieldYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.year().addInFieldCopy(9);
+        check(test, 1972, 6, 9);
+        check(copy, 1981, 6, 9);
+        
+        copy = test.year().addInFieldCopy(0);
+        check(copy, 1972, 6, 9);
+        
+        copy = test.year().addInFieldCopy(292277023 - 1972 + 1);
+        check(copy, -292275054, 6, 9);
+        
+        copy = test.year().addInFieldCopy(-292275054 - 1972 - 1);
+        check(copy, 292277023, 6, 9);
+    }
+
+    public void testPropertySetYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.year().setCopy(12);
+        check(test, 1972, 6, 9);
+        check(copy, 12, 6, 9);
+    }
+
+    public void testPropertySetTextYear() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.year().setCopy("12");
+        check(test, 1972, 6, 9);
+        check(copy, 12, 6, 9);
+    }
+
+    public void testPropertyCompareToYear() {
+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);
+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);
+        assertEquals(true, test1.year().compareTo(test2) < 0);
+        assertEquals(true, test2.year().compareTo(test1) > 0);
+        assertEquals(true, test1.year().compareTo(test1) == 0);
+        try {
+            test1.year().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.year().compareTo(dt2) < 0);
+        assertEquals(true, test2.year().compareTo(dt1) > 0);
+        assertEquals(true, test1.year().compareTo(dt1) == 0);
+        try {
+            test1.year().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
+        assertEquals("monthOfYear", test.monthOfYear().getName());
+        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
+        assertSame(test, test.monthOfYear().getPartialInstant());
+        assertSame(test, test.monthOfYear().getYearMonthDay());
+        assertEquals(6, test.monthOfYear().get());
+        assertEquals("June", test.monthOfYear().getAsText());
+        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));
+        assertEquals("Jun", test.monthOfYear().getAsShortText());
+        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());
+        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
+        test = new YearMonthDay(1972, 7, 9);
+        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
+        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));
+    }
+
+    public void testPropertyGetMaxMinValuesMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertEquals(1, test.monthOfYear().getMinimumValue());
+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());
+        assertEquals(12, test.monthOfYear().getMaximumValue());
+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.monthOfYear().addCopy(6);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 12, 9);
+        
+        copy = test.monthOfYear().addCopy(7);
+        check(copy, 1973, 1, 9);
+        
+        copy = test.monthOfYear().addCopy(-5);
+        check(copy, 1972, 1, 9);
+        
+        copy = test.monthOfYear().addCopy(-6);
+        check(copy, 1971, 12, 9);
+        
+        test = new YearMonthDay(1972, 1, 31);
+        copy = test.monthOfYear().addCopy(1);
+        check(copy, 1972, 2, 29);
+        
+        copy = test.monthOfYear().addCopy(2);
+        check(copy, 1972, 3, 31);
+        
+        copy = test.monthOfYear().addCopy(3);
+        check(copy, 1972, 4, 30);
+        
+        test = new YearMonthDay(1971, 1, 31);
+        copy = test.monthOfYear().addCopy(1);
+        check(copy, 1971, 2, 28);
+    }
+
+    public void testPropertyAddInFieldMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.monthOfYear().addInFieldCopy(4);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 10, 9);
+        
+        copy = test.monthOfYear().addInFieldCopy(8);
+        check(copy, 1972, 2, 9);
+        
+        copy = test.monthOfYear().addInFieldCopy(-8);
+        check(copy, 1972, 10, 9);
+        
+        test = new YearMonthDay(1972, 1, 31);
+        copy = test.monthOfYear().addInFieldCopy(1);
+        check(copy, 1972, 2, 29);
+        
+        copy = test.monthOfYear().addInFieldCopy(2);
+        check(copy, 1972, 3, 31);
+        
+        copy = test.monthOfYear().addInFieldCopy(3);
+        check(copy, 1972, 4, 30);
+        
+        test = new YearMonthDay(1971, 1, 31);
+        copy = test.monthOfYear().addInFieldCopy(1);
+        check(copy, 1971, 2, 28);
+    }
+
+    public void testPropertySetMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.monthOfYear().setCopy(12);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 12, 9);
+        
+        test = new YearMonthDay(1972, 1, 31);
+        copy = test.monthOfYear().setCopy(2);
+        check(copy, 1972, 2, 29);
+        
+        try {
+            test.monthOfYear().setCopy(13);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.monthOfYear().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextMonth() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.monthOfYear().setCopy("12");
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 12, 9);
+        
+        copy = test.monthOfYear().setCopy("December");
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 12, 9);
+        
+        copy = test.monthOfYear().setCopy("Dec");
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 12, 9);
+    }
+
+    public void testPropertyCompareToMonth() {
+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);
+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);
+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);
+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);
+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);
+        try {
+            test1.monthOfYear().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);
+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);
+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);
+        try {
+            test1.monthOfYear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
+        assertEquals("dayOfMonth", test.dayOfMonth().getName());
+        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
+        assertSame(test, test.dayOfMonth().getPartialInstant());
+        assertSame(test, test.dayOfMonth().getYearMonthDay());
+        assertEquals(9, test.dayOfMonth().get());
+        assertEquals("9", test.dayOfMonth().getAsText());
+        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));
+        assertEquals("9", test.dayOfMonth().getAsShortText());
+        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());
+        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());
+        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));
+        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertEquals(1, test.dayOfMonth().getMinimumValue());
+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
+        assertEquals(30, test.dayOfMonth().getMaximumValue());
+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
+        test = new YearMonthDay(1972, 7, 9);
+        assertEquals(31, test.dayOfMonth().getMaximumValue());
+        test = new YearMonthDay(1972, 2, 9);
+        assertEquals(29, test.dayOfMonth().getMaximumValue());
+        test = new YearMonthDay(1971, 2, 9);
+        assertEquals(28, test.dayOfMonth().getMaximumValue());
+    }
+
+    public void testPropertyAddDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.dayOfMonth().addCopy(9);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 6, 18);
+        
+        copy = test.dayOfMonth().addCopy(21);
+        check(copy, 1972, 6, 30);
+        
+        copy = test.dayOfMonth().addCopy(22);
+        check(copy, 1972, 7, 1);
+        
+        copy = test.dayOfMonth().addCopy(22 + 30);
+        check(copy, 1972, 7, 31);
+        
+        copy = test.dayOfMonth().addCopy(22 + 31);
+        check(copy, 1972, 8, 1);
+
+        copy = test.dayOfMonth().addCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+        check(copy, 1972, 12, 31);
+        
+        copy = test.dayOfMonth().addCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+        check(copy, 1973, 1, 1);
+        
+        copy = test.dayOfMonth().addCopy(-8);
+        check(copy, 1972, 6, 1);
+        
+        copy = test.dayOfMonth().addCopy(-9);
+        check(copy, 1972, 5, 31);
+        
+        copy = test.dayOfMonth().addCopy(-8 - 31 - 30 - 31 - 29 - 31);
+        check(copy, 1972, 1, 1);
+        
+        copy = test.dayOfMonth().addCopy(-9 - 31 - 30 - 31 - 29 - 31);
+        check(copy, 1971, 12, 31);
+    }
+
+    public void testPropertyAddInFieldDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.dayOfMonth().addInFieldCopy(21);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 6, 30);
+        
+        copy = test.dayOfMonth().addInFieldCopy(22);
+        check(copy, 1972, 6, 1);
+        
+        copy = test.dayOfMonth().addInFieldCopy(-12);
+        check(copy, 1972, 6, 27);
+        
+        test = new YearMonthDay(1972, 7, 9);
+        copy = test.dayOfMonth().addInFieldCopy(21);
+        check(copy, 1972, 7, 30);
+    
+        copy = test.dayOfMonth().addInFieldCopy(22);
+        check(copy, 1972, 7, 31);
+    
+        copy = test.dayOfMonth().addInFieldCopy(23);
+        check(copy, 1972, 7, 1);
+    
+        copy = test.dayOfMonth().addInFieldCopy(-12);
+        check(copy, 1972, 7, 28);
+    }
+
+    public void testPropertySetDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.dayOfMonth().setCopy(12);
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 6, 12);
+        
+        try {
+            test.dayOfMonth().setCopy(31);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.dayOfMonth().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextDay() {
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        YearMonthDay copy = test.dayOfMonth().setCopy("12");
+        check(test, 1972, 6, 9);
+        check(copy, 1972, 6, 12);
+    }
+
+    public void testPropertyCompareToDay() {
+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);
+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);
+        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);
+        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);
+        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);
+        try {
+            test1.dayOfMonth().compareTo((PartialInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);
+        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);
+        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);
+        try {
+            test1.dayOfMonth().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    private void check(YearMonthDay test, int hour, int min, int sec) {
+        assertEquals(hour, test.getYear());
+        assertEquals(min, test.getMonthOfYear());
+        assertEquals(sec, test.getDayOfMonth());
+    }
+}

From 4272ad9b2e1439c190e0eae842afe22ca5134345 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jun 2004 23:32:23 +0000
Subject: [PATCH 0084/1934] Add extra tests for illegal sets

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@234 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/partial/TestTimeOfDay.java  | 36 +++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
index 03662a379..da3e54d6f 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -882,6 +882,15 @@ public void testPropertySetHour() {
         TimeOfDay copy = test.hourOfDay().setCopy(12);
         check(test, 10, 20, 30, 40);
         check(copy, 12, 20, 30, 40);
+        
+        try {
+            test.hourOfDay().setCopy(24);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.hourOfDay().setCopy(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     public void testPropertySetTextHour() {
@@ -1004,6 +1013,15 @@ public void testPropertySetMinute() {
         TimeOfDay copy = test.minuteOfHour().setCopy(12);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 12, 30, 40);
+        
+        try {
+            test.minuteOfHour().setCopy(60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.minuteOfHour().setCopy(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     public void testPropertySetTextMinute() {
@@ -1123,6 +1141,15 @@ public void testPropertySetSecond() {
         TimeOfDay copy = test.secondOfMinute().setCopy(12);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 12, 40);
+        
+        try {
+            test.secondOfMinute().setCopy(60);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.secondOfMinute().setCopy(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     public void testPropertySetTextSecond() {
@@ -1239,6 +1266,15 @@ public void testPropertySetMilli() {
         TimeOfDay copy = test.millisOfSecond().setCopy(12);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 30, 12);
+        
+        try {
+            test.millisOfSecond().setCopy(1000);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.millisOfSecond().setCopy(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
     }
 
     public void testPropertySetTextMilli() {

From 7cff59020619b432c7985dddb62e6511686f6c15 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 27 Jun 2004 05:48:50 +0000
Subject: [PATCH 0085/1934] Simplified number parsing logic.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@235 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/chrono/GJLocaleSymbols.java | 14 ++++++--------
 1 file changed, 6 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
index e9be4f66f..00c1a6cee 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -198,11 +198,10 @@ public int monthOfYearTextToValue(String text) {
         }
         try {
             int month = Integer.parseInt(text);
-            if (month < 1 || month > 12) {
-                throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
+            if (month >= 1 && month <= 12) {
+                return month;
             }
-            return month;
-        } catch (Exception ex) {
+        } catch (NumberFormatException ex) {
             // ignore
         }
         throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
@@ -239,11 +238,10 @@ public int dayOfWeekTextToValue(String text) {
         }
         try {
             int day = Integer.parseInt(text);
-            if (day < 1 || day > 7) {
-                throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);
+            if (day >= 1 && day <= 7) {
+                return day;
             }
-            return day;
-        } catch (Exception ex) {
+        } catch (NumberFormatException ex) {
             // ignore
         }
         throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);

From ff3b9827639c59940312d50919b5c2484b4ee16f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 27 Jun 2004 08:37:59 +0000
Subject: [PATCH 0086/1934] Removed old code to support partials.
 ReadWritableInstant supports rounding.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@236 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDateTime.java  |  23 -
 .../java/org/joda/time/AbstractInstant.java   | 215 +----
 .../org/joda/time/AbstractPartialInstant.java | 460 ----------
 JodaTime/src/java/org/joda/time/DateOnly.java | 508 -----------
 JodaTime/src/java/org/joda/time/DateTime.java |   4 +-
 .../org/joda/time/DateTimeComparator.java     |  25 +-
 JodaTime/src/java/org/joda/time/Instant.java  |  23 +-
 .../java/org/joda/time/MutableDateOnly.java   | 803 -----------------
 .../java/org/joda/time/MutableDateTime.java   |  90 +-
 .../java/org/joda/time/MutableTimeOnly.java   | 835 ------------------
 .../java/org/joda/time/PartialInstant.java    | 178 ----
 .../org/joda/time/ReadWritableInstant.java    |  45 +
 .../java/org/joda/time/ReadableDateTime.java  |  44 +-
 .../java/org/joda/time/ReadableInstant.java   |  32 -
 JodaTime/src/java/org/joda/time/TimeOnly.java | 505 -----------
 .../joda/time/convert/ConverterManager.java   |   2 -
 .../time/convert/PartialInstantConverter.java | 156 ----
 .../time/property/DateOnlyFieldProperty.java  | 298 -------
 .../time/property/TimeOnlyFieldProperty.java  | 298 -------
 19 files changed, 161 insertions(+), 4383 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
 delete mode 100644 JodaTime/src/java/org/joda/time/DateOnly.java
 delete mode 100644 JodaTime/src/java/org/joda/time/MutableDateOnly.java
 delete mode 100644 JodaTime/src/java/org/joda/time/MutableTimeOnly.java
 delete mode 100644 JodaTime/src/java/org/joda/time/PartialInstant.java
 delete mode 100644 JodaTime/src/java/org/joda/time/TimeOnly.java
 delete mode 100644 JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
 delete mode 100644 JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
 delete mode 100644 JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index 78ef93664..1b37ea512 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -345,29 +345,6 @@ public final long getMillis() {
         return iMillis;
     }
 
-    /**
-     * Gets the milliseconds of the datetime instant from the Java epoch
-     * of 1970-01-01T00:00:00Z.
-     * 
-     * @param base ignored
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
-     */
-    public final long getMillis(ReadableInstant base) {
-        return iMillis;
-    }
-
-    /**
-     * Gets the milliseconds of the datetime instant from the Java epoch
-     * of 1970-01-01T00:00:00Z.
-     * 
-     * @param base ignored
-     * @param zone ignored
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
-     */
-    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
-        return iMillis;
-    }
-
     /**
      * Gets the chronology of the datetime.
      * 
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 7d8892b11..a1a1665d9 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -124,7 +124,7 @@ public final int get(DateTimeField field) {
     /**
      * Get this object as an Instant.
      * 
-     * @return an Instant using the same millis, unless partially specified
+     * @return an Instant using the same millis
      */
     public final Instant toInstant() {
         if (this instanceof Instant) {
@@ -133,21 +133,10 @@ public final Instant toInstant() {
         return new Instant(this);
     }
 
-    /**
-     * Get this object as an Instant, using the given base instant to supply
-     * missing field values.
-     * 
-     * @param base source of missing fields
-     * @return a new Instant
-     */
-    public final Instant toInstant(ReadableInstant base) {
-        return new Instant(getMillis(base, null));
-    }
-
     /**
      * Get this object as a DateTime.
      * 
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      */
     public final DateTime toDateTime() {
         if (this instanceof DateTime) {
@@ -160,7 +149,7 @@ public final DateTime toDateTime() {
      * Get this object as a DateTime.
      * 
      * @param zone time zone to apply, or default if null
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      */
     public final DateTime toDateTime(DateTimeZone zone) {
         if (zone == null) {
@@ -176,7 +165,7 @@ public final DateTime toDateTime(DateTimeZone zone) {
      * Get this object as a DateTime.
      * 
      * @param chronology chronology to apply, or ISOChronology if null
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      */
     public final DateTime toDateTime(Chronology chronology) {
         if (chronology == null) {
@@ -188,60 +177,6 @@ public final DateTime toDateTime(Chronology chronology) {
         return new DateTime(this, chronology);
     }
 
-    /**
-     * Convert this object into a DateTime, using the given base instant to
-     * supply missing field values and time zone.
-     * 
-     * @param base source of missing fields
-     * @return a new DateTime
-     */
-    public final DateTime toDateTime(ReadableInstant base) {
-        if (base == null) {
-            return new DateTime(this);
-        }
-        DateTimeZone zone = base.getZone();
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        return new DateTime(getMillis(base), getChronology().withZone(zone));
-    }
-
-    /**
-     * Convert this object into a DateTime, using the given base instant to
-     * supply missing field values.
-     * 
-     * @param base source of missing fields
-     * @param zone  time zone to apply, or default if null
-     * @return a new DateTime
-     */
-    public final DateTime toDateTime(ReadableInstant base, DateTimeZone zone) {
-        if (base == null) {
-            return new DateTime(this, zone);
-        }
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        return new DateTime(getMillis(base, zone), getChronology().withZone(zone));
-    }
-
-    /**
-     * Convert this object into a DateTime, using the given base instant to
-     * supply missing field values.
-     * 
-     * @param base source of missing fields
-     * @param chronology  chronology to apply, or ISOChronology if null
-     * @return a new DateTime
-     */
-    public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {
-        if (base == null) {
-            return new DateTime(this, chronology);
-        }
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        return new DateTime(getMillis(base, chronology.getZone()), chronology);
-    }
-
     /**
      * Get this object as a trusted ISO immutable DateTime. The purpose of
      * this method is to guarantee that an externally received DateTime
@@ -252,7 +187,7 @@ public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {
      * {@link org.joda.time.tz.Provider provider}, then this object is cast to
      * a DateTime and returned. Otherwise, a new trusted DateTime is returned.
      * 
-     * @return a trusted ISO DateTime using the same millis, unless partially specified
+     * @return a trusted ISO DateTime using the same millis
      * @throws IllegalArgumentException if the time zone is not trusted, and
      * no matching trusted time zone can be found.
      */
@@ -280,7 +215,7 @@ public final DateTime toTrustedISODateTime() {
     /**
      * Get this object as a MutableDateTime.
      * 
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      */
     public final MutableDateTime toMutableDateTime() {
         return new MutableDateTime(this);
@@ -290,7 +225,7 @@ public final MutableDateTime toMutableDateTime() {
      * Get this object as a MutableDateTime.
      * 
      * @param zone time zone to apply, or default if null
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      */
     public final MutableDateTime toMutableDateTime(DateTimeZone zone) {
         if (zone == null) {
@@ -303,7 +238,7 @@ public final MutableDateTime toMutableDateTime(DateTimeZone zone) {
      * Get this object as a MutableDateTime.
      * 
      * @param chronology chronology to apply, or ISOChronology if null
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      */
     public final MutableDateTime toMutableDateTime(Chronology chronology) {
         if (chronology == null) {
@@ -312,122 +247,6 @@ public final MutableDateTime toMutableDateTime(Chronology chronology) {
         return new MutableDateTime(this, chronology);
     }
 
-    /**
-     * Convert this object into a MutableDateTime, using the given base instant
-     * to supply missing field values and time zone.
-     * 
-     * @param base source of missing fields
-     * @return a new MutableDateTime
-     */
-    public final MutableDateTime toMutableDateTime(ReadableInstant base) {
-        if (base == null) {
-            return new MutableDateTime(this);
-        }
-        DateTimeZone zone = base.getZone();
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        return new MutableDateTime(getMillis(base), getChronology().withZone(zone));
-    }
-
-    /**
-     * Convert this object into a MutableDateTime, using the given base instant
-     * to supply missing field values.
-     * 
-     * @param base source of missing fields
-     * @param zone  time zone to apply, or default if null
-     * @return a new MutableDateTime
-     */
-    public final MutableDateTime toMutableDateTime(ReadableInstant base, DateTimeZone zone) {
-        if (base == null) {
-            return new MutableDateTime(this, zone);
-        }
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        return new MutableDateTime(getMillis(base, zone), getChronology().withZone(zone));
-    }
-
-    /**
-     * Convert this object into a MutableDateTime, using the given base instant
-     * to supply missing field values.
-     * 
-     * @param base source of missing fields
-     * @param chronology  chronology to apply, or ISOChronology if null
-     * @return a new MutableDateTime
-     */
-    public final MutableDateTime toMutableDateTime(ReadableInstant base, Chronology chronology) {
-        if (base == null) {
-            return new MutableDateTime(this, chronology);
-        }
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        return new MutableDateTime(getMillis(base, chronology.getZone()), chronology);
-    }
-
-    /**
-     * Get this object as a DateOnly.
-     * 
-     * @return a DateOnly using the same millis, unless partially specified
-     */
-    public final DateOnly toDateOnly() {
-        if (this instanceof DateOnly) {
-            return (DateOnly) this;
-        }
-        return new DateOnly(this);
-    }
-
-    /**
-     * Get this object as a DateOnly.
-     * 
-     * @param chronology chronology to apply, or ISOChronology if null
-     * @return a DateOnly using the same millis, unless partially specified
-     */
-    public final DateOnly toDateOnly(Chronology chronology) {
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        if (this instanceof DateOnly) {
-            DateOnly d = (DateOnly) this;
-            if (d.getChronology() == chronology.withUTC()) {
-                return d;
-            }
-        }
-        return new DateOnly(this, chronology);
-    }
-
-    /**
-     * Get this object as a TimeOnly.
-     * 
-     * @return a TimeOnly using the same millis, unless partially specified
-     */
-    public final TimeOnly toTimeOnly() {
-        if (this instanceof TimeOnly) {
-            return (TimeOnly) this;
-        }
-        return new TimeOnly(this);
-    }
-
-    /**
-     * Get this object as a TimeOnly.
-     * 
-     * @param chronology chronology to apply, or ISOChronology if null
-     * @return a TimeOnly using the same millis, unless partially specified
-     */
-    public final TimeOnly toTimeOnly(Chronology chronology) {
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        if (this instanceof TimeOnly) {
-            TimeOnly t = (TimeOnly) this;
-            if (t.getChronology() == chronology.withUTC()) {
-                return t;
-            }
-        }
-        return new TimeOnly(this, chronology);
-    }
-
     /**
      * Get the date time as a <code>java.util.Date</code>.
      * 
@@ -541,10 +360,8 @@ public final int compareTo(Object readableInstant) {
 
         ReadableInstant otherInstant = (ReadableInstant) readableInstant;
 
-        // If instants are partial, then they can use each other to fill in
-        // missing fields.
-        long otherMillis = otherInstant.getMillis(this);
-        long thisMillis = getMillis(otherInstant);
+        long otherMillis = otherInstant.getMillis();
+        long thisMillis = getMillis();
 
         // cannot do (thisMillis - otherMillis) as can overflow
         if (thisMillis == otherMillis) {
@@ -568,9 +385,7 @@ public final boolean isAfter(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        // If instants are partial, then they can use each other to fill in
-        // missing fields.
-        return (getMillis(readableInstant) > readableInstant.getMillis(this));
+        return (getMillis() > readableInstant.getMillis());
     }
 
     /**
@@ -584,9 +399,7 @@ public final boolean isBefore(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        // If instants are partial, then they can use each other to fill in
-        // missing fields.
-        return (getMillis(readableInstant) < readableInstant.getMillis(this));
+        return (getMillis() < readableInstant.getMillis());
     }
 
     /**
@@ -600,9 +413,7 @@ public final boolean isEqual(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        // If instants are partial, then they can use each other to fill in
-        // missing fields.
-        return (getMillis(readableInstant) == readableInstant.getMillis(this));
+        return (getMillis() == readableInstant.getMillis());
     }
 
     // Output    
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
deleted file mode 100644
index 1ed6fa44c..000000000
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ /dev/null
@@ -1,460 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.io.Serializable;
-import java.util.Locale;
-
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.ConverterManager;
-import org.joda.time.convert.InstantConverter;
-import org.joda.time.format.DateTimeFormat;
-
-/**
- * AbstractPartialInstant provides the common behaviour for partial instant
- * classes.
- * <p>
- * This class should generally not be used directly by API users. The 
- * {@link PartialInstant} interface should be used when different 
- * kinds of partial instants are to be referenced.
- * <p>
- * AbstractPartialInstant subclasses may be mutable and not thread-safe.
- *
- * @author Brian S O'Neill
- */
-public abstract class AbstractPartialInstant extends AbstractInstant
-    implements PartialInstant, Serializable {
-
-    static final long serialVersionUID = -8202208243769478085L;
-
-    /**
-     * Converts the given instant to local time.
-     *
-     * @param instant instant to convert
-     * @param original original chronology
-     * @param chronoUTC chronology with no time zone
-     */
-    private static long toLocalTime(long instant, Chronology original, Chronology chronoUTC) {
-        if (original != chronoUTC) {
-            DateTimeZone zone = original.getZone();
-            if (zone != null) {
-                instant += zone.getOffset(instant);
-            }
-        }
-        return instant;
-    }
-
-    /**
-     * Returns a chronology that is UTC, defaulting to ISO if given chronology
-     * is null.
-     */
-    private static Chronology selectChronologyUTC(final Chronology chronology) {
-        if (chronology == null) {
-            return ISOChronology.getInstanceUTC();
-        } else {
-            Chronology utc = chronology.withUTC();
-            if (utc != null) {
-                return utc;
-            }
-            DateTimeZone zone = chronology.getZone();
-            if (zone == null || zone == DateTimeZone.UTC) {
-                return chronology;
-            }
-            throw new IllegalArgumentException("Chronology does not support UTC: " + chronology);
-        }
-    }
-
-    private Chronology iChronology;
-
-    /** The millis from 1970-01-01T00:00:00Z */
-    private long iMillis;
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs with the current instant in the default time zone.
-     */
-    protected AbstractPartialInstant() {
-        this(ISOChronology.getInstance());
-    }
-
-    /**
-     * Constructs with the current instant in the given time zone.
-     *
-     * @param zone  the time zone, null means default zone
-     */
-    protected AbstractPartialInstant(DateTimeZone zone) {
-        this(ISOChronology.getInstance(zone));
-    }
-
-    /**
-     * Constructs with the current instant in the time zone of the given
-     * chronology.
-     *
-     * @param chronology  the chronology, null means ISOChronology in default zone
-     */
-    protected AbstractPartialInstant(final Chronology chronology) {
-        iChronology = selectChronologyUTC(chronology);
-        iMillis = resetUnsupportedFields
-            (toLocalTime(DateTimeUtils.currentTimeMillis(), chronology, iChronology));
-    }
-
-    /**
-     * Constructs with milliseconds from 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     */
-    protected AbstractPartialInstant(long instant) {
-        iChronology = ISOChronology.getInstanceUTC();
-        iMillis = resetUnsupportedFields(instant);
-    }
-
-    /**
-     * Constructs with milliseconds from 1970-01-01T00:00:00Z. If the time zone
-     * of the given chronology is not null or UTC, then the instant is
-     * converted to local time.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    protected AbstractPartialInstant(long instant, final Chronology chronology) {
-        iChronology = selectChronologyUTC(chronology);
-        iMillis = resetUnsupportedFields
-            (toLocalTime(instant, chronology, iChronology));
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    protected AbstractPartialInstant(Object instant) {
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        Chronology original = converter.getChronology(instant);
-        iChronology = selectChronologyUTC(original);
-        iMillis = resetUnsupportedFields
-            (toLocalTime(converter.getInstantMillis(instant), original, iChronology));
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date or chronology is null
-     */
-    protected AbstractPartialInstant(Object instant, final Chronology chronology) {
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        Chronology original = converter.getChronology(instant, chronology);
-        iChronology = selectChronologyUTC(original);
-        iMillis = resetUnsupportedFields
-            (toLocalTime(converter.getInstantMillis(instant, chronology), original, iChronology));
-    }
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values reset.
-     *
-     * @return the value as milliseconds
-     */
-    public final long getMillis() {
-        return iMillis;
-    }
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled
-     * in by the given base instant.
-     *
-     * @param base source of missing fields
-     * @return the value as milliseconds
-     */
-    public final long getMillis(ReadableInstant base) {
-        if (base == null || isMatchingType(base)) {
-            return getMillis();
-        }
-        return getMillis(base, base.getZone());
-    }
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
-     * given base instant.
-     *
-     * @param base source of missing fields
-     * @param zone override the base time zone, null implies override with no
-     * time zone
-     * @return the value as milliseconds
-     */
-    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
-        if (base == null || isMatchingType(base)) {
-            return getMillis();
-        }
-
-        long millis = getMillis();
-        long baseMillis = base.getMillis();
-
-        DateTimeZone baseZone = base.getZone();
-        if (baseZone != null) {
-            // Strip zone from base such that sum can be performed.
-            baseMillis += baseZone.getOffset(baseMillis);
-        }
-
-        millis += resetSupportedFields(baseMillis);
-
-        if (zone != null) {
-            // Apply new zone.
-            millis -= zone.getOffsetFromLocal(millis);
-        }
-
-        return millis;
-    }
-
-    /**
-     * Gets the chronology of the instant, null if not applicable. The time
-     * zone of the chronology is either null or UTC.
-     * <p>
-     * The {@link Chronology} provides conversion from the millisecond
-     * value to meaningful fields in a particular calendar system.
-     * 
-     * @return the Chronology
-     */
-    public final Chronology getChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Returns the lower limiting field, where the lower limit field itself is
-     * supported. In other words, for the range described by the lower and
-     * upper limits, the lower limit is inclusive.
-     *
-     * @return lower limit or null if none
-     */
-    public abstract DateTimeField getLowerLimit();
-
-    /**
-     * Returns the upper limiting field, where the upper limit field itself is
-     * not supported. In other words, for the range described by the lower and
-     * upper limits, the upper limit is exclusive.
-     *
-     * @return upper limit or null if none
-     */
-    public abstract DateTimeField getUpperLimit();
-
-    /**
-     * Returns the given instant, except with lower and upper limits
-     * applied. Field values are reset below the lower limit and at or above
-     * the upper limit.
-     *
-     * @param instant milliseconds from 1970-01-01T00:00:00
-     */
-    public final long resetUnsupportedFields(long instant) {
-        DateTimeField field;
-        if ((field = getLowerLimit()) != null) {
-            instant = field.roundFloor(instant);
-        }
-        if ((field = getUpperLimit()) != null) {
-            instant = field.remainder(instant);
-        }
-        return instant;
-    }
-
-    /**
-     * Returns the given instant, except with lower and upper limits
-     * applied. Field values are reset below the upper limit and at or above
-     * the lower limit.
-     *
-     * @param instant milliseconds from 1970-01-01T00:00:00
-     */
-    public final long resetSupportedFields(final long instant) {
-        long newInstant = 0;
-        DateTimeField field;
-        if ((field = getUpperLimit()) != null) {
-            newInstant = field.roundFloor(instant);
-        }
-        if ((field = getLowerLimit()) != null) {
-            newInstant += field.remainder(instant);
-        }
-        return newInstant;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Compares this object with the specified object for equality based
-     * on the millisecond instant, the Chronology, and the limiting fields.
-     * <p>
-     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
-     * the chronology), use {@link #isEqual(ReadableInstant)} or
-     * {@link #compareTo(Object)}.
-     *
-     * @param readableInstant  a readable instant to check against
-     * @return true if millisecond and chronology are equal, false if
-     *  not or the instant is null or of an incorrect type
-     */
-    public boolean equals(Object readableInstant) {
-        if (this == readableInstant) {
-            return true;
-        }
-        return super.equals(readableInstant) && isMatchingType(readableInstant);
-    }
-
-    private static boolean equals(Object a, Object b) {
-        return (a == b) || (a != null && a.equals(b));
-    }
-
-    /**
-     * Returns true if the given instant is a PartialInstant that supports the
-     * same exact set of fields.
-     *
-     * @param instant  the instant to compare to
-     * @return true if instant is same type as this
-     */
-    private boolean isMatchingType(Object instant) {
-        if (instant instanceof PartialInstant) {
-            PartialInstant partial = (PartialInstant)instant;
-            return equals(getLowerLimit(), partial.getLowerLimit())
-                && equals(getUpperLimit(), partial.getUpperLimit());
-        }
-        return false;
-    }
-
-    /**
-     * Gets a hash code for the instant that is compatable with the 
-     * equals method.
-     *
-     * @return a suitable hash code
-     */
-    public int hashCode() {
-        int result = super.hashCode();
-        DateTimeField field;
-        if ((field = getLowerLimit()) != null) {
-            result = 31 * result + field.hashCode();
-        }
-        if ((field = getUpperLimit()) != null) {
-            result = 31 * result + field.hashCode();
-        }
-        return result;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Get the value as a String in a recognisable ISO8601 format, only
-     * displaying supported fields.
-     * <p>
-     * The string output is in ISO8601 format to enable the String
-     * constructor to correctly parse it.
-     *
-     * @return the value as an ISO8601 string
-     */
-    public abstract String toString();
-
-    /**
-     * Set the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z.
-     * <p>
-     * Subclasses that wish to be immutable should override this method with an
-     * empty implementation that is protected and final. This also ensures that
-     * all lower subclasses are also immutable.
-     *
-     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
-     * instant to
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    protected void setMillis(long instant) {
-        iMillis = resetUnsupportedFields(instant);
-    }
-
-    /**
-     * Set the value from an Object representing an instant.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     * 
-     * @param instant  an object representing an instant
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    protected void setMillis(Object instant) {
-        // Don't set iMillis directly, as it may provide a backdoor to
-        // immutable subclasses.
-        if (instant instanceof ReadableInstant) {
-            setMillis(((ReadableInstant) instant).getMillis());
-        } else {
-            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-            setMillis(converter.getInstantMillis(instant));
-        }
-    }
-
-    /**
-     * Set the chronology of the instant.
-     * <p>
-     * Subclasses that wish to be immutable should override this method with an
-     * empty implementation that is protected and final. This also ensures that
-     * all lower subclasses are also immutable.
-     * 
-     * @param chronology  the chronology to use, null means ISOChronology/UTC
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    protected void setChronology(Chronology chronology) {
-        iChronology = selectChronologyUTC(chronology);
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
deleted file mode 100644
index 3887a37a4..000000000
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ /dev/null
@@ -1,508 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.io.Serializable;
-
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.DateOnlyFieldProperty;
-
-/**
- * DateOnly is the basic implementation of a date only class supporting
- * chronologies. It holds the date as milliseconds from the Java epoch of
- * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.
- * <p>
- * This class uses a Chronology internally. The Chronology determines how the
- * millisecond instant value is converted into the date time fields.
- * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
- *
- * <p>Each individual field can be queried in two ways:
- * <ul>
- * <li><code>getYear()</code>
- * <li><code>year().get()</code>
- * </ul>
- * The second technique also provides access to other useful methods on the
- * field:
- * <ul>
- * <li>numeric value
- * <li>text value
- * <li>short text value
- * <li>maximum value
- * <li>minimum value
- * </ul>
- * <p>
- * DateOnly is thread-safe and immutable, provided that the Chronology is as well.
- * All standard Chronology classes supplied are thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- * @see MutableDateOnly
- * @see TimeOnly
- * @see DateTime
- */
-public class DateOnly extends AbstractPartialInstant implements Serializable {
-
-    /** Serialization lock */
-    private static final long serialVersionUID = -5796551185494585279L;
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs a DateOnly to the current date in the default time zone.
-     */
-    public DateOnly() {
-        super();
-    }
-
-    /**
-     * Constructs a DateOnly to the current date in the given time zone.
-     *
-     * @param zone  the time zone, null means default zone
-     */
-    public DateOnly(DateTimeZone zone) {
-        super(zone);
-    }
-
-    /**
-     * Constructs a DateOnly to the current date in the time zone of the given
-     * chronology.
-     *
-     * @param chronology  the chronology, null means ISOChronology in default zone
-     */
-    public DateOnly(Chronology chronology) {
-        super(chronology);
-    }
-
-    /**
-     * Constructs a DateOnly set to the milliseconds from 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     */
-    public DateOnly(long instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs a DateOnly set to the milliseconds from
-     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
-     * null or UTC, then the instant is converted to local time.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public DateOnly(long instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    public DateOnly(Object instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    public DateOnly(Object instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from date field values using
-     * <code>ISOChronology</code>.
-     *
-     * @param year  the year
-     * @param monthOfYear  the month of the year
-     * @param dayOfMonth  the day of the month
-     */
-    public DateOnly(
-            final int year,
-            final int monthOfYear,
-            final int dayOfMonth) {
-
-        super(ISOChronology.getInstanceUTC()
-              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
-              ISOChronology.getInstanceUTC());
-    }
-
-    /**
-     * Constructs an instance from date field values
-     * using the specified chronology.
-     * <p>
-     * If the chronology is null, <code>ISOChronology</code>
-     * is used.
-     *
-     * @param year  the year
-     * @param monthOfYear  the month of the year
-     * @param dayOfMonth  the day of the month
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public DateOnly(
-            final int year,
-            final int monthOfYear,
-            final int dayOfMonth,
-            Chronology chronology) {
-
-        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
-              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
-              chronology);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology is kept.
-     * Time fields will be removed from the specified millis.
-     * The returned object will be either be a new instance or <code>this</code>.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public final DateOnly withMillis(long newMillis) {
-        newMillis = resetUnsupportedFields(newMillis);
-        return (newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology()));
-    }
-
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     * The chronology will be converted to a UTC zone.
-     * The returned object will be either be a new instance or <code>this</code>.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public final DateOnly withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();
-        return (newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Returns the lower limiting field, dayOfYear.
-     *
-     * @return dayOfYear field
-     */
-    public final DateTimeField getLowerLimit() {
-        return getChronology().dayOfYear();
-    }
-
-    /**
-     * Returns the upper limiting field, null.
-     *
-     * @return null
-     */
-    public final DateTimeField getUpperLimit() {
-        return null;
-    }
-
-    // Date field access
-    //-----------------------------------------------------------------------
-    /**
-     * Get the era field value.
-     * 
-     * @return the era
-     */
-    public final int getEra() {
-        return getChronology().era().get(getMillis());
-    }
-
-    /**
-     * Get the year of era field value.
-     * 
-     * @return the year of era
-     */
-    public final int getCenturyOfEra() {
-        return getChronology().centuryOfEra().get(getMillis());
-    }
-
-    /**
-     * Get the year of era field value.
-     * 
-     * @return the year of era
-     */
-    public final int getYearOfEra() {
-        return getChronology().yearOfEra().get(getMillis());
-    }
-
-    /**
-     * Get the year of century field value.
-     * 
-     * @return the year of century
-     */
-    public final int getYearOfCentury() {
-        return getChronology().yearOfCentury().get(getMillis());
-    }
-
-    /**
-     * Get the year field value.
-     * 
-     * @return the year
-     */
-    public final int getYear() {
-        return getChronology().year().get(getMillis());
-    }
-
-    /**
-     * Get the weekyear field value.
-     * 
-     * @return the year of a week based year
-     */
-    public final int getWeekyear() {
-        return getChronology().weekyear().get(getMillis());
-    }
-
-    /**
-     * Get the month of year field value.
-     * 
-     * @return the month of year
-     */
-    public final int getMonthOfYear() {
-        return getChronology().monthOfYear().get(getMillis());
-    }
-
-    /**
-     * Get the week of weekyear field value.
-     * 
-     * @return the week of a week based year
-     */
-    public final int getWeekOfWeekyear() {
-        return getChronology().weekOfWeekyear().get(getMillis());
-    }
-
-    /**
-     * Get the day of year field value.
-     * 
-     * @return the day of year
-     */
-    public final int getDayOfYear() {
-        return getChronology().dayOfYear().get(getMillis());
-    }
-
-    /**
-     * Get the day of month field value.
-     * <p>
-     * The values for the day of month are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of month
-     */
-    public final int getDayOfMonth() {
-        return getChronology().dayOfMonth().get(getMillis());
-    }
-
-    /**
-     * Get the day of week field value.
-     * <p>
-     * The values for the day of week are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of week
-     */
-    public final int getDayOfWeek() {
-        return getChronology().dayOfWeek().get(getMillis());
-    }
-
-
-    // Properties
-    //-----------------------------------------------------------------------
-    /**
-     * Get the day of week property.
-     * <p>
-     * The values for day of week are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of week property
-     */
-    public final DateOnlyFieldProperty dayOfWeek() {
-        return new DateOnlyFieldProperty(this, getChronology().dayOfWeek());
-    }
-
-    /**
-     * Get the day of month property.
-     * 
-     * @return the day of month property
-     */
-    public final DateOnlyFieldProperty dayOfMonth() {
-        return new DateOnlyFieldProperty(this, getChronology().dayOfMonth());
-    }
-
-    /**
-     * Get the day of year property.
-     * 
-     * @return the day of year property
-     */
-    public final DateOnlyFieldProperty dayOfYear() {
-        return new DateOnlyFieldProperty(this, getChronology().dayOfYear());
-    }
-
-    /**
-     * Get the week of a week based year property.
-     * 
-     * @return the week of a week based year property
-     */
-    public final DateOnlyFieldProperty weekOfWeekyear() {
-        return new DateOnlyFieldProperty(this, getChronology().weekOfWeekyear());
-    }
-
-    /**
-     * Get the year of a week based year property.
-     * 
-     * @return the year of a week based year property
-     */
-    public final DateOnlyFieldProperty weekyear() {
-        return new DateOnlyFieldProperty(this, getChronology().weekyear());
-    }
-
-    /**
-     * Get the month of year property.
-     * 
-     * @return the month of year property
-     */
-    public final DateOnlyFieldProperty monthOfYear() {
-        return new DateOnlyFieldProperty(this, getChronology().monthOfYear());
-    }
-
-    /**
-     * Get the year property.
-     * 
-     * @return the year property
-     */
-    public final DateOnlyFieldProperty year() {
-        return new DateOnlyFieldProperty(this, getChronology().year());
-    }
-
-    /**
-     * Get the year of era property.
-     * 
-     * @return the year of era property
-     */
-    public final DateOnlyFieldProperty yearOfEra() {
-        return new DateOnlyFieldProperty(this, getChronology().yearOfEra());
-    }
-
-    /**
-     * Get the year of century property.
-     * 
-     * @return the year of era property
-     */
-    public final DateOnlyFieldProperty yearOfCentury() {
-        return new DateOnlyFieldProperty(this, getChronology().yearOfCentury());
-    }
-
-    /**
-     * Get the century of era property.
-     * 
-     * @return the year of era property
-     */
-    public final DateOnlyFieldProperty centuryOfEra() {
-        return new DateOnlyFieldProperty(this, getChronology().centuryOfEra());
-    }
-
-    /**
-     * Get the era property.
-     * 
-     * @return the era property
-     */
-    public final DateOnlyFieldProperty era() {
-        return new DateOnlyFieldProperty(this, getChronology().era());
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Output the date in ISO8601 date only format (yyyy-MM-dd).
-     * 
-     * @return ISO8601 date formatted string
-     */
-    public final String toString() {
-        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());
-    }
-
-    /**
-     * Overridden to do nothing, ensuring this class and all subclasses are
-     * immutable.
-     */
-    protected final void setMillis(long millis) {
-    }
-
-    /**
-     * Overridden to do nothing, ensuring this class and all subclasses are
-     * immutable.
-     */
-    protected final void setChronology(Chronology chronology) {
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index b11aa4c82..d9c11ce0d 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -93,8 +93,6 @@
  * @author Brian S O'Neill
  * @since 1.0
  * @see MutableDateTime
- * @see DateOnly
- * @see TimeOnly
  */
 public class DateTime extends AbstractDateTime
         implements ReadableDateTime, Serializable {
@@ -370,7 +368,7 @@ public final DateTime withZone(DateTimeZone newDateTimeZone) {
      * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
      * <p>
      * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone and the millisecond instant to keep
+     * This method alters the time zone and the millisecond instant to keep
      * the field values the same.
      * The returned object will be either be a new instance or <code>this</code>.
      *
diff --git a/JodaTime/src/java/org/joda/time/DateTimeComparator.java b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
index dd8108f09..6a0c19195 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
@@ -67,7 +67,6 @@
  * The default objects recognised by the comparator are:
  * <ul>
  * <li>ReadableInstant
- * <li>PartialInstant
  * <li>String
  * <li>Calendar
  * <li>Date
@@ -187,27 +186,15 @@ public int compare(Object lhsObj, Object rhsObj) {
         long lhsMillis, rhsMillis;
 
         if (lhsObj instanceof ReadableInstant) {
-            ReadableInstant lhsInstant = (ReadableInstant) lhsObj;
-
-            if (rhsObj instanceof ReadableInstant) {
-                ReadableInstant rhsInstant = (ReadableInstant) rhsObj;
-
-                // If instants are partial, then they can use each other to
-                // fill in missing fields.
-                lhsMillis = lhsInstant.getMillis(rhsInstant);
-                rhsMillis = rhsInstant.getMillis(lhsInstant);
-            } else {
-                lhsMillis = lhsInstant.getMillis();
-                rhsMillis = getMillisFromObject(rhsObj);
-            }
+            lhsMillis = ((ReadableInstant) lhsObj).getMillis();
         } else {
             lhsMillis = getMillisFromObject(lhsObj);
+        }
 
-            if (rhsObj instanceof ReadableInstant) {
-                rhsMillis = ((ReadableInstant) rhsObj).getMillis();
-            } else {
-                rhsMillis = getMillisFromObject(rhsObj);
-            }
+        if (rhsObj instanceof ReadableInstant) {
+            rhsMillis = ((ReadableInstant) rhsObj).getMillis();
+        } else {
+            rhsMillis = getMillisFromObject(rhsObj);
         }
 
         DateTimeField field;
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 9f8f00712..1372b2c98 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -76,7 +76,7 @@
         implements ReadableInstant, Serializable {
 
     /** Serialization lock */
-	private static final long serialVersionUID = 3299096530934209741L;
+    private static final long serialVersionUID = 3299096530934209741L;
 
     /** The millis from 1970-01-01T00:00:00Z */
     private final long iMillis;
@@ -151,27 +151,6 @@ public long getMillis() {
         return iMillis;
     }
 
-    /**
-     * Gets the milliseconds of the instant.
-     *
-     * @param base ignored
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
-     */
-    public long getMillis(ReadableInstant base) {
-        return iMillis;
-    }
-
-    /**
-     * Gets the milliseconds of the instant.
-     *
-     * @param base ignored
-     * @param zone ignored
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
-     */
-    public long getMillis(ReadableInstant base, DateTimeZone zone) {
-        return iMillis;
-    }
-
     /**
      * Gets the chronology of the instant, which is null.
      * <p>
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
deleted file mode 100644
index eca1c3f0d..000000000
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.io.Serializable;
-
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.ConverterManager;
-import org.joda.time.convert.DurationConverter;
-import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.ReadWritableInstantFieldProperty;
-
-/**
- * MutableDateOnly is the basic implementation of a modifiable date only class.
- * It holds the date as milliseconds from the Java epoch of 1970-01-01. The
- * time component and time zone is fixed at T00:00:00Z.
- * <p>
- * This class uses a Chronology internally. The Chronology determines how the
- * millisecond instant value is converted into the date time fields.
- * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
- *
- * <p>
- * Each individual field can be accessed in two ways:
- * <ul>
- * <li><code>getYear()</code>
- * <li><code>year().get()</code>
- * </ul>
- * The second technique also provides access to other useful methods on the
- * field:
- * <ul>
- * <li>get numeric value
- * <li>set numeric value
- * <li>add to numeric value
- * <li>add to numeric value wrapping with the field
- * <li>get text vlaue
- * <li>get short text value
- * <li>set text value
- * <li>field maximum value
- * <li>field minimum value
- * </ul>
- *
- * <p>
- * MutableDateOnly is mutable and not thread-safe, unless concurrent threads
- * are not invoking mutator methods.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DateOnly
- */
-public class MutableDateOnly extends AbstractPartialInstant
-    implements ReadWritableInstant, Cloneable, Serializable {
-
-    static final long serialVersionUID = 7781405642158513308L;
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs a MutableDateOnly to the current date in the default time zone.
-     */
-    public MutableDateOnly() {
-        super();
-    }
-
-    /**
-     * Constructs a MutableDateOnly to the current date in the given time zone.
-     *
-     * @param zone  the time zone, null means default zone
-     */
-    public MutableDateOnly(DateTimeZone zone) {
-        super(zone);
-    }
-
-    /**
-     * Constructs a MutableDateOnly to the current date in the time zone of the given
-     * chronology.
-     *
-     * @param chronology  the chronology, null means ISOChronology in default zone
-     */
-    public MutableDateOnly(Chronology chronology) {
-        super(chronology);
-    }
-
-    /**
-     * Constructs a MutableDateOnly set to the milliseconds from 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     */
-    public MutableDateOnly(long instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs a MutableDateOnly set to the milliseconds from
-     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
-     * null or UTC, then the instant is converted to local time.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public MutableDateOnly(long instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    public MutableDateOnly(Object instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a date, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
-     */
-    public MutableDateOnly(Object instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from date field values using
-     * <code>ISOChronology</code>.
-     *
-     * @param year  the year
-     * @param monthOfYear  the month of the year
-     * @param dayOfMonth  the day of the month
-     */
-    public MutableDateOnly(
-            final int year,
-            final int monthOfYear,
-            final int dayOfMonth) {
-
-        super(ISOChronology.getInstanceUTC()
-              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
-              ISOChronology.getInstanceUTC());
-    }
-
-    /**
-     * Constructs an instance from date field values
-     * using the specified chronology.
-     * <p>
-     * If the chronology is null, <code>ISOChronology</code>
-     * is used.
-     *
-     * @param year  the year
-     * @param monthOfYear  the month of the year
-     * @param dayOfMonth  the day of the month
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public MutableDateOnly(
-            final int year,
-            final int monthOfYear,
-            final int dayOfMonth,
-            Chronology chronology) {
-
-        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
-              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
-              chronology);
-    }
-
-    /**
-     * Returns the lower limiting field, dayOfYear.
-     *
-     * @return dayOfYear field
-     */
-    public final DateTimeField getLowerLimit() {
-        return getChronology().dayOfYear();
-    }
-
-    /**
-     * Returns the upper limiting field, null.
-     *
-     * @return null
-     */
-    public final DateTimeField getUpperLimit() {
-        return null;
-    }
-
-    /**
-     * Set the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
-     * instant to
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillis(long instant) {
-        super.setMillis(instant);
-    }
-
-    /**
-     * Set the value from an Object representing an instant.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     * 
-     * @param instant  an object representing an instant
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillis(Object instant) {
-        super.setMillis(instant);
-    }
-
-    /**
-     * Set the chronology of the instant.
-     * 
-     * @param chronology  the chronology to use, null means ISOChronology/UTC
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setChronology(Chronology chronology) {
-        super.setChronology(chronology);
-    }
-    
-    /**
-     * Since time zones are ignored, this method does nothing.
-     *
-     * @param zone  ignored
-     */
-    public void setZone(DateTimeZone zone) {
-    }
-
-    /**
-     * Since time zones are ignored, this method does nothing.
-     *
-     * @param zone  ignored
-     */
-    public void setZoneRetainFields(DateTimeZone zone) {
-    }
-
-    // Add
-    //-----------------------------------------------------------------------
-    /**
-     * Add an amount of time to the date.
-     * 
-     * @param duration  the millis to add
-     */
-    public void add(final long duration) {
-        setMillis(getMillis() + duration);
-    }
-
-    /**
-     * Add an amount of time to the date.
-     * 
-     * @param duration  duration to add.
-     */
-    public void add(final ReadableDuration duration) {
-        duration.addInto(this, 1);
-    }
-
-    /**
-     * Add an amount of time to the date.
-     * 
-     * @param duration  duration to add.
-     * @param scalar  direction and amount to add, which may be negative
-     */
-    public void add(final ReadableDuration duration, final int scalar) {
-        duration.addInto(this, scalar);
-    }
-
-    /**
-     * Add an amount of time to the date.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableDuration, and Long.
-     * 
-     * @param duration  an object representing a duration
-     */
-    public void add(final Object duration) {
-        if (duration instanceof ReadableDuration) {
-            add((ReadableDuration) duration, 1);
-        } else {
-            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
-            add(converter.getDurationMillis(duration));
-        }
-    }
-
-    // Field based
-    //-----------------------------------------------------------------------
-    /**
-     * Set a value in the specified field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableDateOnly date = new MutableDateOnly();
-     * date.set(GJChronology.getInstance().year(), 2002);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void set(final DateTimeField field, final int value) {
-        setMillis(field.set(getMillis(), value));
-    }
-
-    /**
-     * Add a value to the specified field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableDateOnly date = new MutableDateOnly();
-     * date.add(GJChronology.getInstance().year(), 2);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void add(final DateTimeField field, final int value) {
-        setMillis(field.add(getMillis(), value));
-    }
-
-    /**
-     * Add a value to the specified field, wrapping within that field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableDateOnly date = new MutableDateOnly();
-     * date.addWrapped(GJChronology.getInstance().monthOfYear(), 6);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void addWrapped(final DateTimeField field, final int value) {
-        setMillis(field.addWrapped(getMillis(), value));
-    }
-
-    // Date methods
-    //-----------------------------------------------------------------------
-    /**
-     * Set the year to the specified value.
-     *
-     * @param year  the year
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setYear(final int year) {
-        setMillis(getChronology().year().set(getMillis(), year));
-    }
-
-    /**
-     * Add a number of years to the date.
-     *
-     * @param years  the years to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addYears(final int years) {
-        setMillis(getChronology().years().add(getMillis(), years));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the weekyear to the specified value.
-     *
-     * @param weekyear  the weekyear
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setWeekyear(final int weekyear) {
-        setMillis(getChronology().weekyear().set(getMillis(), weekyear));
-    }
-
-    /**
-     * Add a number of weekyears to the date.
-     *
-     * @param weekyears  the weekyears to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addWeekyears(final int weekyears) {
-        setMillis(getChronology().weekyears().add(getMillis(), weekyears));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the month of the year to the specified value.
-     *
-     * @param monthOfYear  the month of the year
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMonthOfYear(final int monthOfYear) {
-        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));
-    }
-
-    /**
-     * Add a number of months to the date.
-     *
-     * @param months  the months to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addMonths(final int months) {
-        setMillis(getChronology().months().add(getMillis(), months));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the week of weekyear to the specified value.
-     *
-     * @param weekOfWeekyear the week of the weekyear
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setWeekOfWeekyear(final int weekOfWeekyear) {
-        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));
-    }
-
-    /**
-     * Add a number of weeks to the date.
-     *
-     * @param weeks  the weeks to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addWeeks(final int weeks) {
-        setMillis(getChronology().weeks().add(getMillis(), weeks));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the day of year to the specified value.
-     *
-     * @param dayOfYear the day of the year
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setDayOfYear(final int dayOfYear) {
-        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));
-    }
-
-    /**
-     * Set the day of the month to the specified value.
-     *
-     * @param dayOfMonth  the day of the month
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setDayOfMonth(final int dayOfMonth) {
-        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));
-    }
-
-    /**
-     * Set the day of week to the specified value.
-     *
-     * @param dayOfWeek  the day of the week
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setDayOfWeek(final int dayOfWeek) {
-        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));
-    }
-
-    /**
-     * Add a number of days to the date.
-     *
-     * @param days  the days to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addDays(final int days) {
-        setMillis(getChronology().days().add(getMillis(), days));
-    }
-
-    // Date field access
-    //-----------------------------------------------------------------------
-    /**
-     * Get the era field value.
-     * 
-     * @return the era
-     */
-    public final int getEra() {
-        return getChronology().era().get(getMillis());
-    }
-
-    /**
-     * Get the year of era field value.
-     * 
-     * @return the year of era
-     */
-    public final int getCenturyOfEra() {
-        return getChronology().centuryOfEra().get(getMillis());
-    }
-
-    /**
-     * Get the year of era field value.
-     * 
-     * @return the year of era
-     */
-    public final int getYearOfEra() {
-        return getChronology().yearOfEra().get(getMillis());
-    }
-
-    /**
-     * Get the year of century field value.
-     * 
-     * @return the year of century
-     */
-    public final int getYearOfCentury() {
-        return getChronology().yearOfCentury().get(getMillis());
-    }
-
-    /**
-     * Get the year field value.
-     * 
-     * @return the year
-     */
-    public final int getYear() {
-        return getChronology().year().get(getMillis());
-    }
-
-    /**
-     * Get the weekyear field value.
-     * 
-     * @return the year of a week based year
-     */
-    public final int getWeekyear() {
-        return getChronology().weekyear().get(getMillis());
-    }
-
-    /**
-     * Get the month of year field value.
-     * 
-     * @return the month of year
-     */
-    public final int getMonthOfYear() {
-        return getChronology().monthOfYear().get(getMillis());
-    }
-
-    /**
-     * Get the week of weekyear field value.
-     * 
-     * @return the week of a week based year
-     */
-    public final int getWeekOfWeekyear() {
-        return getChronology().weekOfWeekyear().get(getMillis());
-    }
-
-    /**
-     * Get the day of year field value.
-     * 
-     * @return the day of year
-     */
-    public final int getDayOfYear() {
-        return getChronology().dayOfYear().get(getMillis());
-    }
-
-    /**
-     * Get the day of month field value.
-     * <p>
-     * The values for the day of month are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of month
-     */
-    public final int getDayOfMonth() {
-        return getChronology().dayOfMonth().get(getMillis());
-    }
-
-    /**
-     * Get the day of week field value.
-     * <p>
-     * The values for the day of week are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of week
-     */
-    public final int getDayOfWeek() {
-        return getChronology().dayOfWeek().get(getMillis());
-    }
-
-    // Setters
-    //-----------------------------------------------------------------------
-    /**
-     * Set the date from milliseconds.
-     *
-     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setDate(final long instant) {
-        setMillis(instant);
-    }
-
-    /**
-     * Set the date from an object representing an instant.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  an object representing an instant, time part ignored
-     * @throws IllegalArgumentException if the object is null or invalid
-     */
-    public void setDate(final Object instant) {
-        setMillis(instant);
-    }
-
-    /**
-     * Set the date from fields.
-     *
-     * @param year  the year
-     * @param monthOfYear  the month of the year
-     * @param dayOfMonth  the day of the month
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setDate(
-            final int year,
-            final int monthOfYear,
-            final int dayOfMonth) {
-        setMillis(getChronology().getDateOnlyMillis(year, monthOfYear, dayOfMonth));
-    }
-
-    // Properties
-    //-----------------------------------------------------------------------
-    /**
-     * Get the day of week property.
-     * <p>
-     * The values for day of week are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of week property
-     */
-    public final ReadWritableInstantFieldProperty dayOfWeek() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfWeek());
-    }
-
-    /**
-     * Get the day of month property.
-     * 
-     * @return the day of month property
-     */
-    public final ReadWritableInstantFieldProperty dayOfMonth() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth());
-    }
-
-    /**
-     * Get the day of year property.
-     * 
-     * @return the day of year property
-     */
-    public final ReadWritableInstantFieldProperty dayOfYear() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfYear());
-    }
-
-    /**
-     * Get the week of a week based year property.
-     * 
-     * @return the week of a week based year property
-     */
-    public final ReadWritableInstantFieldProperty weekOfWeekyear() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());
-    }
-
-    /**
-     * Get the year of a week based year property.
-     * 
-     * @return the year of a week based year property
-     */
-    public final ReadWritableInstantFieldProperty weekyear() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().weekyear());
-    }
-
-    /**
-     * Get the month of year property.
-     * 
-     * @return the month of year property
-     */
-    public final ReadWritableInstantFieldProperty monthOfYear() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().monthOfYear());
-    }
-
-    /**
-     * Get the year property.
-     * 
-     * @return the year property
-     */
-    public final ReadWritableInstantFieldProperty year() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().year());
-    }
-
-    /**
-     * Get the year of era property.
-     * 
-     * @return the year of era property
-     */
-    public final ReadWritableInstantFieldProperty yearOfEra() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfEra());
-    }
-
-    /**
-     * Get the year of century property.
-     * 
-     * @return the year of era property
-     */
-    public final ReadWritableInstantFieldProperty yearOfCentury() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfCentury());
-    }
-
-    /**
-     * Get the century of era property.
-     * 
-     * @return the year of era property
-     */
-    public final ReadWritableInstantFieldProperty centuryOfEra() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());
-    }
-
-    /**
-     * Get the era property.
-     * 
-     * @return the era property
-     */
-    public final ReadWritableInstantFieldProperty era() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().era());
-    }
-
-    // Misc
-    //-----------------------------------------------------------------------
-    /**
-     * Clone this object without having to cast the returned object.
-     *
-     * @return a clone of the this object.
-     */
-    public MutableDateOnly copy() {
-        return (MutableDateOnly)clone();
-    }
-
-    /**
-     * Clone this object.
-     *
-     * @return a clone of this object.
-     */
-    public Object clone() {
-        try {
-            return super.clone();
-        } catch (CloneNotSupportedException ex) {
-            throw new InternalError("Clone error");
-        }
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Output the date in ISO8601 date only format (yyyy-MM-dd).
-     * 
-     * @return ISO8601 date formatted string
-     */
-    public final String toString() {
-        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 6b5aaa52b..514cc2bc2 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -105,6 +105,9 @@
     
     static final long serialVersionUID = 2852608688135209575L;
 
+    private DateTimeField iRoundingField;
+    private int iRoundingMode;
+
     // Constructors
     //-----------------------------------------------------------------------
     /**
@@ -310,8 +313,36 @@ public MutableDateTime(
         super(year, monthOfYear, dayOfMonth,
               hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);
     }
-
     
+    public DateTimeField getRoundingField() {
+        return iRoundingField;
+    }
+
+    public int getRoundingMode() {
+        return iRoundingMode;
+    }
+
+    public void setRoundingField(DateTimeField field) {
+        iRoundingField = field;
+        if (field != null) {
+            if (iRoundingMode == ROUND_NONE) {
+                iRoundingMode = ROUND_FLOOR;
+            }
+            setMillis(getMillis());
+        }
+    }
+
+    public void setRoundingField(DateTimeField field, int mode) {
+        if (mode < ROUND_NONE || mode > ROUND_HALF_EVEN) {
+            throw new IllegalArgumentException("Illegal rounding mode: " + mode);
+        }
+        iRoundingField = field;
+        iRoundingMode = mode;
+        if (field != null && mode != ROUND_NONE) {
+            setMillis(getMillis());
+        }
+    }
+
     // Millis
     //-----------------------------------------------------------------------
     /**
@@ -322,6 +353,26 @@ public MutableDateTime(
      * @see #setDateTime(long)
      */
     public void setMillis(long instant) {
+        switch (iRoundingMode) {
+        case ROUND_NONE:
+            break;
+        case ROUND_FLOOR:
+            instant = iRoundingField.roundFloor(instant);
+            break;
+        case ROUND_CEILING:
+            instant = iRoundingField.roundCeiling(instant);
+            break;
+        case ROUND_HALF_FLOOR:
+            instant = iRoundingField.roundHalfFloor(instant);
+            break;
+        case ROUND_HALF_CEILING:
+            instant = iRoundingField.roundHalfCeiling(instant);
+            break;
+        case ROUND_HALF_EVEN:
+            instant = iRoundingField.roundHalfEven(instant);
+            break;
+        }
+
         super.setMillis(instant);
     }
 
@@ -1064,6 +1115,43 @@ public MutableDateTime copy() {
         return (MutableDateTime)clone();
     }
 
+    // Basics
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based on the
+     * millisecond instant, the Chronology, and known rounding behavior.
+     * <p>
+     * All ReadableInstant instances are accepted.
+     * <p>
+     * See {@link #isEqual(ReadableInstant)} for an equals method that
+     * ignores the Chronology and rounding behavior.
+     *
+     * @param readableInstant  a readable instant to check against
+     * @return true if millisecond, Chronology, and known rounding behavior are
+     * equal, false if not or the instant is null or of an incorrect type
+     */
+    public boolean equals(Object readableInstant) {
+        if (this == readableInstant) {
+            return true;
+        }
+        if (super.equals(readableInstant)) {
+            if (readableInstant instanceof ReadWritableInstant) {
+                ReadWritableInstant other = (ReadWritableInstant) readableInstant;
+                if (getRoundingMode() == other.getRoundingMode()) {
+                    DateTimeField field = getRoundingField();
+                    if (field == other.getRoundingField() ||
+                        field != null && field.equals(other.getRoundingField())) {
+                        
+                        return true;
+                    }
+                }
+            } else {
+                return true;
+            }
+        }
+        return false;
+    }
+
     /**
      * Clone this object.
      *
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
deleted file mode 100644
index 14965dc99..000000000
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ /dev/null
@@ -1,835 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.io.Serializable;
-
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.ConverterManager;
-import org.joda.time.convert.DurationConverter;
-import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.ReadWritableInstantFieldProperty;
-
-/**
- * MutableTimeOnly is the basic implementation of a modifiable time only class.
- * It holds the time as milliseconds from T00:00:00. The date component and
- * time zone is fixed at 1970-01-01TZ.
- * <p>
- * This class uses a Chronology internally. The Chronology determines how the
- * millisecond instant value is converted into the date time fields.
- * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
- *
- * <p>
- * Each individual field can be accessed in two ways:
- * <ul>
- * <li><code>getHourOfDay()</code>
- * <li><code>hourOfDay().get()</code>
- * </ul>
- * The second technique also provides access to other useful methods on the
- * field:
- * <ul>
- * <li>get numeric value
- * <li>set numeric value
- * <li>add to numeric value
- * <li>add to numeric value wrapping with the field
- * <li>get text vlaue
- * <li>get short text value
- * <li>set text value
- * <li>field maximum value
- * <li>field minimum value
- * </ul>
- *
- * <p>
- * MutableTimeOnly is mutable and not thread-safe, unless concurrent threads
- * are not invoking mutator methods.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see TimeOnly
- */
-public class MutableTimeOnly extends AbstractPartialInstant
-    implements ReadWritableInstant, Cloneable, Serializable {
-
-    static final long serialVersionUID = -1438532408790831231L;
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs a MutableTimeOnly to the current time in the default time zone.
-     */
-    public MutableTimeOnly() {
-        super();
-    }
-
-    /**
-     * Constructs a MutableTimeOnly to the current time in the given time zone.
-     *
-     * @param zone  the time zone, null means default zone
-     */
-    public MutableTimeOnly(DateTimeZone zone) {
-        super(zone);
-    }
-
-    /**
-     * Constructs a MutableTimeOnly to the current time in the time zone of the given
-     * chronology.
-     *
-     * @param chronology  the chronology, null means ISOChronology in default zone
-     */
-    public MutableTimeOnly(Chronology chronology) {
-        super(chronology);
-    }
-
-    /**
-     * Constructs a MutableTimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     */
-    public MutableTimeOnly(long instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs a MutableTimeOnly set to the milliseconds from
-     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
-     * null or UTC, then the instant is converted to local time.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public MutableTimeOnly(long instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a time.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    public MutableTimeOnly(Object instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a time, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
-     */
-    public MutableTimeOnly(Object instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from time field values using
-     * <code>ISOChronology</code>.
-     *
-     * @param hourOfDay  the hour of the day
-     * @param minuteOfHour  the minute of the hour
-     * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the millisecond of the second
-     */
-    public MutableTimeOnly(
-            final int hourOfDay,
-            final int minuteOfHour,
-            final int secondOfMinute,
-            final int millisOfSecond) {
-
-        super(ISOChronology.getInstanceUTC()
-              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
-              ISOChronology.getInstanceUTC());
-    }
-
-    /**
-     * Constructs an instance from time field values
-     * using the specified chronology.
-     * <p>
-     * If the chronology is null, <code>ISOChronology</code>
-     * is used.
-     *
-     * @param hourOfDay  the hour of the day
-     * @param minuteOfHour  the minute of the hour
-     * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the millisecond of the second
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public MutableTimeOnly(
-            final int hourOfDay,
-            final int minuteOfHour,
-            final int secondOfMinute,
-            final int millisOfSecond,
-            Chronology chronology) {
-
-        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
-              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
-              chronology);
-    }
-
-    /**
-     * Returns the lower limiting field, null.
-     *
-     * @return null.
-     */
-    public final DateTimeField getLowerLimit() {
-        return null;
-    }
-
-    /**
-     * Returns the upper limiting field, dayOfYear.
-     *
-     * @return dayOfYear field
-     */
-    public final DateTimeField getUpperLimit() {
-        return getChronology().dayOfYear();
-    }
-
-    /**
-     * Set the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
-     * instant to
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillis(long instant) {
-        super.setMillis(instant);
-    }
-
-    /**
-     * Set the value from an Object representing an instant.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     * 
-     * @param instant  an object representing an instant
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillis(Object instant) {
-        super.setMillis(instant);
-    }
-
-    /**
-     * Set the chronology of the instant.
-     * 
-     * @param chronology  the chronology to use, null means ISOChronology/UTC
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setChronology(Chronology chronology) {
-        super.setChronology(chronology);
-    }
-    
-    /**
-     * Since time zones are ignored, this method does nothing.
-     *
-     * @param zone  ignored
-     */
-    public void setZone(DateTimeZone zone) {
-    }
-
-    /**
-     * Since time zones are ignored, this method does nothing.
-     *
-     * @param zone  ignored
-     */
-    public void setZoneRetainFields(DateTimeZone zone) {
-    }
-
-    // Add
-    //-----------------------------------------------------------------------
-    /**
-     * Add an amount of time to the time.
-     * 
-     * @param duration  the millis to add
-     */
-    public void add(final long duration) {
-        setMillis(getMillis() + duration);
-    }
-
-    /**
-     * Add an amount of time to the time.
-     * 
-     * @param duration  duration to add.
-     */
-    public void add(final ReadableDuration duration) {
-        duration.addInto(this, 1);
-    }
-
-    /**
-     * Add an amount of time to the time.
-     * 
-     * @param duration  duration to add.
-     * @param scalar  direction and amount to add, which may be negative
-     */
-    public void add(final ReadableDuration duration, final int scalar) {
-        duration.addInto(this, scalar);
-    }
-
-    /**
-     * Add an amount of time to the time.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableDuration, and Long.
-     * 
-     * @param duration  an object representing a duration
-     */
-    public void add(final Object duration) {
-        if (duration instanceof ReadableDuration) {
-            add((ReadableDuration) duration, 1);
-        } else {
-            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
-            add(converter.getDurationMillis(duration));
-        }
-    }
-
-    // Field based
-    //-----------------------------------------------------------------------
-    /**
-     * Set a value in the specified field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableTimeOnly time = new MutableTimeOnly();
-     * time.set(GJChronology.getInstance().hourOfDay(), 12);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void set(final DateTimeField field, final int value) {
-        setMillis(field.set(getMillis(), value));
-    }
-
-    /**
-     * Add a value to the specified field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableTimeOnly time = new MutableTimeOnly();
-     * time.add(GJChronology.getInstance().hourOfDay(), 2);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void add(final DateTimeField field, final int value) {
-        setMillis(field.add(getMillis(), value));
-    }
-
-    /**
-     * Add a value to the specified field, wrapping within that field.
-     * This could be used to set a field using a different Chronology.
-     * For example:
-     * <pre>
-     * MutableTimeOnly time = new MutableTimeOnly();
-     * time.addWrapped(GJChronology.getInstance().minuteOfHour(), 30);
-     * </pre>
-     * 
-     * @param field  the DateTimeField to use
-     * @param value the value
-     * @throws NullPointerException if the field is null
-     */
-    public void addWrapped(final DateTimeField field, final int value) {
-        setMillis(field.addWrapped(getMillis(), value));
-    }
-
-    // Time methods
-    //-----------------------------------------------------------------------
-    /**
-     * Set the hour of the day to the specified value.
-     *
-     * @param hourOfDay  the hour of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setHourOfDay(final int hourOfDay) {
-        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));
-    }
-
-    /**
-     * Set the hour of day (offset to 1-24) to the specified value.
-     * 
-     * @param clockhourOfDay  the clockhour of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setClockhourOfDay(final int clockhourOfDay) {
-        setMillis(getChronology().clockhourOfDay().set(getMillis(), clockhourOfDay));
-    }
-
-    /**
-     * Set the hour of am/pm (0-11) to the specified value.
-     * 
-     * @param hourOfHalfday  the hour of halfday
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setHourOfHalfday(final int hourOfHalfday) {
-        setMillis(getChronology().hourOfHalfday().set(getMillis(), hourOfHalfday));
-    }
-
-    /**
-     * Set the hour of am/pm (offset to 1-12) to the specified value.
-     * 
-     * @param clockhourOfHalfday  the clockhour of halfday
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setClockhourOfHalfday(final int clockhourOfHalfday) {
-        setMillis(getChronology().clockhourOfHalfday().set(getMillis(), clockhourOfHalfday));
-    }
-
-    /**
-     * Set the AM(0) PM(1) field value.
-     * 
-     * @param halfdayOfDay  the halfday of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setHalfdayOfDay(final int halfdayOfDay) {
-        setMillis(getChronology().halfdayOfDay().set(getMillis(), halfdayOfDay));
-    }
-
-    /**
-     * Add a number of hours to the date.
-     *
-     * @param hours  the hours to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addHours(final int hours) {
-        setMillis(getChronology().hours().add(getMillis(), hours));
-    }
-    
-    //-----------------------------------------------------------------------
-    /**
-     * Set the minute of the day to the specified value.
-     *
-     * @param minuteOfDay  the minute of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMinuteOfDay(final int minuteOfDay) {
-        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));
-    }
-
-    /**
-     * Set the minute of the hour to the specified value.
-     *
-     * @param minuteOfHour  the minute of hour
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMinuteOfHour(final int minuteOfHour) {
-        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));
-    }
-
-    /**
-     * Add a number of minutes to the date.
-     *
-     * @param minutes  the minutes to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addMinutes(final int minutes) {
-        setMillis(getChronology().minutes().add(getMillis(), minutes));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the second of the day to the specified value.
-     *
-     * @param secondOfDay  the second of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setSecondOfDay(final int secondOfDay) {
-        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));
-    }
-
-    /**
-     * Set the second of the minute to the specified value.
-     *
-     * @param secondOfMinute  the second of minute
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setSecondOfMinute(final int secondOfMinute) {
-        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));
-    }
-
-    /**
-     * Add a number of seconds to the date.
-     *
-     * @param seconds  the seconds to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addSeconds(final int seconds) {
-        setMillis(getChronology().seconds().add(getMillis(), seconds));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Set the millis of the day to the specified value.
-     *
-     * @param millisOfDay  the millis of day
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillisOfDay(final int millisOfDay) {
-        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));
-    }
-
-    /**
-     * Set the millis of the second to the specified value.
-     *
-     * @param millisOfSecond  the millis of second
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setMillisOfSecond(final int millisOfSecond) {
-        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));
-    }
-
-    /**
-     * Add a number of milliseconds to the date. The implementation of this
-     * method differs from the {@link #add(long)} method in that a
-     * DateTimeField performs the addition.
-     *
-     * @param millis  the milliseconds to add
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void addMillis(final int millis) {
-        setMillis(getChronology().millis().add(getMillis(), millis));
-    }
-
-    // Time field access
-    //-----------------------------------------------------------------------
-    /**
-     * Get the hour of day (0-23) field value.
-     *
-     * @return the hour of day
-     */
-    public final int getHourOfDay() {
-        return getChronology().hourOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field value.
-     * 
-     * @return the clockhour of day
-     */
-    public final int getClockhourOfDay() {
-        return getChronology().clockhourOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field value.
-     * 
-     * @return the hour of halfday
-     */
-    public final int getHourOfHalfday() {
-        return getChronology().hourOfHalfday().get(getMillis());
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field value.
-     * 
-     * @return the clockhour of halfday
-     */
-    public final int getClockhourOfHalfday() {
-        return getChronology().clockhourOfHalfday().get(getMillis());
-    }
-
-    /**
-     * Get the AM(0) PM(1) field value.
-     * 
-     * @return the halfday of day
-     */
-    public final int getHalfdayOfDay() {
-        return getChronology().halfdayOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the minute of day field value.
-     *
-     * @return the minute of day
-     */
-    public final int getMinuteOfDay() {
-        return getChronology().minuteOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the minute of hour field value.
-     *
-     * @return the minute of hour
-     */
-    public final int getMinuteOfHour() {
-        return getChronology().minuteOfHour().get(getMillis());
-    }
-
-    /**
-     * Get the second of day field value.
-     *
-     * @return the second of day
-     */
-    public final int getSecondOfDay() {
-        return getChronology().secondOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the second of minute field value.
-     *
-     * @return the second of minute
-     */
-    public final int getSecondOfMinute() {
-        return getChronology().secondOfMinute().get(getMillis());
-    }
-
-    /**
-     * Get the millis of day field value.
-     *
-     * @return the millis of day
-     */
-    public final int getMillisOfDay() {
-        return getChronology().millisOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the millis of second field value.
-     *
-     * @return the millis of second
-     */
-    public final int getMillisOfSecond() {
-        return getChronology().millisOfSecond().get(getMillis());
-    }
-
-    // Setters
-    //-----------------------------------------------------------------------
-    /**
-     * Set the time from milliseconds.
-     *
-     * @param millis milliseconds from T00:00:00Z, date part ignored
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setTime(final long millis) {
-        setMillis(millis);
-    }
-
-    /**
-     * Set the date from an object representing an instant.
-     * <p>
-     * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  an object representing an instant, date part ignored
-     * @throws IllegalArgumentException if the object is null or invalid
-     */
-    public void setTime(final Object instant) {
-        setMillis(instant);
-    }
-
-    /**
-     * Set the time from fields.
-     *
-     * @param hour  the hour
-     * @param minuteOfHour  the minute of the hour
-     * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the millisecond of the second
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public void setTime(
-            final int hour,
-            final int minuteOfHour,
-            final int secondOfMinute,
-            final int millisOfSecond) {
-        setMillis(getChronology().getTimeOnlyMillis(hour, minuteOfHour, secondOfMinute, millisOfSecond));
-    }
-
-    // Properties
-    //-----------------------------------------------------------------------
-    /**
-     * Get the hour of day (0-23) field property
-     * 
-     * @return the hour of day property
-     */
-    public final ReadWritableInstantFieldProperty hourOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfDay());
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field property
-     * 
-     * @return the clockhour of day property
-     */
-    public final ReadWritableInstantFieldProperty clockhourOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().clockhourOfDay());
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field property
-     * 
-     * @return the hour of halfday property
-     */
-    public final ReadWritableInstantFieldProperty hourOfHalfday() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfHalfday());
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field property
-     * 
-     * @return the clockhour of halfday property
-     */
-    public final ReadWritableInstantFieldProperty clockhourOfHalfday() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().clockhourOfHalfday());
-    }
-
-    /**
-     * Get the AM(0) PM(1) field property
-     * 
-     * @return the halfday of day property
-     */
-    public final ReadWritableInstantFieldProperty halfdayOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().halfdayOfDay());
-    }
-
-    /**
-     * Get the minute of day property
-     * 
-     * @return the minute of day property
-     */
-    public final ReadWritableInstantFieldProperty minuteOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfDay());
-    }
-
-    /**
-     * Get the minute of hour field property
-     * 
-     * @return the minute of hour property
-     */
-    public final ReadWritableInstantFieldProperty minuteOfHour() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfHour());
-    }
-
-    /**
-     * Get the second of day property
-     * 
-     * @return the second of day property
-     */
-    public final ReadWritableInstantFieldProperty secondOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfDay());
-    }
-
-    /**
-     * Get the second of minute field property
-     * 
-     * @return the second of minute property
-     */
-    public final ReadWritableInstantFieldProperty secondOfMinute() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfMinute());
-    }
-
-    /**
-     * Get the millis of day property
-     * 
-     * @return the millis of day property
-     */
-    public final ReadWritableInstantFieldProperty millisOfDay() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay());
-    }
-
-    /**
-     * Get the millis of second property
-     * 
-     * @return the millis of second property
-     */
-    public final ReadWritableInstantFieldProperty millisOfSecond() {
-        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfSecond());
-    }
-
-    // Misc
-    //-----------------------------------------------------------------------
-    /**
-     * Clone this object without having to cast the returned object.
-     *
-     * @return a clone of the this object.
-     */
-    public MutableTimeOnly copy() {
-        return (MutableTimeOnly)clone();
-    }
-
-    /**
-     * Clone this object.
-     *
-     * @return a clone of this object.
-     */
-    public Object clone() {
-        try {
-            return super.clone();
-        } catch (CloneNotSupportedException ex) {
-            throw new InternalError("Clone error");
-        }
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).
-     * 
-     * @return ISO8601 date formatted string
-     */
-    public final String toString() {
-        return ISODateTimeFormat.getInstance(getChronology())
-            .hourMinuteSecondFraction().print(getMillis());
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/PartialInstant.java b/JodaTime/src/java/org/joda/time/PartialInstant.java
deleted file mode 100644
index 99534a93c..000000000
--- a/JodaTime/src/java/org/joda/time/PartialInstant.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-/**
- * Defines an instant that does not support every datetime field.
- * A PartialInstant supports a range of fields, specified by lower and
- * upper bounding fields.
- *
- * @author Brian S O'Neill
- */
-public interface PartialInstant extends ReadableInstant {
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values reset.
-     *
-     * @return the value as milliseconds
-     */
-    long getMillis();
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled
-     * in by the given base instant.
-     *
-     * @param base  source of missing fields
-     * @return the value as milliseconds
-     */
-    long getMillis(ReadableInstant base);
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
-     * given base instant.
-     *
-     * @param base  source of missing fields
-     * @param zone  override the base time zone, null implies override with no
-     * time zone
-     * @return the value as milliseconds
-     */
-    long getMillis(ReadableInstant base, DateTimeZone zone);
-
-    /**
-     * Gets the chronology of the instant, null if not applicable. The time
-     * zone of the chronology is either null or UTC.
-     * <p>
-     * The {@link Chronology} provides conversion from the millisecond
-     * value to meaningful fields in a particular calendar system.
-     * 
-     * @return the Chronology
-     */
-    Chronology getChronology();
-
-    /**
-     * Returns the lower limiting field, where the lower limit field itself is
-     * supported. In other words, for the range described by the lower and
-     * upper limits, the lower limit is inclusive.
-     *
-     * @return lower limit or null if none
-     */
-    DateTimeField getLowerLimit();
-
-    /**
-     * Returns the upper limiting field, where the upper limit field itself is
-     * not supported. In other words, for the range described by the lower and
-     * upper limits, the upper limit is exclusive.
-     *
-     * @return upper limit or null if none
-     */
-    DateTimeField getUpperLimit();
-
-    /**
-     * Returns the given instant, except with lower and upper limits
-     * applied. Field values are reset below the lower limit and at or above
-     * the upper limit.
-     *
-     * @param instant milliseconds from 1970-01-01T00:00:00
-     * @return the adjusted millisecond instant
-     */
-    long resetUnsupportedFields(long instant);
-
-    /**
-     * Returns the given instant, except with lower and upper limits
-     * applied. Field values are reset below the upper limit and at or above
-     * the lower limit.
-     *
-     * @param instant milliseconds from 1970-01-01T00:00:00
-     * @return the adjusted millisecond instant
-     */
-    long resetSupportedFields(long instant);
-
-    /**
-     * Compares this object with the specified object for equality based
-     * on the millisecond instant, the Chronology, and the limiting fields.
-     * <p>
-     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
-     * the chronology), use {@link #isEqual(ReadableInstant)} or
-     * {@link #compareTo(Object)}.
-     *
-     * @param readableInstant  a readable instant to check against
-     * @return true if millisecond and chronology are equal, false if
-     *  not or the instant is null or of an incorrect type
-     */
-    boolean equals(Object readableInstant);
-
-    /**
-     * Gets a hash code for the instant that is compatable with the 
-     * equals method.
-     *
-     * @return a suitable hash code
-     */
-    int hashCode();
-
-    //-----------------------------------------------------------------------
-    /**
-     * Get the value as a String in a recognisable ISO8601 format, only
-     * displaying supported fields.
-     * <p>
-     * The string output is in ISO8601 format to enable the String
-     * constructor to correctly parse it.
-     *
-     * @return the value as an ISO8601 string
-     */
-    String toString();
-
-}
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index cf26c727e..28dc09be4 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -65,6 +65,51 @@
  */
 public interface ReadWritableInstant extends ReadableInstant {
 
+    /** Rounding is disabled */
+    public static final int ROUND_NONE = 0;
+    /** Rounding mode as described by {@link DateTimeField#roundFloor} */
+    public static final int ROUND_FLOOR = 1;
+    /** Rounding mode as described by {@link DateTimeField#roundCeiling} */
+    public static final int ROUND_CEILING = 2;
+    /** Rounding mode as described by {@link DateTimeField#roundHalfFloor} */
+    public static final int ROUND_HALF_FLOOR = 3;
+    /** Rounding mode as described by {@link DateTimeField#roundHalfCeiling} */
+    public static final int ROUND_HALF_CEILING = 4;
+    /** Rounding mode as described by {@link DateTimeField#roundHalfEven} */
+    public static final int ROUND_HALF_EVEN = 5;
+
+    /**
+     * Returns the field used for rounding, which is ignored if rounding mode
+     * is ROUND_NONE or field is null.
+     */
+    DateTimeField getRoundingField();
+
+    /**
+     * Returns the rounding mode for this instant, or ROUND_NONE if rounding
+     * is not enabled.
+     */
+    int getRoundingMode();
+
+    /**
+     * Sets the field to use for rounding, or null to disable rounding. If the
+     * rounding field is non-null, and the rounding mode was ROUND_NONE, it is
+     * switched to ROUND_FLOOR. The instant is then rounded using the new field
+     * and mode.
+     *
+     * @param field rounding field or null to disable
+     */
+    void setRoundingField(DateTimeField field);
+
+    /**
+     * Sets the field to use for rounding, or null to disable rounding. The
+     * instant is then rounded using the new field and mode.
+     *
+     * @param field rounding field or null to disable
+     * @param mode rounding mode or ROUND_NONE to disable
+     * @throws IllegalArgumentException if mode is unknown
+     */
+    void setRoundingField(DateTimeField field, int mode);
+
     /**
      * Set the value as the number of milliseconds since
      * the epoch, 1970-01-01T00:00:00Z.
diff --git a/JodaTime/src/java/org/joda/time/ReadableDateTime.java b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
index 8abbfb86e..41a444110 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
@@ -207,7 +207,7 @@
      * <p>
      * If the implementation of the interface is a DateTime, it is returned directly.
      * 
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      */
     DateTime toDateTime();
 
@@ -218,7 +218,7 @@
      * it is returned directly.
      * 
      * @param zone  time zone to apply
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      * @throws IllegalArgumentException if the time zone is null
      */
     DateTime toDateTime(DateTimeZone zone);
@@ -230,7 +230,7 @@
      * it is returned directly.
      * 
      * @param chronology  chronology to apply
-     * @return a DateTime using the same millis, unless partially specified
+     * @return a DateTime using the same millis
      * @throws IllegalArgumentException if the chronology is null
      */
     DateTime toDateTime(Chronology chronology);
@@ -238,7 +238,7 @@
     /**
      * Get this object as a MutableDateTime, always returning a new instance.
      * 
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      */
     MutableDateTime toMutableDateTime();
 
@@ -246,7 +246,7 @@
      * Get this object as a MutableDateTime, always returning a new instance.
      * 
      * @param zone  time zone to apply
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      * @throws IllegalArgumentException if the time zone is null
      */
     MutableDateTime toMutableDateTime(DateTimeZone zone);
@@ -255,43 +255,11 @@
      * Get this object as a MutableDateTime, always returning a new instance.
      * 
      * @param chronology  chronology to apply
-     * @return a MutableDateTime using the same millis, unless partially specified
+     * @return a MutableDateTime using the same millis
      * @throws IllegalArgumentException if the chronology is null
      */
     MutableDateTime toMutableDateTime(Chronology chronology);
 
-    /**
-     * Get this object as a DateOnly.
-     * 
-     * @return a DateOnly using the same millis, unless partially specified
-     */
-    DateOnly toDateOnly();
-
-    /**
-     * Get this object as a DateOnly.
-     * 
-     * @param chronology chronology to apply
-     * @return a DateOnly using the same millis, unless partially specified
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    DateOnly toDateOnly(Chronology chronology);
-
-    /**
-     * Get this object as a TimeOnly.
-     * 
-     * @return a TimeOnly using the same millis, unless partially specified
-     */
-    TimeOnly toTimeOnly();
-
-    /**
-     * Get this object as a TimeOnly.
-     * 
-     * @param chronology chronology to apply
-     * @return a TimeOnly using the same millis, unless partially specified
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    TimeOnly toTimeOnly(Chronology chronology);
-
     /**
      * Output the instant using the specified format pattern.
      *
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index f26ee6cd3..b63d243e7 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -77,38 +77,6 @@
      */
     long getMillis();
 
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
-     * given base instant.
-     * <p>
-     * This method is useful for ReadableInstants that only partially describe
-     * the instant. The base supplies missing information, including time
-     * zone. Instants that are complete simply return the same value as for
-     * getMillis(), ignoring the given base.
-     *
-     * @param base optional source of missing fields
-     * @return the value as milliseconds
-     */
-    long getMillis(ReadableInstant base);
-
-    /**
-     * Get the value as the number of milliseconds since the epoch,
-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
-     * given base instant.
-     * <p>
-     * This method is useful for ReadableInstants that only partially describe
-     * the instant. The base supplies missing information, excluding time
-     * zone. Instants that are complete simply return the same value as for
-     * getMillis(), ignoring the given base.
-     *
-     * @param base source of missing fields
-     * @param zone override the base time zone, null implies override with no
-     * time zone
-     * @return the value as milliseconds
-     */
-    long getMillis(ReadableInstant base, DateTimeZone zone);
-
     /**
      * Gets the chronology of the instant, null if not applicable.
      * <p>
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
deleted file mode 100644
index af1913cad..000000000
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.io.Serializable;
-
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.TimeOnlyFieldProperty;
-
-/**
- * TimeOnly is the basic implementation of a time only class supporting
- * chronologies. It holds the time as milliseconds from T00:00:00. The date
- * component and time zone is fixed at 1970-01-01TZ.
- * <p>
- * This class uses a Chronology internally. The Chronology determines how the
- * millisecond instant value is converted into the date time fields.
- * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
- *
- * <p>Each individual field can be queried in two ways:
- * <ul>
- * <li><code>getHourOfDay()</code>
- * <li><code>hourOfDay().get()</code>
- * </ul>
- * The second technique also provides access to other useful methods on the
- * field:
- * <ul>
- * <li>numeric value
- * <li>text value
- * <li>short text value
- * <li>maximum value
- * <li>minimum value
- * </ul>
- * <p>
- * TimeOnly is thread-safe and immutable, provided that the Chronology is as
- * well. All standard Chronology classes supplied are thread-safe and
- * immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- * @see MutableTimeOnly
- * @see DateOnly
- * @see DateTime
- */
-public class TimeOnly extends AbstractPartialInstant implements Serializable {
-
-    /** Serialization lock */
-    private static final long serialVersionUID = -8414446947366046476L;
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs a TimeOnly to the current time in the default time zone.
-     */
-    public TimeOnly() {
-        super();
-    }
-
-    /**
-     * Constructs a TimeOnly to the current time in the given time zone.
-     *
-     * @param zone  the time zone, null means default zone
-     */
-    public TimeOnly(DateTimeZone zone) {
-        super(zone);
-    }
-
-    /**
-     * Constructs a TimeOnly to the current time in the time zone of the given
-     * chronology.
-     *
-     * @param chronology  the chronology, null means ISOChronology in default zone
-     */
-    public TimeOnly(Chronology chronology) {
-        super(chronology);
-    }
-
-    /**
-     * Constructs a TimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     */
-    public TimeOnly(long instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs a TimeOnly set to the milliseconds from
-     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
-     * null or UTC, then the instant is converted to local time.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public TimeOnly(long instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a time.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    public TimeOnly(Object instant) {
-        super(instant);
-    }
-
-    /**
-     * Constructs an instance from an Object that represents a time, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is null
-     */
-    public TimeOnly(Object instant, Chronology chronology) {
-        super(instant, chronology);
-    }
-
-    /**
-     * Constructs an instance from time field values using
-     * <code>ISOChronology</code>.
-     *
-     * @param hourOfDay  the hour of the day
-     * @param minuteOfHour  the minute of the hour
-     * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the millisecond of the second
-     */
-    public TimeOnly(
-            final int hourOfDay,
-            final int minuteOfHour,
-            final int secondOfMinute,
-            final int millisOfSecond) {
-
-        super(ISOChronology.getInstanceUTC()
-              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
-              ISOChronology.getInstanceUTC());
-    }
-
-    /**
-     * Constructs an instance from time field values
-     * using the specified chronology.
-     * <p>
-     * If the chronology is null, <code>ISOChronology</code>
-     * is used.
-     *
-     * @param hourOfDay  the hour of the day
-     * @param minuteOfHour  the minute of the hour
-     * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the millisecond of the second
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    public TimeOnly(
-            final int hourOfDay,
-            final int minuteOfHour,
-            final int secondOfMinute,
-            final int millisOfSecond,
-            Chronology chronology) {
-
-        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
-              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
-              chronology);
-    }
-
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the millis will change, the chronology is kept.
-     * Date fields will be removed from the millis.
-     * The returned object will be either be a new instance or <code>this</code>.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public final TimeOnly withMillis(long newMillis) {
-        newMillis = resetUnsupportedFields(newMillis);
-        return (newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology()));
-    }
-    
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of the same implementation type.
-     * Only the chronology will change, the millis are kept.
-     * The chronology will be converted to a UTC zone.
-     * The returned object will be either be a new instance or <code>this</code>.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public final TimeOnly withChronology(Chronology newChronology) {
-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();
-        return (newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology));
-    }
-
-    /**
-     * Returns the lower limiting field, null.
-     *
-     * @return null.
-     */
-    public final DateTimeField getLowerLimit() {
-        return null;
-    }
-
-    /**
-     * Returns the upper limiting field, dayOfYear.
-     *
-     * @return dayOfYear field
-     */
-    public final DateTimeField getUpperLimit() {
-        return getChronology().dayOfYear();
-    }
-
-    // Time field access
-    //-----------------------------------------------------------------------
-    /**
-     * Get the hour of day (0-23) field value.
-     *
-     * @return the hour of day
-     */
-    public final int getHourOfDay() {
-        return getChronology().hourOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field value.
-     * 
-     * @return the clockhour of day
-     */
-    public final int getClockhourOfDay() {
-        return getChronology().clockhourOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field value.
-     * 
-     * @return the hour of halfday
-     */
-    public final int getHourOfHalfday() {
-        return getChronology().hourOfHalfday().get(getMillis());
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field value.
-     * 
-     * @return the clockhour of halfday
-     */
-    public final int getClockhourOfHalfday() {
-        return getChronology().clockhourOfHalfday().get(getMillis());
-    }
-
-    /**
-     * Get the AM(0) PM(1) field value.
-     * 
-     * @return the halfday of day
-     */
-    public final int getHalfdayOfDay() {
-        return getChronology().halfdayOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the minute of day field value.
-     *
-     * @return the minute of day
-     */
-    public final int getMinuteOfDay() {
-        return getChronology().minuteOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the minute of hour field value.
-     *
-     * @return the minute of hour
-     */
-    public final int getMinuteOfHour() {
-        return getChronology().minuteOfHour().get(getMillis());
-    }
-
-    /**
-     * Get the second of day field value.
-     *
-     * @return the second of day
-     */
-    public final int getSecondOfDay() {
-        return getChronology().secondOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the second of minute field value.
-     *
-     * @return the second of minute
-     */
-    public final int getSecondOfMinute() {
-        return getChronology().secondOfMinute().get(getMillis());
-    }
-
-    /**
-     * Get the millis of day field value.
-     *
-     * @return the millis of day
-     */
-    public final int getMillisOfDay() {
-        return getChronology().millisOfDay().get(getMillis());
-    }
-
-    /**
-     * Get the millis of second field value.
-     *
-     * @return the millis of second
-     */
-    public final int getMillisOfSecond() {
-        return getChronology().millisOfSecond().get(getMillis());
-    }
-
-    // Properties
-    //-----------------------------------------------------------------------
-    /**
-     * Get the hour of day (0-23) field property
-     * 
-     * @return the hour of day property
-     */
-    public final TimeOnlyFieldProperty hourOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().hourOfDay());
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field property
-     * 
-     * @return the clockhour of day property
-     */
-    public final TimeOnlyFieldProperty clockhourOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfDay());
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field property
-     * 
-     * @return the hour of halfday property
-     */
-    public final TimeOnlyFieldProperty hourOfHalfday() {
-        return new TimeOnlyFieldProperty(this, getChronology().hourOfHalfday());
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field property
-     * 
-     * @return the clockhour of halfday property
-     */
-    public final TimeOnlyFieldProperty clockhourOfHalfday() {
-        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfHalfday());
-    }
-
-    /**
-     * Get the AM(0) PM(1) field property
-     * 
-     * @return the halfday of day property
-     */
-    public final TimeOnlyFieldProperty halfdayOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().halfdayOfDay());
-    }
-
-    /**
-     * Get the minute of day property
-     * 
-     * @return the minute of day property
-     */
-    public final TimeOnlyFieldProperty minuteOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().minuteOfDay());
-    }
-
-    /**
-     * Get the minute of hour field property
-     * 
-     * @return the minute of hour property
-     */
-    public final TimeOnlyFieldProperty minuteOfHour() {
-        return new TimeOnlyFieldProperty(this, getChronology().minuteOfHour());
-    }
-
-    /**
-     * Get the second of day property
-     * 
-     * @return the second of day property
-     */
-    public final TimeOnlyFieldProperty secondOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().secondOfDay());
-    }
-
-    /**
-     * Get the second of minute field property
-     * 
-     * @return the second of minute property
-     */
-    public final TimeOnlyFieldProperty secondOfMinute() {
-        return new TimeOnlyFieldProperty(this, getChronology().secondOfMinute());
-    }
-
-    /**
-     * Get the millis of day property
-     * 
-     * @return the millis of day property
-     */
-    public final TimeOnlyFieldProperty millisOfDay() {
-        return new TimeOnlyFieldProperty(this, getChronology().millisOfDay());
-    }
-
-    /**
-     * Get the millis of second property
-     * 
-     * @return the millis of second property
-     */
-    public final TimeOnlyFieldProperty millisOfSecond() {
-        return new TimeOnlyFieldProperty(this, getChronology().millisOfSecond());
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).
-     * 
-     * @return ISO8601 date formatted string
-     */
-    public final String toString() {
-        return ISODateTimeFormat.getInstance(getChronology())
-            .hourMinuteSecondFraction().print(getMillis());
-    }
-
-    /**
-     * Overridden to do nothing, ensuring this class and all subclasses are
-     * immutable.
-     */
-    protected final void setMillis(long millis) {
-    }
-
-    /**
-     * Overridden to do nothing, ensuring this class and all subclasses are
-     * immutable.
-     */
-    protected final void setChronology(Chronology chronology) {
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index e3095c089..68300a6d7 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -70,7 +70,6 @@
  * The default instant converters are:
  * <ul>
  * <li>ReadableInstant
- * <li>PartialInstant
  * <li>String
  * <li>Calendar
  * <li>Date
@@ -120,7 +119,6 @@ protected ConverterManager() {
 
         iInstantConverters = new ConverterSet(new Converter[] {
             ReadableInstantConverter.INSTANCE,
-            PartialInstantConverter.INSTANCE,
             StringConverter.INSTANCE,
             CalendarConverter.INSTANCE,
             DateConverter.INSTANCE,
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
deleted file mode 100644
index 05f1e245c..000000000
--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.convert;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-import org.joda.time.PartialInstant;
-import org.joda.time.chrono.ISOChronology;
-
-/**
- * PartialInstantConverter extracts milliseconds and chronology from a
- * PartialInstant. Since supplying a time zone requires special attention, the
- * regular ReadableInstantConverter is not quite right.
- *
- * @author Brian S O'Neill
- * @since 1.0
- */
-class PartialInstantConverter extends ReadableInstantConverter {
-    /**
-     * Singleton instance.
-     */
-    static final PartialInstantConverter INSTANCE = new PartialInstantConverter();
-
-    /**
-     * Restricted constructor.
-     */
-    protected PartialInstantConverter() {
-        super();
-    }
-
-    /**
-     * Extracts the millis from an object of this convertor's type.
-     * 
-     * @param object  the object to convert, must not be null
-     * @return the millisecond instant
-     */
-    public long getInstantMillis(Object object) {
-        return getInstantMillis(object, (DateTimeZone) null);
-    }
-    
-    /**
-     * Extracts the millis from an object of this convertor's type.
-     * 
-     * @param object  the object to convert, must not be null
-     * @param zone  the zone to use, null means default zone
-     * @return the millisecond instant
-     */
-    public long getInstantMillis(Object object, DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        long millis = ((PartialInstant) object).getMillis();
-        return millis - zone.getOffsetFromLocal(millis);
-    }
-    
-    /**
-     * Extracts the millis from an object of this convertor's type.
-     * 
-     * @param object  the object to convert, must not be null
-     * @param chrono  the chronology to use, null means ISOChronology
-     * @return the millisecond instant
-     */
-    public long getInstantMillis(Object object, Chronology chrono) {
-        long millis = ((PartialInstant) object).getMillis();
-        DateTimeZone zone;
-        if (chrono == null) {
-            zone = DateTimeZone.getDefault();
-        } else {
-            zone = chrono.getZone();
-        }
-        if (zone != null) {
-            millis -= zone.getOffsetFromLocal(millis);
-        }
-        return millis;
-    }
-    
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the chronology, which is taken from the PartialDateTime.  If the
-     * chronology on the datetime is null, the ISOChronology in the default
-     * time zone is used. Otherwise, the chronology is returned in the default
-     * time zone.
-     * 
-     * @param object  the object to convert, must not be null
-     * @return the chronology, never null
-     */
-    public Chronology getChronology(Object object) {
-        Chronology chrono = ((PartialInstant) object).getChronology();
-        if (chrono == null) {
-            return ISOChronology.getInstance();
-        }
-        return chrono.withZone(DateTimeZone.getDefault());
-    }
-    
-    //-----------------------------------------------------------------------
-    /**
-     * Returns PartialDateTime.class.
-     * 
-     * @return PartialDateTime.class
-     */
-    public Class getSupportedType() {
-        return PartialInstant.class;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
deleted file mode 100644
index 4e80957bf..000000000
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.property;
-
-import java.util.Locale;
-
-import org.joda.time.DateOnly;
-import org.joda.time.DateTimeField;
-import org.joda.time.ReadableInstant;
-
-/**
- * DateOnlyFieldProperty binds a DateOnly to a DateTimeField allowing powerful
- * date functionality to be easily accessed.
- * <p>
- * The simplest use of this class is as an alternative get method, here used to
- * get the year '1972' (as an int) and the month 'December' (as a String).
- * <pre>
- * DateOnly date = new DateOnly(1972, 12, 3);
- * int year = date.year().get();
- * String monthStr = date.month().getAsText();
- * </pre>
- * <p>
- * Methods are also provided that allow date modification. These return new instances
- * of DateOnly - they do not modify the original. The example below yields two
- * independent immutable date objects 20 years apart.
- * <pre>
- * DateOnly date = new DateOnly(1972, 12, 3);
- * DateOnly date20 = date.year().addToCopy(20);
- * </pre>
- * Serious modification of dates (ie. more than just changing one or two fields)
- * should use the {@link org.joda.time.MutableDateOnly MutableDateOnly} class.
- * <p>
- * DateOnlyFieldPropery itself is thread-safe and immutable, as well as the
- * DateOnly being operated on.
- *
- * @author Brian S O'Neill
- */
-public class DateOnlyFieldProperty extends AbstractReadableInstantFieldProperty {
-
-    static final long serialVersionUID = -7764886769525930067L;
-
-    /** The instant this property is working against */
-    private final DateOnly iInstant;
-    /** The field this property is working against */
-    private final DateTimeField iField;
-
-    /**
-     * Constructor.
-     * 
-     * @param instant  the instant to set
-     * @param field  the field to use
-     */
-    public DateOnlyFieldProperty(DateOnly instant, DateTimeField field) {
-        super();
-        iInstant = instant;
-        iField = field;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the field being used.
-     * 
-     * @return the field
-     */
-    public DateTimeField getField() {
-        return iField;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public ReadableInstant getInstant() {
-        return iInstant;
-    }
-
-    /**
-     * Gets the date being used.
-     * 
-     * @return the date
-     */
-    public DateOnly getDateOnly() {
-        return iInstant;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Adds to this field in a copy of this DateOnly.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateOnly addToCopy(int value) {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.add(instant.getMillis(), value));
-    }
-
-    /**
-     * Adds to this field in a copy of this DateOnly.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateOnly addToCopy(long value) {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.add(instant.getMillis(), value));
-    }
-
-    /**
-     * Adds to this field, possibly wrapped, in a copy of this DateOnly.
-     * A wrapped operation only changes this field.
-     * Thus 31st January addWrapped one day goes to the 1st January.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateOnly addWrappedToCopy(int value) {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Sets this field in a copy of the DateOnly.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param value  the value to set the field in the copy to
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateOnly setCopy(int value) {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.set(instant.getMillis(), value));
-    }
-    
-    /**
-     * Sets this field in a copy of the DateOnly to a parsed text value.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param text  the text value to set
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public DateOnly setCopy(String text, Locale locale) {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.set(instant.getMillis(), text, locale));
-    }
-
-    /**
-     * Sets this field in a copy of the DateOnly to a parsed text value.
-     * <p>
-     * The DateOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateOnly to a MutableDateOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateOnly.
-     * 
-     * @param text  the text value to set
-     * @return a copy of the DateOnly with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public final DateOnly setCopy(String text) {
-        return setCopy(text, null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Rounds to the lowest whole unit of this field on a copy of this DateOnly.
-     *
-     * @return a copy of the DateOnly with the field value changed
-     */
-    public DateOnly roundFloorCopy() {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.roundFloor(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the highest whole unit of this field on a copy of this DateOnly.
-     *
-     * @return a copy of the DateOnly with the field value changed
-     */
-    public DateOnly roundCeilingCopy() {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.roundCeiling(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateOnly,
-     * favoring the floor if halfway.
-     *
-     * @return a copy of the DateOnly with the field value changed
-     */
-    public DateOnly roundHalfFloorCopy() {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateOnly,
-     * favoring the ceiling if halfway.
-     *
-     * @return a copy of the DateOnly with the field value changed
-     */
-    public DateOnly roundHalfCeilingCopy() {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateOnly.
-     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
-     *
-     * @return a copy of the DateOnly with the field value changed
-     */
-    public DateOnly roundHalfEvenCopy() {
-        DateOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfEven(instant.getMillis()));
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
deleted file mode 100644
index cf85f9a86..000000000
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.property;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.ReadableInstant;
-import org.joda.time.TimeOnly;
-
-/**
- * TimeOnlyFieldProperty binds a TimeOnly to a DateTimeField allowing powerful
- * time functionality to be easily accessed.
- * <p>
- * The simplest use of this class is as an alternative get method, here used to
- * get the clockhour '8' (as an int) and the AM/PM string.
- * <pre>
- * TimeOnly time = new TimeOnly(20, 30, 0);
- * int clockhour = time.clockhourOfHalfday().get();
- * String amPmStr = time.halfdayOfDay().getAsText();
- * </pre>
- * <p>
- * Methods are also provided that allow time modification. These return new instances
- * of TimeOnly - they do not modify the original. The example below yields two
- * independent immutable time objects 20 minutes apart.
- * <pre>
- * TimeOnly time = new TimeOnly(20, 30, 0);
- * TimeOnly time20 = time.minuteOfHour().addToCopy(20);
- * </pre>
- * Serious modification of times (ie. more than just changing one or two fields)
- * should use the {@link org.joda.time.MutableTimeOnly MutableTimeOnly} class.
- * <p>
- * TimeOnlyFieldPropery itself is thread-safe and immutable, as well as the
- * TimeOnly being operated on.
- *
- * @author Brian S O'Neill
- */
-public class TimeOnlyFieldProperty extends AbstractReadableInstantFieldProperty {
-
-    static final long serialVersionUID = 8826542069120527929L;
-
-    /** The instant this property is working against */
-    private final TimeOnly iInstant;
-    /** The field this property is working against */
-    private final DateTimeField iField;
-
-    /**
-     * Constructor.
-     * 
-     * @param instant  the instant to set
-     * @param field  the field to use
-     */
-    public TimeOnlyFieldProperty(TimeOnly instant, DateTimeField field) {
-        super();
-        iInstant = instant;
-        iField = field;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the field being used.
-     * 
-     * @return the field
-     */
-    public DateTimeField getField() {
-        return iField;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public ReadableInstant getInstant() {
-        return iInstant;
-    }
-
-    /**
-     * Gets the time being used.
-     * 
-     * @return the time
-     */
-    public TimeOnly getTimeOnly() {
-        return iInstant;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Adds to this field in a copy of this TimeOnly.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public TimeOnly addToCopy(int value) {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.add(instant.getMillis(), value));
-    }
-
-    /**
-     * Adds to this field in a copy of this TimeOnly.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public TimeOnly addToCopy(long value) {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.add(instant.getMillis(), value));
-    }
-
-    /**
-     * Adds to this field, possibly wrapped, in a copy of this TimeOnly.
-     * A wrapped operation only changes this field.
-     * Thus 12:59:00 addWrapped one minute goes to 12:00:00.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public TimeOnly addWrappedToCopy(int value) {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Sets this field in a copy of the TimeOnly.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param value  the value to set the field in the copy to
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public TimeOnly setCopy(int value) {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.set(instant.getMillis(), value));
-    }
-    
-    /**
-     * Sets this field in a copy of the TimeOnly to a parsed text value.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param text  the text value to set
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public TimeOnly setCopy(String text, Locale locale) {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.set(instant.getMillis(), text, locale));
-    }
-
-    /**
-     * Sets this field in a copy of the TimeOnly to a parsed text value.
-     * <p>
-     * The TimeOnly attached to this property is unchanged by this call.
-     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableTimeOnly.
-     * 
-     * @param text  the text value to set
-     * @return a copy of the TimeOnly with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public final TimeOnly setCopy(String text) {
-        return setCopy(text, null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Rounds to the lowest whole unit of this field on a copy of this TimeOnly.
-     *
-     * @return a copy of the TimeOnly with the field value changed
-     */
-    public TimeOnly roundFloorCopy() {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.roundFloor(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the highest whole unit of this field on a copy of this TimeOnly.
-     *
-     * @return a copy of the TimeOnly with the field value changed
-     */
-    public TimeOnly roundCeilingCopy() {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.roundCeiling(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly,
-     * favoring the floor if halfway.
-     *
-     * @return a copy of the TimeOnly with the field value changed
-     */
-    public TimeOnly roundHalfFloorCopy() {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly,
-     * favoring the ceiling if halfway.
-     *
-     * @return a copy of the TimeOnly with the field value changed
-     */
-    public TimeOnly roundHalfCeilingCopy() {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly.
-     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
-     *
-     * @return a copy of the TimeOnly with the field value changed
-     */
-    public TimeOnly roundHalfEvenCopy() {
-        TimeOnly instant = iInstant;
-        return instant.withMillis(iField.roundHalfEven(instant.getMillis()));
-    }
-
-}

From 5ffd24e9b7a5e5a4c6ca8590e091a96fe4aa8001 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 13:58:44 +0000
Subject: [PATCH 0087/1934] Update to send commit emails

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@237 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 CVSROOT/loginfo | 1 +
 1 file changed, 1 insertion(+)

diff --git a/CVSROOT/loginfo b/CVSROOT/loginfo
index 5a59f0a54..d5619fc23 100644
--- a/CVSROOT/loginfo
+++ b/CVSROOT/loginfo
@@ -24,3 +24,4 @@
 #DEFAULT (echo ""; id; echo %s; date; cat) >> $CVSROOT/CVSROOT/commitlog
 # or
 #DEFAULT (echo ""; id; echo %{sVv}; date; cat) >> $CVSROOT/CVSROOT/commitlog
+DEFAULT /cvsroot/sitedocs/CVSROOT/cvstools/syncmail %{sVv} joda-time-cvs@lists.sourceforge.net

From 6880d4b7184d23513485c62309a74d77acc46e21 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 14:23:34 +0000
Subject: [PATCH 0088/1934] Update TODO

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@238 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index 2129faa5e..359a9e469 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -1,6 +1,22 @@
 JodaTime ToDo list
 ==================
 
+0.96
+----
+Remove old partial code
+Rounded dates
+
+DayOfWeek partial (new)
+MonthOfYear partial (new)
+
+TimePeriod.toDurationByFields()
+
+...
+
+Tests
+
+
+
 1.0
 ---
 

From f4c5b9496262f269bc649e33ec7ddff7c2124c05 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 14:53:35 +0000
Subject: [PATCH 0089/1934] Update examples

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@239 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/Examples.java       | 89 ++++++++++++++-----
 1 file changed, 69 insertions(+), 20 deletions(-)

diff --git a/JodaTime/src/example/org/joda/example/time/Examples.java b/JodaTime/src/example/org/joda/example/time/Examples.java
index 6d693fe9c..a89b41027 100644
--- a/JodaTime/src/example/org/joda/example/time/Examples.java
+++ b/JodaTime/src/example/org/joda/example/time/Examples.java
@@ -55,6 +55,7 @@
 
 import java.util.Locale;
 
+import org.joda.time.DateTime;
 import org.joda.time.Instant;
 
 /**
@@ -74,35 +75,83 @@ public static void main(String[] args) throws Exception {
 
     private void run() {
         runInstant();
+        System.out.println();
+        runDateTime();
+        System.out.println();
     }
     
     private void runInstant() {
         System.out.println("Instant");
         System.out.println("=======");
         System.out.println("Instant stores a point in the datetime continuum as millisecs from 1970-01-01T00:00:00Z");
-        System.out.println("                       in = new Instant()");
+        System.out.println("Instant is immutable and thread-safe");
+        System.out.println("                      in = new Instant()");
         Instant in = new Instant();
-        System.out.println("Millisecond time:      in.getMillis():           " + in.getMillis());
-        System.out.println("ISO string version:    in.toString():            " + in.toString());
-        System.out.println("No chronology:         in.getChronology():       " + in.getChronology());
-        System.out.println("No time zone:          in.getDateTimeZone():     " + in.getZone());
-        System.out.println("Change millis:         in.withMillis(0):         " + in.withMillis(0L));
+        System.out.println("Millisecond time:     in.getMillis():           " + in.getMillis());
+        System.out.println("ISO string version:   in.toString():            " + in.toString());
+        System.out.println("No chronology:        in.getChronology():       " + in.getChronology());
+        System.out.println("No time zone:         in.getDateTimeZone():     " + in.getZone());
+        System.out.println("Change millis:        in.withMillis(0):         " + in.withMillis(0L));
         System.out.println("");
-        System.out.println("Convert to DateTime:   in.toDateTime():          " + in.toDateTime());
-        System.out.println("Convert to trusted:    in.toTrustedISODateTime():" + in.toTrustedISODateTime());
-        System.out.println("Convert to MutableDT:  in.toMutableDateTime():   " + in.toMutableDateTime());
-        System.out.println("Convert to DateOnly:   in.toDateOnly():          " + in.toDateOnly());
-        System.out.println("Convert to TimeOnly:   in.toTimeOnly():          " + in.toTimeOnly());
-        System.out.println("Convert to Date:       in.toDate():              " + in.toDate());
-        System.out.println("Convert to Calendar:   in.toCalendar(Locale.UK): " + in.toCalendar(Locale.UK).toString().substring(0, 46));
-        System.out.println("Convert to GregorianC: in.toGregorianCalendar(): " + in.toGregorianCalendar().toString().substring(0, 46));
+        System.out.println("Convert to Instant:   in.toInstant():           " + in.toInstant());
+        System.out.println("Convert to DateTime:  in.toDateTime():          " + in.toDateTime());
+        System.out.println("Convert to trusted:   in.toTrustedISODateTime():" + in.toTrustedISODateTime());
+        System.out.println("Convert to MutableDT: in.toMutableDateTime():   " + in.toMutableDateTime());
+        System.out.println("Convert to Date:      in.toDate():              " + in.toDate());
+        System.out.println("Convert to Calendar:  in.toCalendar(Locale.UK): " + in.toCalendar(Locale.UK).toString().substring(0, 46));
+        System.out.println("Convert to GregCal:   in.toGregorianCalendar(): " + in.toGregorianCalendar().toString().substring(0, 46));
         System.out.println("");
-        System.out.println("                       in2 = new Instant(in.getMillis() + 10)");
+        System.out.println("                      in2 = new Instant(in.getMillis() + 10)");
         Instant in2 = new Instant(in.getMillis() + 10);
-        System.out.println("Equals ms and chrono:  in.equals(in2):           " + in.equals(in2));
-        System.out.println("Compare millisecond:   in.compareTo(in2):        " + in.compareTo(in2));
-        System.out.println("Compare millisecond:   in.isEqual(in2):          " + in.isEqual(in2));
-        System.out.println("Compare millisecond:   in.isAfter(in2):          " + in.isAfter(in2));
-        System.out.println("Compare millisecond:   in.isBefore(in2):         " + in.isBefore(in2));
+        System.out.println("Equals ms and chrono: in.equals(in2):           " + in.equals(in2));
+        System.out.println("Compare millisecond:  in.compareTo(in2):        " + in.compareTo(in2));
+        System.out.println("Compare millisecond:  in.isEqual(in2):          " + in.isEqual(in2));
+        System.out.println("Compare millisecond:  in.isAfter(in2):          " + in.isAfter(in2));
+        System.out.println("Compare millisecond:  in.isBefore(in2):         " + in.isBefore(in2));
     }
+
+    private void runDateTime() {
+        System.out.println("DateTime");
+        System.out.println("=======");
+        System.out.println("DateTime stores a the date and time using millisecs from 1970-01-01T00:00:00Z internally");
+        System.out.println("DateTime is immutable and thread-safe");
+        System.out.println("                      in = new DateTime()");
+        DateTime in = new DateTime();
+        System.out.println("Millisecond time:     in.getMillis():           " + in.getMillis());
+        System.out.println("ISO string version:   in.toString():            " + in.toString());
+        System.out.println("ISO chronology:       in.getChronology():       " + in.getChronology());
+        System.out.println("Your time zone:       in.getDateTimeZone():     " + in.getZone());
+        System.out.println("Change millis:        in.withMillis(0):         " + in.withMillis(0L));
+        System.out.println("");
+        System.out.println("Get year:             in.getYear():             " + in.getYear());
+        System.out.println("Get monthOfYear:      in.getMonthOfYear():      " + in.getMonthOfYear());
+        System.out.println("Get dayOfMonth:       in.getDayOfMonth():       " + in.getDayOfMonth());
+        System.out.println("...");
+        System.out.println("Property access:      in.dayOfWeek().get():                " + in.dayOfWeek().get());
+        System.out.println("Day of week as text:  in.dayOfWeek().getAsText():          " + in.dayOfWeek().getAsText());
+        System.out.println("Day as short text:    in.dayOfWeek().getAsShortText():     " + in.dayOfWeek().getAsShortText());
+        System.out.println("Day in french:        in.dayOfWeek().getAsText(Locale.FRENCH): " + in.dayOfWeek().getAsText(Locale.FRENCH));
+        System.out.println("Max allowed value:    in.dayOfWeek().getMaximumValue():    " + in.dayOfWeek().getMaximumValue());
+        System.out.println("Min allowed value:    in.dayOfWeek().getMinimumValue():    " + in.dayOfWeek().getMinimumValue());
+        System.out.println("Copy & set to Jan:    in.monthOfYear().setCopy(1):         " + in.monthOfYear().setCopy(1));
+        System.out.println("Copy & add 14 months: in.monthOfYear().addCopy(14):        " + in.monthOfYear().addToCopy(14));
+        System.out.println("Add 14 mnths in field:in.monthOfYear().addInFieldCopy(14): " + in.monthOfYear().addWrappedToCopy(14));
+        System.out.println("...");
+        System.out.println("Convert to Instant:   in.toInstant():           " + in.toInstant());
+        System.out.println("Convert to DateTime:  in.toDateTime():          " + in.toDateTime());
+        System.out.println("Convert to trusted:   in.toTrustedISODateTime():" + in.toTrustedISODateTime());
+        System.out.println("Convert to MutableDT: in.toMutableDateTime():   " + in.toMutableDateTime());
+        System.out.println("Convert to Date:      in.toDate():              " + in.toDate());
+        System.out.println("Convert to Calendar:  in.toCalendar(Locale.UK): " + in.toCalendar(Locale.UK).toString().substring(0, 46));
+        System.out.println("Convert to GregCal:   in.toGregorianCalendar(): " + in.toGregorianCalendar().toString().substring(0, 46));
+        System.out.println("");
+        System.out.println("                      in2 = new DateTime(in.getMillis() + 10)");
+        DateTime in2 = new DateTime(in.getMillis() + 10);
+        System.out.println("Equals ms and chrono: in.equals(in2):           " + in.equals(in2));
+        System.out.println("Compare millisecond:  in.compareTo(in2):        " + in.compareTo(in2));
+        System.out.println("Compare millisecond:  in.isEqual(in2):          " + in.isEqual(in2));
+        System.out.println("Compare millisecond:  in.isAfter(in2):          " + in.isAfter(in2));
+        System.out.println("Compare millisecond:  in.isBefore(in2):         " + in.isBefore(in2));
+    }
+
 }

From fd192c2d6492fef77ab116c6a3ddedd128551c7a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 19:31:19 +0000
Subject: [PATCH 0090/1934] Commit class so its not lost

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@240 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/partial/DayOfWeek.java | 674 ++++++++++++++++++
 1 file changed, 674 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/partial/DayOfWeek.java

diff --git a/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java b/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java
new file mode 100644
index 000000000..9a841d61e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java
@@ -0,0 +1,674 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.partial;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadWritableInstant;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.InstantConverter;
+
+/**
+ * DayOfWeek is an immutable partial instant supporting the dayOfWeek field.
+ * <p>
+ * The day of week field is restricted to seven values for the ISO chronology.
+ * These are provided as constants.
+ * <p>
+ * Calculations on DayOfWeek are performed using a {@link Chronology}.
+ * This chronology is set to be in the UTC time zone for all calculations.
+ * <p>
+ * The day of week field can be queried in two ways:
+ * <ul>
+ * <li><code>getDayOfWeek()</code>
+ * <li><code>dayOfWeek().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the field:
+ * <ul>
+ * <li>numeric value - <code>dayOfWeek().get()</code>
+ * <li>text value - <code>dayOfWeek().getAsText()</code>
+ * <li>short text value - <code>dayOfWeek().getAsShortText()</code>
+ * <li>maximum/minimum values - <code>dayOfWeek().getMaximumValue()</code>
+ * <li>add/subtract - <code>dayOfWeek().addToCopy()</code>
+ * <li>set - <code>dayOfWeek().setCopy()</code>
+ * </ul>
+ * <p>
+ * DayOfWeek is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class DayOfWeek implements PartialInstant, Serializable {
+
+    /** Serialization version */
+    private static final long serialVersionUID = 65294869236483L;
+
+    /** The index of the dayOfWeek field in the field array. */
+    public static final int DAY_OF_WEEK = 0;
+
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek MONDAY = new DayOfWeek(1, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek TUESDAY = new DayOfWeek(2, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek WEDNESDAY = new DayOfWeek(3, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek THURSDAY = new DayOfWeek(4, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek FRIDAY = new DayOfWeek(5, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek SATURDAY = new DayOfWeek(6, null);
+    /** A day of week constant for Monday in the ISOChronology. */
+    public static final DayOfWeek SUNDAY = new DayOfWeek(7, null);
+    
+    /** The chronology. */
+    private final Chronology iChronology;
+    /** The value. */
+    private final int iValue;
+
+    // Factories
+    //-----------------------------------------------------------------------
+    /**
+     * Obtains a DayOfWeek by day value in the <code>ISOChronology</code>.
+     *
+     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
+     * @return a DayOfWeek constant
+     */
+    public static DayOfWeek getInstance(int dayOfWeek) {
+        switch (dayOfWeek) {
+            case 1:
+            return MONDAY;
+            case 2:
+            return TUESDAY;
+            case 3:
+            return WEDNESDAY;
+            case 4:
+            return THURSDAY;
+            case 5:
+            return FRIDAY;
+            case 6:
+            return SATURDAY;
+            case 7:
+            return SUNDAY;
+        }
+        throw new IllegalArgumentException("Invalid day of week: " + dayOfWeek);
+    }
+
+    /**
+     * Constructs a DayOfWeek with specified day value and chronology.
+     *
+     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
+     * @param chronology  the chronology, null means ISOChronology
+     * @return a DayOfWeek
+     */
+    public static DayOfWeek getInstance(int dayOfWeek, Chronology chronology) {
+        if (chronology == null || chronology instanceof ISOChronology) {
+            return getInstance(dayOfWeek);
+        }
+        return new DayOfWeek(dayOfWeek, chronology);
+    }
+
+    /**
+     * Obtains a DayOfWeek with the current time, using ISOChronology in
+     * the default zone to extract the fields.
+     * <p>
+     * The constructor uses the default time zone, resulting in the local time
+     * being initialised. Once the constructor is complete, all further calculations
+     * are performed without reference to a timezone (by switching to UTC).
+     * 
+     * @return a DayOfWeek constant
+     */
+    public static DayOfWeek getInstanceNow() {
+        return getInstance(DateTimeUtils.currentTimeMillis());
+    }
+
+    /**
+     * Obtains a DayOfWeek with the current time, using the specified chronology
+     * and zone to extract the fields.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     * @return a DayOfWeek
+     */
+    public static DayOfWeek getInstanceNow(Chronology chronology) {
+        return getInstance(DateTimeUtils.currentTimeMillis(), chronology);
+    }
+
+    /**
+     * Obtains a DayOfWeek by millisecond in the <code>ISOChronology</code>.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @return a DayOfWeek constant
+     */
+    public static DayOfWeek getInstance(long instant) {
+        int dayOfWeek = ISOChronology.getInstance().dayOfWeek().get(instant);
+        return getInstance(dayOfWeek);
+    }
+
+    /**
+     * Obtains a DayOfWeek extracting the partial fields from the specified
+     * milliseconds using the chronology provided.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in the default zone
+     * @return a DayOfWeek
+     */
+    public static DayOfWeek getInstance(long instant, Chronology chronology) {
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        int dayOfWeek = chronology.dayOfWeek().get(instant);
+        return getInstance(dayOfWeek, chronology);
+    }
+
+    /**
+     * Obtains a DayOfWeek from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, null means now
+     * @throws IllegalArgumentException if the date is invalid
+     * @return a DayOfWeek
+     */
+    public static DayOfWeek getInstance(Object instant) {
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        long millis = converter.getInstantMillis(instant);
+        Chronology chronology = converter.getChronology(instant);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        return getInstance(millis, chronology);
+    }
+
+    /**
+     * Obtains a DayOfWeek from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * <p>
+     * The constructor uses the time zone of the chronology specified.
+     * Once the constructor is complete, all further calculations are performed
+     * without reference to a timezone (by switching to UTC).
+     *
+     * @param instant  the datetime object, null means now
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the date is invalid
+     * @return a DayOfWeek
+     */
+    public static DayOfWeek getInstance(Object instant, Chronology chronology) {
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        long millis = converter.getInstantMillis(instant, chronology);
+        chronology = converter.getChronology(instant, chronology);
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        return getInstance(millis, chronology);
+    }
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a DayOfWeek with specified day value and chronology.
+     *
+     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    private DayOfWeek(int dayOfWeek, Chronology chronology) {
+        super();
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        iChronology = chronology.withUTC();
+        iValue = dayOfWeek;
+        chronology.validate(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the number of fields in this instant.
+     * 
+     * @return the field count
+     */
+    public int getFieldSize() {
+        return 1;
+    }
+
+    /**
+     * Gets the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the field
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public DateTimeField getField(int index) {
+        if (index != 0) {
+            throw new IllegalArgumentException(Integer.toString(index));
+        }
+        return iChronology.dayOfWeek();
+    }
+
+    /**
+     * Gets the value of the field at the specifed index.
+     * 
+     * @param index  the index
+     * @return the value
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public int getValue(int index) {
+        if (index != 0) {
+            throw new IllegalArgumentException(Integer.toString(index));
+        }
+        return iValue;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets an array containing the day of week field.
+     *
+     * @return the fields supported (cloned)
+     */
+    public DateTimeField[] getFields() {
+        return new DateTimeField[] {iChronology.dayOfWeek()};
+    }
+
+    /**
+     * Gets an array containing the day of week value.
+     *
+     * @return the current values of each field (cloned)
+     */
+    public int[] getValues() {
+        return new int[] {iValue};
+    }
+
+    /**
+     * Gets the chronology of the partial which is never null.
+     * <p>
+     * The {@link Chronology} is the calculation engine behind the partial and
+     * provides conversion and validation of the fields in a particular calendar system.
+     * 
+     * @return the chronology
+     */
+    public Chronology getChronology() {
+        return iChronology;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value of one of the fields of this partial.
+     * <p>
+     * The field specified must be one of those that is supported by the partial instant.
+     *
+     * @param field  a DateTimeField instance that is supported by this partial
+     * @return the value of that field
+     * @throws IllegalArgumentException if the field is null or not supported
+     */
+    public int get(DateTimeField field) {
+        if (iChronology.dayOfWeek() == field) {
+            return iValue;
+        }
+        throw new IllegalArgumentException("Field '" + field + "' is not supported");
+    }
+
+    /**
+     * Checks whether the field specified is supported by this partial instant.
+     *
+     * @param field  the field to check, may be null which returns false
+     * @return true if the field is supported
+     */
+    public boolean isSupported(DateTimeField field) {
+        if (iChronology.dayOfWeek() == field) {
+            return true;
+        }
+        return false;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param baseMillis  source of missing fields
+     * @param zone  the zone to use, null means default
+     * @return the combined instant in milliseconds
+     */
+    public long resolve(long baseMillis, DateTimeZone zone) {
+        Chronology chrono = iChronology.withZone(zone);
+        return resolve(baseMillis, chrono);
+    }
+
+    /**
+     * Resolves this partial into another complete instant setting the relevant fields
+     * on the writable instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the input writable instant
+     * will be updated with the time from this instant.
+     *
+     * @param base  the instant to set into, must not be null
+     * @throws IllegalArgumentException if the base instant is null
+     */
+    public void resolveInto(ReadWritableInstant base) {
+        if (base == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        Chronology chrono = base.getChronology();
+        long resolved = resolve(base.getMillis(), chrono);
+        base.setMillis(resolved);
+    }
+
+    /**
+     * Resolves this partial against another complete instant to create a new
+     * full instant. The combination is performed using the chronology of the
+     * specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the result of this method
+     * will be the date from the specified base plus the time from this instant.
+     *
+     * @param base  the instant that provides the missing fields, null means now
+     * @return the combined datetime
+     */
+    public DateTime resolveDateTime(ReadableInstant base) {
+        long resolved;
+        Chronology chrono;
+        if (base == null) {
+            chrono = ISOChronology.getInstance();
+            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);
+        } else {
+            chrono = base.getChronology();
+            resolved = resolve(base.getMillis(), chrono);
+        }
+        return new DateTime(resolved, chrono);
+    }
+
+    /**
+     * Resolve this partial instant into the base millis using the specified chronology.
+     * 
+     * @param baseMillis  the base millis
+     * @param chrono  the chronology
+     * @return the new resolved millis
+     */
+    protected long resolve(long baseMillis, Chronology chrono) {
+        return iChronology.dayOfWeek().set(baseMillis, iValue);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this PartialInstant with another returning true if the chronology,
+     * fields and values are equal.
+     *
+     * @param instant  an object to check against
+     * @return true if fields and values are equal
+     */
+    public boolean equals(Object instant) {
+        if (instant instanceof PartialInstant) {
+            PartialInstant other = (PartialInstant) instant;
+            return other.getFieldSize() == 1 &&
+                   other.isSupported(iChronology.dayOfWeek()) &&
+                   iValue == other.get(iChronology.dayOfWeek()) &&
+                   iChronology == other.getChronology();
+        }
+        return false;
+    }
+
+    /**
+     * Gets a hash code for the PartialInstant that is compatible with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    public int hashCode() {
+        int total = 157;
+        total = 23 * total + iValue;
+        total = 23 * total + iChronology.dayOfWeek().hashCode();
+        total += iChronology.hashCode();
+        return total;
+    }
+
+    /**
+     * Output the time in an ISO8601 format.
+     * 
+     * @return ISO8601 formatted string
+     */
+    public String toString() {
+        // TODO
+        return "";
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the ISO day of week (1-7) field value.
+     *
+     * @return the ISO day of the week, 1 (Monday) - 7 (Sunday)
+     */
+    public int getDayOfWeek() {
+        return iValue;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the ISO day of week (1-7) field property
+     * 
+     * @return the ISO day of week property
+     */
+    public Property dayOfWeek() {
+        return new Property(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The property class for DayOfWeek.
+     */
+    public static class Property extends AbstractPartialFieldProperty {
+
+        /** The instant */
+        private final DayOfWeek iInstant;
+
+        /**
+         * Constructs a property.
+         * 
+         * @param instant  the partial instant
+         */
+        Property(DayOfWeek instant) {
+            super();
+            iInstant = instant;
+        }
+
+        /**
+         * Gets the field that this property uses.
+         * 
+         * @return the field
+         */
+        public DateTimeField getField() {
+            return iInstant.iChronology.dayOfWeek();
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public PartialInstant getPartialInstant() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the instant that this property belongs to.
+         * 
+         * @return the partial instant
+         */
+        public DayOfWeek getDayOfWeek() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the value of the field that the partial instant is set to.
+         * 
+         * @return the field value
+         */
+        public int get() {
+            return iInstant.iValue;
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Adds to the value of this field in a copy of this DayOfWeek.
+         * <p>
+         * The value will be added to this field. If the result is too large
+         * (more than 7) or too small (less than 1) then an exception is thrown.
+         * <p>
+         * The DayOfWeek attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the DayOfWeek with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DayOfWeek addCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().add(iInstant, 0, newValues, valueToAdd);
+            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
+        }
+
+        /**
+         * Adds to the value of this field in a copy of this DayOfWeek wrapping
+         * within this field if the maximum value is reached.
+         * <p>
+         * The value will be added to this field. If the result is too large
+         * (more than 7) or too small (less than 1) then it will wrap.
+         * <p>
+         * The DayOfWeek attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param valueToAdd  the value to add to the field in the copy
+         * @return a copy of the DayOfWeek with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DayOfWeek addInFieldCopy(int valueToAdd) {
+            int[] newValues = iInstant.getValues();
+            getField().addInField(iInstant, 0, newValues, valueToAdd);
+            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Sets this field in a copy of the DayOfWeek.
+         * <p>
+         * The DayOfWeek attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param value  the value to set the field in the copy to
+         * @return a copy of the DayOfWeek with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DayOfWeek setCopy(int value) {
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, 0, newValues, value);
+            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
+        }
+
+        /**
+         * Sets this field in a copy of the DayOfWeek to a parsed text value.
+         * <p>
+         * The DayOfWeek attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param text  the text value to set
+         * @param locale  optional locale to use for selecting a text symbol
+         * @return a copy of the DayOfWeek with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public DayOfWeek setCopy(String text, Locale locale) {
+            int[] newValues = iInstant.getValues();
+            getField().set(iInstant, 0, newValues, text, locale);
+            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
+        }
+
+        /**
+         * Sets this field in a copy of the DayOfWeek to a parsed text value.
+         * <p>
+         * The DayOfWeek attached to this property is unchanged by this call.
+         * Instead, a new instance is returned.
+         * 
+         * @param text  the text value to set
+         * @return a copy of the DayOfWeek with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public DayOfWeek setCopy(String text) {
+            return setCopy(text, null);
+        }
+    }
+
+}

From fc46baaeb211b61923397b816c2c03faa1a2c668 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 19:32:10 +0000
Subject: [PATCH 0091/1934] DayOfWeek not that useful

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@241 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/partial/DayOfWeek.java | 674 ------------------
 1 file changed, 674 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/partial/DayOfWeek.java

diff --git a/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java b/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java
deleted file mode 100644
index 9a841d61e..000000000
--- a/JodaTime/src/java/org/joda/time/partial/DayOfWeek.java
+++ /dev/null
@@ -1,674 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.partial;
-
-import java.io.Serializable;
-import java.util.Locale;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTime;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeUtils;
-import org.joda.time.DateTimeZone;
-import org.joda.time.ReadWritableInstant;
-import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.ConverterManager;
-import org.joda.time.convert.InstantConverter;
-
-/**
- * DayOfWeek is an immutable partial instant supporting the dayOfWeek field.
- * <p>
- * The day of week field is restricted to seven values for the ISO chronology.
- * These are provided as constants.
- * <p>
- * Calculations on DayOfWeek are performed using a {@link Chronology}.
- * This chronology is set to be in the UTC time zone for all calculations.
- * <p>
- * The day of week field can be queried in two ways:
- * <ul>
- * <li><code>getDayOfWeek()</code>
- * <li><code>dayOfWeek().get()</code>
- * </ul>
- * The second technique also provides access to other useful methods on the field:
- * <ul>
- * <li>numeric value - <code>dayOfWeek().get()</code>
- * <li>text value - <code>dayOfWeek().getAsText()</code>
- * <li>short text value - <code>dayOfWeek().getAsShortText()</code>
- * <li>maximum/minimum values - <code>dayOfWeek().getMaximumValue()</code>
- * <li>add/subtract - <code>dayOfWeek().addToCopy()</code>
- * <li>set - <code>dayOfWeek().setCopy()</code>
- * </ul>
- * <p>
- * DayOfWeek is thread-safe and immutable, provided that the Chronology is as well.
- * All standard Chronology classes supplied are thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @since 1.0
- */
-public final class DayOfWeek implements PartialInstant, Serializable {
-
-    /** Serialization version */
-    private static final long serialVersionUID = 65294869236483L;
-
-    /** The index of the dayOfWeek field in the field array. */
-    public static final int DAY_OF_WEEK = 0;
-
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek MONDAY = new DayOfWeek(1, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek TUESDAY = new DayOfWeek(2, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek WEDNESDAY = new DayOfWeek(3, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek THURSDAY = new DayOfWeek(4, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek FRIDAY = new DayOfWeek(5, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek SATURDAY = new DayOfWeek(6, null);
-    /** A day of week constant for Monday in the ISOChronology. */
-    public static final DayOfWeek SUNDAY = new DayOfWeek(7, null);
-    
-    /** The chronology. */
-    private final Chronology iChronology;
-    /** The value. */
-    private final int iValue;
-
-    // Factories
-    //-----------------------------------------------------------------------
-    /**
-     * Obtains a DayOfWeek by day value in the <code>ISOChronology</code>.
-     *
-     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
-     * @return a DayOfWeek constant
-     */
-    public static DayOfWeek getInstance(int dayOfWeek) {
-        switch (dayOfWeek) {
-            case 1:
-            return MONDAY;
-            case 2:
-            return TUESDAY;
-            case 3:
-            return WEDNESDAY;
-            case 4:
-            return THURSDAY;
-            case 5:
-            return FRIDAY;
-            case 6:
-            return SATURDAY;
-            case 7:
-            return SUNDAY;
-        }
-        throw new IllegalArgumentException("Invalid day of week: " + dayOfWeek);
-    }
-
-    /**
-     * Constructs a DayOfWeek with specified day value and chronology.
-     *
-     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
-     * @param chronology  the chronology, null means ISOChronology
-     * @return a DayOfWeek
-     */
-    public static DayOfWeek getInstance(int dayOfWeek, Chronology chronology) {
-        if (chronology == null || chronology instanceof ISOChronology) {
-            return getInstance(dayOfWeek);
-        }
-        return new DayOfWeek(dayOfWeek, chronology);
-    }
-
-    /**
-     * Obtains a DayOfWeek with the current time, using ISOChronology in
-     * the default zone to extract the fields.
-     * <p>
-     * The constructor uses the default time zone, resulting in the local time
-     * being initialised. Once the constructor is complete, all further calculations
-     * are performed without reference to a timezone (by switching to UTC).
-     * 
-     * @return a DayOfWeek constant
-     */
-    public static DayOfWeek getInstanceNow() {
-        return getInstance(DateTimeUtils.currentTimeMillis());
-    }
-
-    /**
-     * Obtains a DayOfWeek with the current time, using the specified chronology
-     * and zone to extract the fields.
-     * <p>
-     * The constructor uses the time zone of the chronology specified.
-     * Once the constructor is complete, all further calculations are performed
-     * without reference to a timezone (by switching to UTC).
-     *
-     * @param chronology  the chronology, null means ISOChronology in the default zone
-     * @return a DayOfWeek
-     */
-    public static DayOfWeek getInstanceNow(Chronology chronology) {
-        return getInstance(DateTimeUtils.currentTimeMillis(), chronology);
-    }
-
-    /**
-     * Obtains a DayOfWeek by millisecond in the <code>ISOChronology</code>.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @return a DayOfWeek constant
-     */
-    public static DayOfWeek getInstance(long instant) {
-        int dayOfWeek = ISOChronology.getInstance().dayOfWeek().get(instant);
-        return getInstance(dayOfWeek);
-    }
-
-    /**
-     * Obtains a DayOfWeek extracting the partial fields from the specified
-     * milliseconds using the chronology provided.
-     * <p>
-     * The constructor uses the time zone of the chronology specified.
-     * Once the constructor is complete, all further calculations are performed
-     * without reference to a timezone (by switching to UTC).
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
-     * @param chronology  the chronology, null means ISOChronology in the default zone
-     * @return a DayOfWeek
-     */
-    public static DayOfWeek getInstance(long instant, Chronology chronology) {
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        int dayOfWeek = chronology.dayOfWeek().get(instant);
-        return getInstance(dayOfWeek, chronology);
-    }
-
-    /**
-     * Obtains a DayOfWeek from an Object that represents a time.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     *
-     * @param instant  the datetime object, null means now
-     * @throws IllegalArgumentException if the date is invalid
-     * @return a DayOfWeek
-     */
-    public static DayOfWeek getInstance(Object instant) {
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        long millis = converter.getInstantMillis(instant);
-        Chronology chronology = converter.getChronology(instant);
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        return getInstance(millis, chronology);
-    }
-
-    /**
-     * Obtains a DayOfWeek from an Object that represents a time, using the
-     * specified chronology.
-     * <p>
-     * The recognised object types are defined in
-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
-     * include ReadableInstant, String, Calendar and Date.
-     * <p>
-     * The constructor uses the time zone of the chronology specified.
-     * Once the constructor is complete, all further calculations are performed
-     * without reference to a timezone (by switching to UTC).
-     *
-     * @param instant  the datetime object, null means now
-     * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is invalid
-     * @return a DayOfWeek
-     */
-    public static DayOfWeek getInstance(Object instant, Chronology chronology) {
-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        long millis = converter.getInstantMillis(instant, chronology);
-        chronology = converter.getChronology(instant, chronology);
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        return getInstance(millis, chronology);
-    }
-
-    // Constructors
-    //-----------------------------------------------------------------------
-    /**
-     * Constructs a DayOfWeek with specified day value and chronology.
-     *
-     * @param dayOfWeek  the ISO day of the week, 1 (Monday) - 7 (Sunday)
-     * @param chronology  the chronology, null means ISOChronology
-     */
-    private DayOfWeek(int dayOfWeek, Chronology chronology) {
-        super();
-        if (chronology == null) {
-            chronology = ISOChronology.getInstance();
-        }
-        iChronology = chronology.withUTC();
-        iValue = dayOfWeek;
-        chronology.validate(this);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the number of fields in this instant.
-     * 
-     * @return the field count
-     */
-    public int getFieldSize() {
-        return 1;
-    }
-
-    /**
-     * Gets the field at the specifed index.
-     * 
-     * @param index  the index
-     * @return the field
-     * @throws IndexOutOfBoundsException if the index is invalid
-     */
-    public DateTimeField getField(int index) {
-        if (index != 0) {
-            throw new IllegalArgumentException(Integer.toString(index));
-        }
-        return iChronology.dayOfWeek();
-    }
-
-    /**
-     * Gets the value of the field at the specifed index.
-     * 
-     * @param index  the index
-     * @return the value
-     * @throws IndexOutOfBoundsException if the index is invalid
-     */
-    public int getValue(int index) {
-        if (index != 0) {
-            throw new IllegalArgumentException(Integer.toString(index));
-        }
-        return iValue;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets an array containing the day of week field.
-     *
-     * @return the fields supported (cloned)
-     */
-    public DateTimeField[] getFields() {
-        return new DateTimeField[] {iChronology.dayOfWeek()};
-    }
-
-    /**
-     * Gets an array containing the day of week value.
-     *
-     * @return the current values of each field (cloned)
-     */
-    public int[] getValues() {
-        return new int[] {iValue};
-    }
-
-    /**
-     * Gets the chronology of the partial which is never null.
-     * <p>
-     * The {@link Chronology} is the calculation engine behind the partial and
-     * provides conversion and validation of the fields in a particular calendar system.
-     * 
-     * @return the chronology
-     */
-    public Chronology getChronology() {
-        return iChronology;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Get the value of one of the fields of this partial.
-     * <p>
-     * The field specified must be one of those that is supported by the partial instant.
-     *
-     * @param field  a DateTimeField instance that is supported by this partial
-     * @return the value of that field
-     * @throws IllegalArgumentException if the field is null or not supported
-     */
-    public int get(DateTimeField field) {
-        if (iChronology.dayOfWeek() == field) {
-            return iValue;
-        }
-        throw new IllegalArgumentException("Field '" + field + "' is not supported");
-    }
-
-    /**
-     * Checks whether the field specified is supported by this partial instant.
-     *
-     * @param field  the field to check, may be null which returns false
-     * @return true if the field is supported
-     */
-    public boolean isSupported(DateTimeField field) {
-        if (iChronology.dayOfWeek() == field) {
-            return true;
-        }
-        return false;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
-     * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
-     *
-     * @param baseMillis  source of missing fields
-     * @param zone  the zone to use, null means default
-     * @return the combined instant in milliseconds
-     */
-    public long resolve(long baseMillis, DateTimeZone zone) {
-        Chronology chrono = iChronology.withZone(zone);
-        return resolve(baseMillis, chrono);
-    }
-
-    /**
-     * Resolves this partial into another complete instant setting the relevant fields
-     * on the writable instant. The combination is performed using the chronology of the
-     * specified instant.
-     * <p>
-     * For example, if this partial represents a time, then the input writable instant
-     * will be updated with the time from this instant.
-     *
-     * @param base  the instant to set into, must not be null
-     * @throws IllegalArgumentException if the base instant is null
-     */
-    public void resolveInto(ReadWritableInstant base) {
-        if (base == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        Chronology chrono = base.getChronology();
-        long resolved = resolve(base.getMillis(), chrono);
-        base.setMillis(resolved);
-    }
-
-    /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant. The combination is performed using the chronology of the
-     * specified instant.
-     * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
-     *
-     * @param base  the instant that provides the missing fields, null means now
-     * @return the combined datetime
-     */
-    public DateTime resolveDateTime(ReadableInstant base) {
-        long resolved;
-        Chronology chrono;
-        if (base == null) {
-            chrono = ISOChronology.getInstance();
-            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);
-        } else {
-            chrono = base.getChronology();
-            resolved = resolve(base.getMillis(), chrono);
-        }
-        return new DateTime(resolved, chrono);
-    }
-
-    /**
-     * Resolve this partial instant into the base millis using the specified chronology.
-     * 
-     * @param baseMillis  the base millis
-     * @param chrono  the chronology
-     * @return the new resolved millis
-     */
-    protected long resolve(long baseMillis, Chronology chrono) {
-        return iChronology.dayOfWeek().set(baseMillis, iValue);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Compares this PartialInstant with another returning true if the chronology,
-     * fields and values are equal.
-     *
-     * @param instant  an object to check against
-     * @return true if fields and values are equal
-     */
-    public boolean equals(Object instant) {
-        if (instant instanceof PartialInstant) {
-            PartialInstant other = (PartialInstant) instant;
-            return other.getFieldSize() == 1 &&
-                   other.isSupported(iChronology.dayOfWeek()) &&
-                   iValue == other.get(iChronology.dayOfWeek()) &&
-                   iChronology == other.getChronology();
-        }
-        return false;
-    }
-
-    /**
-     * Gets a hash code for the PartialInstant that is compatible with the 
-     * equals method.
-     *
-     * @return a suitable hash code
-     */
-    public int hashCode() {
-        int total = 157;
-        total = 23 * total + iValue;
-        total = 23 * total + iChronology.dayOfWeek().hashCode();
-        total += iChronology.hashCode();
-        return total;
-    }
-
-    /**
-     * Output the time in an ISO8601 format.
-     * 
-     * @return ISO8601 formatted string
-     */
-    public String toString() {
-        // TODO
-        return "";
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Get the ISO day of week (1-7) field value.
-     *
-     * @return the ISO day of the week, 1 (Monday) - 7 (Sunday)
-     */
-    public int getDayOfWeek() {
-        return iValue;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Get the ISO day of week (1-7) field property
-     * 
-     * @return the ISO day of week property
-     */
-    public Property dayOfWeek() {
-        return new Property(this);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * The property class for DayOfWeek.
-     */
-    public static class Property extends AbstractPartialFieldProperty {
-
-        /** The instant */
-        private final DayOfWeek iInstant;
-
-        /**
-         * Constructs a property.
-         * 
-         * @param instant  the partial instant
-         */
-        Property(DayOfWeek instant) {
-            super();
-            iInstant = instant;
-        }
-
-        /**
-         * Gets the field that this property uses.
-         * 
-         * @return the field
-         */
-        public DateTimeField getField() {
-            return iInstant.iChronology.dayOfWeek();
-        }
-
-        /**
-         * Gets the instant that this property belongs to.
-         * 
-         * @return the partial instant
-         */
-        public PartialInstant getPartialInstant() {
-            return iInstant;
-        }
-
-        /**
-         * Gets the instant that this property belongs to.
-         * 
-         * @return the partial instant
-         */
-        public DayOfWeek getDayOfWeek() {
-            return iInstant;
-        }
-
-        /**
-         * Gets the value of the field that the partial instant is set to.
-         * 
-         * @return the field value
-         */
-        public int get() {
-            return iInstant.iValue;
-        }
-
-        //-----------------------------------------------------------------------
-        /**
-         * Adds to the value of this field in a copy of this DayOfWeek.
-         * <p>
-         * The value will be added to this field. If the result is too large
-         * (more than 7) or too small (less than 1) then an exception is thrown.
-         * <p>
-         * The DayOfWeek attached to this property is unchanged by this call.
-         * Instead, a new instance is returned.
-         * 
-         * @param valueToAdd  the value to add to the field in the copy
-         * @return a copy of the DayOfWeek with the field value changed
-         * @throws IllegalArgumentException if the value isn't valid
-         */
-        public DayOfWeek addCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().add(iInstant, 0, newValues, valueToAdd);
-            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
-        }
-
-        /**
-         * Adds to the value of this field in a copy of this DayOfWeek wrapping
-         * within this field if the maximum value is reached.
-         * <p>
-         * The value will be added to this field. If the result is too large
-         * (more than 7) or too small (less than 1) then it will wrap.
-         * <p>
-         * The DayOfWeek attached to this property is unchanged by this call.
-         * Instead, a new instance is returned.
-         * 
-         * @param valueToAdd  the value to add to the field in the copy
-         * @return a copy of the DayOfWeek with the field value changed
-         * @throws IllegalArgumentException if the value isn't valid
-         */
-        public DayOfWeek addInFieldCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().addInField(iInstant, 0, newValues, valueToAdd);
-            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
-        }
-
-        //-----------------------------------------------------------------------
-        /**
-         * Sets this field in a copy of the DayOfWeek.
-         * <p>
-         * The DayOfWeek attached to this property is unchanged by this call.
-         * Instead, a new instance is returned.
-         * 
-         * @param value  the value to set the field in the copy to
-         * @return a copy of the DayOfWeek with the field value changed
-         * @throws IllegalArgumentException if the value isn't valid
-         */
-        public DayOfWeek setCopy(int value) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, 0, newValues, value);
-            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
-        }
-
-        /**
-         * Sets this field in a copy of the DayOfWeek to a parsed text value.
-         * <p>
-         * The DayOfWeek attached to this property is unchanged by this call.
-         * Instead, a new instance is returned.
-         * 
-         * @param text  the text value to set
-         * @param locale  optional locale to use for selecting a text symbol
-         * @return a copy of the DayOfWeek with the field value changed
-         * @throws IllegalArgumentException if the text value isn't valid
-         */
-        public DayOfWeek setCopy(String text, Locale locale) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, 0, newValues, text, locale);
-            return DayOfWeek.getInstance(newValues[0], iInstant.getChronology());
-        }
-
-        /**
-         * Sets this field in a copy of the DayOfWeek to a parsed text value.
-         * <p>
-         * The DayOfWeek attached to this property is unchanged by this call.
-         * Instead, a new instance is returned.
-         * 
-         * @param text  the text value to set
-         * @return a copy of the DayOfWeek with the field value changed
-         * @throws IllegalArgumentException if the text value isn't valid
-         */
-        public DayOfWeek setCopy(String text) {
-            return setCopy(text, null);
-        }
-    }
-
-}

From 58ebc40ac4ce4fba5c838968936d7f130dde2141 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 20:03:34 +0000
Subject: [PATCH 0092/1934] Rename PartialInstant to ReadablePartial

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@242 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/Chronology.java    |   4 +-
 .../src/java/org/joda/time/DateTimeField.java |  26 +--
 .../joda/time/chrono/AbstractChronology.java  |   4 +-
 .../chrono/CopticDayOfMonthDateTimeField.java |   6 +-
 .../chrono/GJDayOfMonthDateTimeField.java     |   6 +-
 .../time/chrono/GJDayOfYearDateTimeField.java |   6 +-
 .../chrono/GJWeekOfWeekyearDateTimeField.java |   6 +-
 .../time/chrono/GJYearOfEraDateTimeField.java |   4 +-
 .../chrono/ISOYearOfEraDateTimeField.java     |   4 +-
 .../joda/time/field/BaseDateTimeField.java    |  22 +--
 .../time/field/DelegatedDateTimeField.java    |  26 +--
 .../joda/time/field/NonZeroDateTimeField.java |  12 +-
 .../time/field/UnsupportedDateTimeField.java  |  22 +--
 JodaTime/src/java/org/joda/time/package.html  |   5 -
 ...rtialInstant.java => AbstractPartial.java} | 152 +++++++++---------
 .../partial/AbstractPartialFieldProperty.java |  16 +-
 ...rtialInstant.java => ReadablePartial.java} |  81 +++++++---
 .../java/org/joda/time/partial/TimeOfDay.java | 115 ++++---------
 .../org/joda/time/partial/YearMonthDay.java   |  60 +++----
 .../java/org/joda/time/partial/package.html   |  82 ++++++++++
 ...ckPartialInstant.java => MockPartial.java} |   7 +-
 .../org/joda/time/partial/TestTimeOfDay.java  |  20 +--
 .../joda/time/partial/TestYearMonthDay.java   |  16 +-
 23 files changed, 381 insertions(+), 321 deletions(-)
 rename JodaTime/src/java/org/joda/time/partial/{AbstractPartialInstant.java => AbstractPartial.java} (78%)
 rename JodaTime/src/java/org/joda/time/partial/{PartialInstant.java => ReadablePartial.java} (71%)
 create mode 100644 JodaTime/src/java/org/joda/time/partial/package.html
 rename JodaTime/src/test/org/joda/time/partial/{MockPartialInstant.java => MockPartial.java} (93%)

diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index dd3a9ca77..5f44b5fd7 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -53,7 +53,7 @@
  */
 package org.joda.time;
 
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Chronology provides access to the individual date time fields for a
@@ -239,7 +239,7 @@ long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @param instant  the partial instant to validate
      * @throws IllegalArgumentException if the instant is invalid
      */
-    void validate(PartialInstant instant);
+    void validate(ReadablePartial instant);
 
     // Millis
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 4bc678304..980d1b971 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -55,7 +55,7 @@
 
 import java.util.Locale;
 
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Defines the calculation engine for date and time fields.
@@ -138,7 +138,7 @@ public String getAsText(long instant) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public abstract String getAsText(PartialInstant partial, int fieldValue, Locale locale);
+    public abstract String getAsText(ReadablePartial partial, int fieldValue, Locale locale);
 
     /**
      * Get the human-readable, text value of this field from a partial instant.
@@ -148,7 +148,7 @@ public String getAsText(long instant) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsText(PartialInstant partial, Locale locale) {
+    public String getAsText(ReadablePartial partial, Locale locale) {
         return getAsText(partial, partial.get(this), locale);
     }
 
@@ -182,7 +182,7 @@ public String getAsShortText(long instant) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public abstract String getAsShortText(PartialInstant partial, int fieldValue, Locale locale);
+    public abstract String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale);
 
     /**
      * Get the human-readable, short text value of this field from a partial instant.
@@ -192,7 +192,7 @@ public String getAsShortText(long instant) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsShortText(PartialInstant partial, Locale locale) {
+    public String getAsShortText(ReadablePartial partial, Locale locale) {
         return getAsShortText(partial, partial.get(this), locale);
     }
 
@@ -258,7 +258,7 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
      */
-    public abstract int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);
+    public abstract int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -307,7 +307,7 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public abstract int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);
+    public abstract int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -387,7 +387,7 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue);
+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text value.
@@ -423,7 +423,7 @@ public String getAsShortText(PartialInstant partial, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale);
+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text value.
@@ -507,7 +507,7 @@ public long set(long instant, String text) {
      * @param instant  the partial instant to query
      * @return the minimum value for this field, in the units of the field
      */
-    public abstract int getMinimumValue(PartialInstant instant);
+    public abstract int getMinimumValue(ReadablePartial instant);
 
     /**
      * Get the minimum value for this field using the partial instant and
@@ -517,7 +517,7 @@ public long set(long instant, String text) {
      * @param values  the values to use
      * @return the minimum value for this field, in the units of the field
      */
-    public abstract int getMinimumValue(PartialInstant instant, int[] values);
+    public abstract int getMinimumValue(ReadablePartial instant, int[] values);
 
     /**
      * Get the maximum allowable value for this field.
@@ -541,7 +541,7 @@ public long set(long instant, String text) {
      * @param instant  the partial instant to query
      * @return the maximum value for this field, in the units of the field
      */
-    public abstract int getMaximumValue(PartialInstant instant);
+    public abstract int getMaximumValue(ReadablePartial instant);
 
     /**
      * Get the maximum value for this field using the partial instant and
@@ -551,7 +551,7 @@ public long set(long instant, String text) {
      * @param values  the values to use
      * @return the maximum value for this field, in the units of the field
      */
-    public abstract int getMaximumValue(PartialInstant instant, int[] values);
+    public abstract int getMaximumValue(ReadablePartial instant, int[] values);
 
     /**
      * Get the maximum text value for this field.
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
index 2e11cd330..0647d7005 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
@@ -61,7 +61,7 @@
 import org.joda.time.DurationField;
 import org.joda.time.field.UnsupportedDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * AbstractChronology provides a skeleton implementation for chronology
@@ -281,7 +281,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @param instant  the partial instant to validate
      * @throws IllegalArgumentException if the instant is invalid
      */
-    public void validate(PartialInstant instant) {
+    public void validate(ReadablePartial instant) {
         DateTimeField[] fields = instant.getFields();
         int[] values = instant.getValues();
         for (int i = 0; i < fields.length; i++) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
index e03dd4448..76273e686 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
@@ -56,7 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -101,7 +101,7 @@ public int getMaximumValue(long instant) {
 		return iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;
     }
 
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         if (instant.isSupported(iChronology.monthOfYear())) {
             int month = instant.get(iChronology.monthOfYear());
             if (month <= 12) {
@@ -116,7 +116,7 @@ public int getMaximumValue(PartialInstant instant) {
         return 30;
     }
 
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         DateTimeField[] fields = instant.getFields();
         for (int i = 0; i < fields.length; i++) {
             if (fields[i] == iChronology.monthOfYear()) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
index 613ed84de..7507b4c1b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
@@ -56,7 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -108,7 +108,7 @@ public int getMaximumValue(long instant) {
         return iChronology.getDaysInYearMonth(thisYear, thisMonth);
     }
 
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         if (instant.isSupported(iChronology.monthOfYear())) {
             int month = instant.get(iChronology.monthOfYear());
             if (instant.isSupported(iChronology.year())) {
@@ -120,7 +120,7 @@ public int getMaximumValue(PartialInstant instant) {
         return 31;
     }
 
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         DateTimeField[] fields = instant.getFields();
         for (int i = 0; i < fields.length; i++) {
             if (fields[i] == iChronology.monthOfYear()) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
index 36e93e53a..752361d6c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
@@ -56,7 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Provides time calculations for the day of the year component of time.
@@ -107,7 +107,7 @@ public int getMaximumValue(long instant) {
         return iChronology.getDaysInYear(year);
     }
 
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         if (instant.isSupported(iChronology.year())) {
             int year = instant.get(iChronology.year());
             return iChronology.getDaysInYear(year);
@@ -115,7 +115,7 @@ public int getMaximumValue(PartialInstant instant) {
         return 366;
     }
 
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         DateTimeField[] fields = instant.getFields();
         for (int i = 0; i < fields.length; i++) {
             if (fields[i] == iChronology.year()) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
index ff55f2b84..336fcce56 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
@@ -57,7 +57,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Provides time calculations for the week of a week based year component of time.
@@ -127,7 +127,7 @@ public int getMaximumValue(long instant) {
         return iChronology.getWeeksInYear(weekyear);
     }
 
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         if (instant.isSupported(iChronology.weekyear())) {
             int weekyear = instant.get(iChronology.weekyear());
             return iChronology.getWeeksInYear(weekyear);
@@ -135,7 +135,7 @@ public int getMaximumValue(PartialInstant instant) {
         return 53;
     }
 
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         DateTimeField[] fields = instant.getFields();
         for (int i = 0; i < fields.length; i++) {
             if (fields[i] == iChronology.weekyear()) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index c166ea453..bc3df81de 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -56,7 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Provides time calculations for the year of era component of time.
@@ -97,7 +97,7 @@ public long addWrapped(long instant, int years) {
         return getWrappedField().addWrapped(instant, years);
     }
 
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
         return getWrappedField().addInField(instant, fieldIndex, values, years);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
index 6c11eaa3f..686f2fcf4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
@@ -56,7 +56,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * This field is not publicy exposed by ISOChronology, but rather it is used to
@@ -99,7 +99,7 @@ public long addWrapped(long instant, int years) {
         return getWrappedField().addWrapped(instant, years);
     }
 
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
         return getWrappedField().addInField(instant, fieldIndex, values, years);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 163c2c54a..b26cc3e92 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -58,7 +58,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * BaseDateTimeField provides the common behaviour for DateTimeField
@@ -142,7 +142,7 @@ public String getAsText(long instant, Locale locale) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {
         return getAsText(fieldValue, locale);
     }
 
@@ -189,7 +189,7 @@ public String getAsShortText(long instant, Locale locale) {
      * @param locale  the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {
         return getAsShortText(fieldValue, locale);
     }
 
@@ -277,7 +277,7 @@ public long add(long instant, long value) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
      */
-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         if (valueToAdd == 0) {
             return values;
         }
@@ -388,7 +388,7 @@ public long addWrapped(long instant, int value) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         int current = values[fieldIndex];
         int wrapped = FieldUtils.getWrappedValue
             (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
@@ -478,7 +478,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @return the updated values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {
         FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));
         values[fieldIndex] = newValue;
         
@@ -533,7 +533,7 @@ public long set(long instant, String text, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {
         int value = convertText(text, locale);
         return set(instant, fieldIndex, values, value);
     }
@@ -637,7 +637,7 @@ public int getMinimumValue(long instant) {
      * @param instant  the partial instant to query
      * @return the minimum value for this field, in the units of the field
      */
-    public int getMinimumValue(PartialInstant instant) {
+    public int getMinimumValue(ReadablePartial instant) {
         return getMinimumValue();
     }
 
@@ -651,7 +651,7 @@ public int getMinimumValue(PartialInstant instant) {
      * @param values  the values to use
      * @return the minimum value for this field, in the units of the field
      */
-    public int getMinimumValue(PartialInstant instant, int[] values) {
+    public int getMinimumValue(ReadablePartial instant, int[] values) {
         return getMinimumValue(instant);
     }
 
@@ -683,7 +683,7 @@ public int getMaximumValue(long instant) {
      * @param instant  the partial instant to query
      * @return the maximum value for this field, in the units of the field
      */
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         return getMaximumValue();
     }
 
@@ -697,7 +697,7 @@ public int getMaximumValue(PartialInstant instant) {
      * @param values  the values to use
      * @return the maximum value for this field, in the units of the field
      */
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         return getMaximumValue(instant);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 422fcdcef..473c8384f 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -57,7 +57,7 @@
 import java.util.Locale;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * <code>DelegatedDateTimeField</code> delegates each method call to the
@@ -137,11 +137,11 @@ public String getAsText(long instant) {
         return iField.getAsText(instant);
     }
 
-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {
         return iField.getAsText(partial, fieldValue, locale);
     }
 
-    public String getAsText(PartialInstant partial, Locale locale) {
+    public String getAsText(ReadablePartial partial, Locale locale) {
         return iField.getAsText(partial, locale);
     }
 
@@ -153,11 +153,11 @@ public String getAsShortText(long instant) {
         return iField.getAsShortText(instant);
     }
 
-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {
         return iField.getAsShortText(partial, fieldValue, locale);
     }
 
-    public String getAsShortText(PartialInstant partial, Locale locale) {
+    public String getAsShortText(ReadablePartial partial, Locale locale) {
         return iField.getAsShortText(partial, locale);
     }
 
@@ -169,7 +169,7 @@ public long add(long instant, long value) {
         return iField.add(instant, value);
     }
 
-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         return iField.add(instant, fieldIndex, values, valueToAdd);
     }
 
@@ -177,7 +177,7 @@ public long addWrapped(long instant, int value) {
         return iField.addWrapped(instant, value);
     }
 
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         return iField.addInField(instant, fieldIndex, values, valueToAdd);
     }
 
@@ -201,11 +201,11 @@ public long set(long instant, String text) {
         return iField.set(instant, text);
     }
 
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {
         return iField.set(instant, fieldIndex, values, newValue);
     }
 
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {
         return iField.set(instant, fieldIndex, values, text, locale);
     }
 
@@ -237,11 +237,11 @@ public int getMinimumValue(long instant) {
         return iField.getMinimumValue(instant);
     }
 
-    public int getMinimumValue(PartialInstant instant) {
+    public int getMinimumValue(ReadablePartial instant) {
         return iField.getMinimumValue(instant);
     }
 
-    public int getMinimumValue(PartialInstant instant, int[] values) {
+    public int getMinimumValue(ReadablePartial instant, int[] values) {
         return iField.getMinimumValue(instant, values);
     }
 
@@ -253,11 +253,11 @@ public int getMaximumValue(long instant) {
         return iField.getMaximumValue(instant);
     }
 
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         return iField.getMaximumValue(instant);
     }
 
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         return iField.getMaximumValue(instant, values);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index a209e3e4b..d49f0083e 100644
--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -55,7 +55,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Wraps another field such that zero values are replaced with one more than
@@ -102,7 +102,7 @@ public long addWrapped(long instant, int value) {
         return getWrappedField().addWrapped(instant, value);
     }
 
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         return getWrappedField().addInField(instant, fieldIndex, values, valueToAdd);
     }
 
@@ -158,7 +158,7 @@ public int getMinimumValue(long instant) {
      * 
      * @return the minimum value of 1
      */
-    public int getMinimumValue(PartialInstant instant) {
+    public int getMinimumValue(ReadablePartial instant) {
         return 1;
     }
 
@@ -167,7 +167,7 @@ public int getMinimumValue(PartialInstant instant) {
      * 
      * @return the minimum value of 1
      */
-    public int getMinimumValue(PartialInstant instant, int[] values) {
+    public int getMinimumValue(ReadablePartial instant, int[] values) {
         return 1;
     }
 
@@ -197,7 +197,7 @@ public int getMaximumValue(long instant) {
      * 
      * @return the maximum value
      */
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         return getWrappedField().getMaximumValue(instant) + 1;
     }
 
@@ -207,7 +207,7 @@ public int getMaximumValue(PartialInstant instant) {
      * 
      * @return the maximum value
      */
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         return getWrappedField().getMaximumValue(instant, values) + 1;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index 5cb6f6d63..38e4cbaff 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -58,7 +58,7 @@
 import java.util.Locale;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.partial.PartialInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * A placeholder implementation to use when a datetime field is not supported.
@@ -162,7 +162,7 @@ public String getAsText(long instant, Locale locale) {
      *
      * @throws UnsupportedOperationException
      */
-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {
         throw unsupported();
     }
 
@@ -180,7 +180,7 @@ public String getAsShortText(long instant, Locale locale) {
      *
      * @throws UnsupportedOperationException
      */
-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {
+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {
         throw unsupported();
     }
 
@@ -207,7 +207,7 @@ public long add(long instant, long value) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         throw unsupported();
     }
 
@@ -225,7 +225,7 @@ public long addWrapped(long instant, int value) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         throw unsupported();
     }
 
@@ -261,7 +261,7 @@ public long set(long instant, int value) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {
         throw unsupported();
     }
 
@@ -279,7 +279,7 @@ public long set(long instant, String text, Locale locale) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {
         throw unsupported();
     }
 
@@ -352,7 +352,7 @@ public int getMinimumValue(long instant) {
      *
      * @throws UnsupportedOperationException
      */
-    public int getMinimumValue(PartialInstant instant) {
+    public int getMinimumValue(ReadablePartial instant) {
         throw unsupported();
     }
 
@@ -361,7 +361,7 @@ public int getMinimumValue(PartialInstant instant) {
      *
      * @throws UnsupportedOperationException
      */
-    public int getMinimumValue(PartialInstant instant, int[] values) {
+    public int getMinimumValue(ReadablePartial instant, int[] values) {
         throw unsupported();
     }
 
@@ -388,7 +388,7 @@ public int getMaximumValue(long instant) {
      *
      * @throws UnsupportedOperationException
      */
-    public int getMaximumValue(PartialInstant instant) {
+    public int getMaximumValue(ReadablePartial instant) {
         throw unsupported();
     }
 
@@ -397,7 +397,7 @@ public int getMaximumValue(PartialInstant instant) {
      *
      * @throws UnsupportedOperationException
      */
-    public int getMaximumValue(PartialInstant instant, int[] values) {
+    public int getMaximumValue(ReadablePartial instant, int[] values) {
         throw unsupported();
     }
 
diff --git a/JodaTime/src/java/org/joda/time/package.html b/JodaTime/src/java/org/joda/time/package.html
index faab2ad5d..628b764e7 100644
--- a/JodaTime/src/java/org/joda/time/package.html
+++ b/JodaTime/src/java/org/joda/time/package.html
@@ -126,11 +126,6 @@ <h4>Implementations</h4>
 modified, so the "danger" posed is small.)
 </p>
 <p>
-In addition to the datetime classes, there are date and time only classes, 
-<code>DateOnly</code> and <code>TimeOnly</code>. These have similar subclasses 
-to <code>DateTime</code>.
-</p>
-<p>
 The concrete implementations of the <code>ReadWritable...</code> interfaces are
 named the same as their immutable counterparts, but with a "Mutable"
 prefix. For example, <code>MutableDateTime</code> implements
diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
similarity index 78%
rename from JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
rename to JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
index 87f940150..1e7172b0c 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
@@ -70,45 +70,45 @@
 import org.joda.time.convert.InstantConverter;
 
 /**
- * AbstractPartialInstant provides a standard base implementation of most methods
- * in the PartialInstant interface.
+ * AbstractPartial provides a standard base implementation of most methods
+ * in the ReadablePartial interface.
  * <p>
  * Calculations on are performed using a {@link Chronology}.
  * This chronology is set to be in the UTC time zone for all calculations.
  * <p>
- * AbstractPartialInstant allows subclasses may be mutable and not thread-safe.
+ * AbstractPartial allows subclasses may be mutable and not thread-safe.
  *
  * @author Stephen Colebourne
  * @since 1.0
  */
-public abstract class AbstractPartialInstant implements PartialInstant, Serializable {
+public abstract class AbstractPartial implements ReadablePartial, Serializable {
 
     /** Serialization version */
     private static final long serialVersionUID = 2353678632973660L;
 
     /** The chronology in use */
     protected Chronology iChronology;
-    /** The values of each field in this partial instant */
+    /** The values of each field in this partial */
     protected int[] iValues;
-    /** The values of each field in this partial instant */
+    /** The values of each field in this partial */
     protected transient DateTimeField[] iFields;
 
     // Constructors
     //-----------------------------------------------------------------------
     /**
-     * Constructs a AbstractPartialInstant with the current time, using ISOChronology in
+     * Constructs a AbstractPartial with the current time, using ISOChronology in
      * the default zone to extract the fields.
      * <p>
      * The constructor uses the default time zone, resulting in the local time
      * being initialised. Once the constructor is complete, all further calculations
      * are performed without reference to a timezone (by switching to UTC).
      */
-    public AbstractPartialInstant() {
+    public AbstractPartial() {
         this(DateTimeUtils.currentTimeMillis(), null);
     }
 
     /**
-     * Constructs a AbstractPartialInstant with the current time, using the specified chronology
+     * Constructs a AbstractPartial with the current time, using the specified chronology
      * and zone to extract the fields.
      * <p>
      * The constructor uses the time zone of the chronology specified.
@@ -117,12 +117,12 @@ public AbstractPartialInstant() {
      *
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
-    public AbstractPartialInstant(Chronology chronology) {
+    public AbstractPartial(Chronology chronology) {
         this(DateTimeUtils.currentTimeMillis(), chronology);
     }
 
     /**
-     * Constructs a AbstractPartialInstant extracting the partial fields from the specified
+     * Constructs a AbstractPartial extracting the partial fields from the specified
      * milliseconds using the ISOChronology in the default zone.
      * <p>
      * The constructor uses the default time zone, resulting in the local time
@@ -131,12 +131,12 @@ public AbstractPartialInstant(Chronology chronology) {
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
-    public AbstractPartialInstant(long instant) {
+    public AbstractPartial(long instant) {
         this(instant, null);
     }
 
     /**
-     * Constructs a AbstractPartialInstant extracting the partial fields from the specified
+     * Constructs a AbstractPartial extracting the partial fields from the specified
      * milliseconds using the chronology provided.
      * <p>
      * The constructor uses the time zone of the chronology specified.
@@ -146,7 +146,7 @@ public AbstractPartialInstant(long instant) {
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
-    public AbstractPartialInstant(long instant, Chronology chronology) {
+    public AbstractPartial(long instant, Chronology chronology) {
         super();
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
@@ -157,7 +157,7 @@ public AbstractPartialInstant(long instant, Chronology chronology) {
     }
 
     /**
-     * Constructs a AbstractPartialInstant from an Object that represents a time.
+     * Constructs a AbstractPartial from an Object that represents a time.
      * <p>
      * The recognised object types are defined in
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
@@ -166,20 +166,21 @@ public AbstractPartialInstant(long instant, Chronology chronology) {
      * @param instant  the datetime object, must not be null
      * @throws IllegalArgumentException if the date is null
      */
-    public AbstractPartialInstant(Object instant) {
+    public AbstractPartial(Object instant) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        long millis = converter.getInstantMillis(instant);
         Chronology chronology = converter.getChronology(instant);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
         iChronology = chronology.withUTC();
         iFields = initFields(iChronology);
-        iValues = initValues(converter.getInstantMillis(instant), chronology);
+        iValues = initValues(millis, chronology);
     }
 
     /**
-     * Constructs a AbstractPartialInstant from an Object that represents a time, using the
+     * Constructs a AbstractPartial from an Object that represents a time, using the
      * specified chronology.
      * <p>
      * The recognised object types are defined in
@@ -194,20 +195,21 @@ public AbstractPartialInstant(Object instant) {
      * @param chronology  the chronology, null means ISOChronology
      * @throws IllegalArgumentException if the date is null
      */
-    public AbstractPartialInstant(Object instant, Chronology chronology) {
+    public AbstractPartial(Object instant, Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        long millis = converter.getInstantMillis(instant, chronology);
         chronology = converter.getChronology(instant, chronology);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
         iChronology = chronology.withUTC();
         iFields = initFields(iChronology);
-        iValues = initValues(converter.getInstantMillis(instant, chronology), chronology);
+        iValues = initValues(millis, chronology);
     }
 
     /**
-     * Constructs a AbstractPartialInstant with specified time field values and chronology.
+     * Constructs a AbstractPartial with specified time field values and chronology.
      * <p>
      * The constructor uses the time zone of the chronology specified.
      * Once the constructor is complete, all further calculations are performed
@@ -216,7 +218,7 @@ public AbstractPartialInstant(Object instant, Chronology chronology) {
      * @param values  the new set of values
      * @param chronology  the chronology, null means ISOChronology in the default zone
      */
-    public AbstractPartialInstant(int[] values, Chronology chronology) {
+    public AbstractPartial(int[] values, Chronology chronology) {
         super();
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
@@ -257,7 +259,7 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the number of fields in this instant.
+     * Gets the number of fields in this partial.
      * 
      * @return the field count
      */
@@ -295,7 +297,7 @@ public int getValue(int index) {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets an array of the fields that this partial instant supports.
+     * Gets an array of the fields that this partial supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      *
@@ -306,7 +308,7 @@ public int getValue(int index) {
     }
 
     /**
-     * Gets an array of the value of each of the fields that this partial instant supports.
+     * Gets an array of the value of each of the fields that this partial supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      * Each value corresponds to the same array index as <code>getFields()</code>
@@ -333,7 +335,7 @@ public Chronology getChronology() {
     /**
      * Get the value of one of the fields of a datetime.
      * <p>
-     * The field specified must be one of those that is supported by the partial instant.
+     * The field specified must be one of those that is supported by the partial.
      *
      * @param field  a DateTimeField instance that is supported by this partial
      * @return the value of that field
@@ -349,7 +351,7 @@ public int get(DateTimeField field) {
     }
 
     /**
-     * Checks whether the field specified is supported by this partial instant.
+     * Checks whether the field specified is supported by this partial.
      *
      * @param field  the field to check, may be null which returns false
      * @return true if the field is supported
@@ -365,39 +367,20 @@ public boolean isSupported(DateTimeField field) {
 
     //-----------------------------------------------------------------------
     /**
-     * Resolves this partial against another complete instant to create a new
-     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.
+     * Resolves this partial against another complete millisecond instant to
+     * create a new full instant specifying the time zone to resolve with.
      * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
+     * For example, if this partial represents a time, then the result of this
+     * method will be the datetime from the specified base instant plus the
+     * time from this partial set using the time zone specified.
      *
-     * @param baseMillis  source of missing fields
-     * @param zone  the zone to use, null means default
+     * @param baseInstant  source of missing fields
+     * @param zone  the time zone to use, null means default
      * @return the combined instant in milliseconds
      */
-    public long resolve(long baseMillis, DateTimeZone zone) {
+    public long resolve(long baseInstant, DateTimeZone zone) {
         Chronology chrono = iChronology.withZone(zone);
-        return resolve(baseMillis, chrono);
-    }
-
-    /**
-     * Resolves this partial into another complete instant setting the relevant fields
-     * on the writable instant. The combination is performed using the chronology of the
-     * specified instant.
-     * <p>
-     * For example, if this partial represents a time, then the input writable instant
-     * will be updated with the time from this instant.
-     *
-     * @param base  the instant to set into, must not be null
-     * @throws IllegalArgumentException if the base instant is null
-     */
-    public void resolveInto(ReadWritableInstant base) {
-        if (base == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        Chronology chrono = base.getChronology();
-        long resolved = resolve(base.getMillis(), chrono);
-        base.setMillis(resolved);
+        return resolve(baseInstant, chrono);
     }
 
     /**
@@ -405,34 +388,55 @@ public void resolveInto(ReadWritableInstant base) {
      * full instant. The combination is performed using the chronology of the
      * specified instant.
      * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
+     * For example, if this partial represents a time, then the result of this
+     * method will be the datetime from the specified base instant plus the
+     * time from this partial.
      *
-     * @param base  the instant that provides the missing fields, null means now
+     * @param baseInstant  the instant that provides the missing fields, null means now
      * @return the combined datetime
      */
-    public DateTime resolveDateTime(ReadableInstant base) {
+    public DateTime resolveDateTime(ReadableInstant baseInstant) {
         long resolved;
         Chronology chrono;
-        if (base == null) {
+        if (baseInstant == null) {
             chrono = ISOChronology.getInstance();
             resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);
         } else {
-            chrono = base.getChronology();
-            resolved = resolve(base.getMillis(), chrono);
+            chrono = baseInstant.getChronology();
+            resolved = resolve(baseInstant.getMillis(), chrono);
         }
         return new DateTime(resolved, chrono);
     }
 
     /**
-     * Resolve this partial instant into the base millis using the specified chronology.
+     * Resolves this partial into another complete instant setting the relevant
+     * fields on the writable instant. The combination is performed using the
+     * chronology of the specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the input writable
+     * instant will be updated with the time from this partial.
+     *
+     * @param baseInstant  the instant to set into, must not be null
+     * @throws IllegalArgumentException if the base instant is null
+     */
+    public void resolveInto(ReadWritableInstant baseInstant) {
+        if (baseInstant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        Chronology chrono = baseInstant.getChronology();
+        long resolved = resolve(baseInstant.getMillis(), chrono);
+        baseInstant.setMillis(resolved);
+    }
+
+    /**
+     * Resolve this partial into the base millis using the specified chronology.
      * 
-     * @param baseMillis  the base millis
+     * @param baseInstant  the base millisecond instant
      * @param chrono  the chronology
      * @return the new resolved millis
      */
-    protected long resolve(long baseMillis, Chronology chrono) {
-        long millis = baseMillis;
+    protected long resolve(long baseInstant, Chronology chrono) {
+        long millis = baseInstant;
         for (int i = 0; i < iFields.length; i++) {
             millis = iFields[i].set(millis, iValues[i]);
         }
@@ -441,20 +445,20 @@ protected long resolve(long baseMillis, Chronology chrono) {
 
     //-----------------------------------------------------------------------
     /**
-     * Compares this PartialInstant with another returning true if the chronology,
+     * Compares this ReadablePartial with another returning true if the chronology,
      * fields and values are equal.
      *
-     * @param instant  an object to check against
+     * @param partial  an object to check against
      * @return true if fields and values are equal
      */
-    public boolean equals(Object instant) {
-        if (instant instanceof AbstractPartialInstant) {
-            AbstractPartialInstant other = (AbstractPartialInstant) instant;
+    public boolean equals(Object partial) {
+        if (partial instanceof AbstractPartial) {
+            AbstractPartial other = (AbstractPartial) partial;
             return Arrays.equals(iValues, other.iValues) &&
                    Arrays.equals(iFields, other.iFields) &&
                    iChronology == other.iChronology;
-        } else if (instant instanceof PartialInstant) {
-            PartialInstant other = (PartialInstant) instant;
+        } else if (partial instanceof ReadablePartial) {
+            ReadablePartial other = (ReadablePartial) partial;
             return Arrays.equals(iValues, other.getValues()) &&
                    Arrays.equals(iFields, other.getFields()) &&
                    iChronology == other.getChronology();
@@ -463,7 +467,7 @@ public boolean equals(Object instant) {
     }
 
     /**
-     * Gets a hash code for the PartialInstant that is compatible with the 
+     * Gets a hash code for the ReadablePartial that is compatible with the 
      * equals method.
      *
      * @return a suitable hash code
diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
index 85335b893..56bd01e11 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java
@@ -61,7 +61,7 @@
 
 /**
  * AbstractPartialFieldProperty is a base class for binding a
- * PartialInstant to a DateTimeField.
+ * ReadablePartial to a DateTimeField.
  * <p>
  * It allows the date and time manipulation code to be field based yet
  * still easy to use.
@@ -101,7 +101,7 @@ public String getName() {
      * 
      * @return the partial instant
      */
-    public abstract PartialInstant getPartialInstant();
+    public abstract ReadablePartial getReadablePartial();
 
     //-----------------------------------------------------------------------
     /**
@@ -119,7 +119,7 @@ public String getName() {
      * @see DateTimeField#getAsText
      */
     public String getAsText(Locale locale) {
-        return getField().getAsText(getPartialInstant(), get(), locale);
+        return getField().getAsText(getReadablePartial(), get(), locale);
     }
 
     /**
@@ -140,7 +140,7 @@ public String getAsText() {
      * @see DateTimeField#getAsShortText
      */
     public String getAsShortText(Locale locale) {
-        return getField().getAsShortText(getPartialInstant(), get(), locale);
+        return getField().getAsShortText(getReadablePartial(), get(), locale);
     }
 
     /**
@@ -192,7 +192,7 @@ public int getMinimumValueOverall() {
      * @see DateTimeField#getMinimumValue
      */
     public int getMinimumValue() {
-        return getField().getMinimumValue(getPartialInstant());
+        return getField().getMinimumValue(getReadablePartial());
     }
 
     /**
@@ -212,7 +212,7 @@ public int getMaximumValueOverall() {
      * @see DateTimeField#getMaximumValue
      */
     public int getMaximumValue() {
-        return getField().getMaximumValue(getPartialInstant());
+        return getField().getMaximumValue(getReadablePartial());
     }
 
     //-----------------------------------------------------------------------
@@ -269,7 +269,7 @@ public int compareTo(ReadableInstant instant) {
      * Compare this field to the same field on another partial instant.
      * <p>
      * The {@link #get()} method is used to obtain the value to compare for
-     * this instant and the {@link PartialInstant#get(DateTimeField)} method
+     * this instant and the {@link ReadablePartial#get(DateTimeField)} method
      * is used for the specified instant.
      * 
      * @param instant  the instant to compare to
@@ -278,7 +278,7 @@ public int compareTo(ReadableInstant instant) {
      * @throws IllegalArgumentException if the field of this property cannot be queried
      *  on the specified instant
      */
-    public int compareTo(PartialInstant instant) {
+    public int compareTo(ReadablePartial instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
diff --git a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java b/JodaTime/src/java/org/joda/time/partial/ReadablePartial.java
similarity index 71%
rename from JodaTime/src/java/org/joda/time/partial/PartialInstant.java
rename to JodaTime/src/java/org/joda/time/partial/ReadablePartial.java
index c7af3c0cb..ab4e37b18 100644
--- a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/partial/ReadablePartial.java
@@ -57,21 +57,26 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
 
 /**
- * Defines an instant that does not support every datetime field.
+ * Defines an partial time that does not support every datetime field.
  * <p>
- * A PartialInstant supports a set of fields and cannot be compared to a
- * full complete instant. Methods are provided to resolve the partial instant
- * into a full instant by 'filling in the gaps'.
+ * A <code>ReadablePartial</code> supports a set of fields which be be a
+ * subset of those on the chronology.
+ * A <code>ReadablePartial</code> cannot be compared to a <code>ReadableInstant</code>.
+ * <p>
+ * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>
+ * using one of the <code>resolve</code> methods. These work by providing a full base
+ * instant that can be used to 'fill in the gaps'.
  *
  * @author Stephen Colebourne
  */
-public interface PartialInstant {
+public interface ReadablePartial {
 
     /**
-     * Gets the number of fields that this instant supports.
+     * Gets the number of fields that this partial supports.
      *
      * @return the number of fields supported
      */
@@ -87,7 +92,7 @@
     DateTimeField getField(int index);
 
     /**
-     * Gets an array of the fields that this partial instant supports.
+     * Gets an array of the fields that this partial supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      *
@@ -105,7 +110,7 @@
     int getValue(int index);
 
     /**
-     * Gets an array of the value of each of the fields that this partial instant supports.
+     * Gets an array of the value of each of the fields that this partial supports.
      * <p>
      * The fields are returned largest to smallest, for example Hour, Minute, Second.
      * Each value corresponds to the same array index as <code>getFields()</code>
@@ -127,7 +132,7 @@
     /**
      * Get the value of one of the fields of a datetime.
      * <p>
-     * The field specified must be one of those that is supported by the partial instant.
+     * The field specified must be one of those that is supported by the partial.
      *
      * @param field  a DateTimeField instance that is supported by this partial
      * @return the value of that field
@@ -136,7 +141,7 @@
     int get(DateTimeField field);
 
     /**
-     * Checks whether the field specified is supported by this partial instant.
+     * Checks whether the field specified is supported by this partial.
      *
      * @param field  the field to check, may be null which returns false
      * @return true if the field is supported
@@ -147,44 +152,70 @@
      * Resolves this partial against another complete millisecond instant to
      * create a new full instant specifying the time zone to resolve with.
      * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the datetime from the specified base plus the time from this instant
-     * set using the time zone specified.
+     * For example, if this partial represents a time, then the result of this
+     * method will be the datetime from the specified base instant plus the
+     * time from this partial set using the time zone specified.
      *
-     * @param baseMillis  source of missing fields
+     * @param baseInstant  source of missing fields
+     * @param zone  the time zone to use, null means default
      * @return the combined instant in milliseconds
      */
-    long resolve(long baseMillis, DateTimeZone zone);
+    long resolve(long baseInstant, DateTimeZone zone);
 
     /**
      * Resolves this partial against another complete instant to create a new
      * full instant. The combination is performed using the chronology of the
      * specified instant.
      * <p>
-     * For example, if this partial represents a time, then the result of this method
-     * will be the date from the specified base plus the time from this instant.
+     * For example, if this partial represents a time, then the result of this
+     * method will be the datetime from the specified base instant plus the
+     * time from this partial.
      *
-     * @param base  the instant that provides the missing fields, null means now
+     * @param baseInstant  the instant that provides the missing fields, null means now
      * @return the combined datetime
      */
-    DateTime resolveDateTime(ReadableInstant base);
+    DateTime resolveDateTime(ReadableInstant baseInstant);
+
+    /**
+     * Resolves this partial into another complete instant setting the relevant
+     * fields on the writable instant. The combination is performed using the
+     * chronology of the specified instant.
+     * <p>
+     * For example, if this partial represents a time, then the input writable
+     * instant will be updated with the time from this partial.
+     *
+     * @param baseInstant  the instant to set into, must not be null
+     * @throws IllegalArgumentException if the base instant is null
+     */
+    void resolveInto(ReadWritableInstant baseInstant);
 
     //-----------------------------------------------------------------------
     /**
      * Compares this partial with the specified object for equality based
-     * on the implementation class, supported fields, chronology and values.
+     * on the supported fields, chronology and values.
      * <p>
-     * Instances of PartialInstant are not generally comparable to one another
-     * as the comparison is based on the implementation class.
+     * Two instances of ReadablePartial are equal if they have the same
+     * chronology, same fields in same order and same values.
      *
-     * @param object  the object to compare to
+     * @param partial  the object to compare to
      * @return true if equal
      */
-    boolean equals(Object object);
+    boolean equals(Object partial);
 
     /**
-     * Gets a hash code for the instant that is compatible with the 
+     * Gets a hash code for the partial that is compatible with the 
      * equals method.
+     * <p>
+     * The formula used must be:
+     * <pre>
+     *  int total = 157;
+     *  for (int i = 0; i < fields.length; i++) {
+     *      total = 23 * total + values[i];
+     *      total = 23 * total + fields[i].hashCode();
+     *  }
+     *  total += chronology.hashCode();
+     *  return total;
+     * </pre>
      *
      * @return a suitable hash code
      */
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 2260e5c73..d4c87e65a 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -60,7 +60,7 @@
 import org.joda.time.DateTimeField;
 
 /**
- * TimeOfDay is an immutable partial instant supporting the hour, minute, second
+ * TimeOfDay is an immutable partial supporting the hour, minute, second
  * and millisecond fields.
  * <p>
  * Calculations on TimeOfDay are performed using a {@link Chronology}.
@@ -89,7 +89,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class TimeOfDay extends AbstractPartialInstant implements PartialInstant, Serializable {
+public final class TimeOfDay extends AbstractPartial implements ReadablePartial, Serializable {
 
     /** Serialization version */
     private static final long serialVersionUID = 3633353405803318660L;
@@ -413,21 +413,21 @@ public Property millisOfSecond() {
      */
     public static class Property extends AbstractPartialFieldProperty {
 
-        /** The instant */
-        private final TimeOfDay iInstant;
+        /** The partial */
+        private final TimeOfDay iTimeOfDay;
         /** The field index */
         private final int iFieldIndex;
 
         /**
          * Constructs a property.
          * 
-         * @param instant  the partial instant
+         * @param partial  the partial instance
          * @param field  the field
-         * @param fieldIndex  the index in the instant
+         * @param fieldIndex  the index in the partial
          */
-        Property(TimeOfDay instant, int fieldIndex) {
+        Property(TimeOfDay partial, int fieldIndex) {
             super();
-            iInstant = instant;
+            iTimeOfDay = partial;
             iFieldIndex = fieldIndex;
         }
 
@@ -437,34 +437,34 @@ public Property millisOfSecond() {
          * @return the field
          */
         public DateTimeField getField() {
-            return iInstant.getField(iFieldIndex);
+            return iTimeOfDay.getField(iFieldIndex);
         }
 
         /**
-         * Gets the instant that this property belongs to.
+         * Gets the partial that this property belongs to.
          * 
-         * @return the partial instant
+         * @return the partial
          */
-        public PartialInstant getPartialInstant() {
-            return iInstant;
+        public ReadablePartial getReadablePartial() {
+            return iTimeOfDay;
         }
 
         /**
-         * Gets the instant that this property belongs to.
+         * Gets the partial that this property belongs to.
          * 
-         * @return the partial instant
+         * @return the partial
          */
         public TimeOfDay getTimeOfDay() {
-            return iInstant;
+            return iTimeOfDay;
         }
 
         /**
-         * Gets the value of the field that the partial instant is set to.
+         * Gets the value of this field.
          * 
          * @return the field value
          */
         public int get() {
-            return iInstant.getValue(iFieldIndex);
+            return iTimeOfDay.getValue(iFieldIndex);
         }
 
         //-----------------------------------------------------------------------
@@ -486,9 +486,9 @@ public int get() {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public TimeOfDay addCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);
-            return new TimeOfDay(iInstant, newValues);
+            int[] newValues = iTimeOfDay.getValues();
+            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);
+            return new TimeOfDay(iTimeOfDay, newValues);
         }
 
         /**
@@ -510,9 +510,9 @@ public TimeOfDay addCopy(int valueToAdd) {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public TimeOfDay addInFieldCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);
-            return new TimeOfDay(iInstant, newValues);
+            int[] newValues = iTimeOfDay.getValues();
+            newValues = getField().addInField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);
+            return new TimeOfDay(iTimeOfDay, newValues);
         }
 
         //-----------------------------------------------------------------------
@@ -527,9 +527,9 @@ public TimeOfDay addInFieldCopy(int valueToAdd) {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public TimeOfDay setCopy(int value) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, iFieldIndex, newValues, value);
-            return new TimeOfDay(iInstant, newValues);
+            int[] newValues = iTimeOfDay.getValues();
+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);
+            return new TimeOfDay(iTimeOfDay, newValues);
         }
 
         /**
@@ -544,9 +544,9 @@ public TimeOfDay setCopy(int value) {
          * @throws IllegalArgumentException if the text value isn't valid
          */
         public TimeOfDay setCopy(String text, Locale locale) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, iFieldIndex, newValues, text, locale);
-            return new TimeOfDay(iInstant, newValues);
+            int[] newValues = iTimeOfDay.getValues();
+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);
+            return new TimeOfDay(iTimeOfDay, newValues);
         }
 
         /**
@@ -562,61 +562,6 @@ public TimeOfDay setCopy(String text, Locale locale) {
         public TimeOfDay setCopy(String text) {
             return setCopy(text, null);
         }
-
-// TODO
-//        //-----------------------------------------------------------------------
-//        /**
-//         * Rounds to the lowest whole unit of this field on a copy of this TimeOfDay.
-//         *
-//         * @return a copy of the TimeOfDay with the field value changed
-//         */
-//        public TimeOfDay roundFloorCopy() {
-//            TimeOfDay instant = iInstant;
-//            return (TimeOfDay) instant.withMillis(iField.roundFloor(instant.getMillis()));
-//        }
-//
-//        /**
-//         * Rounds to the highest whole unit of this field on a copy of this TimeOfDay.
-//         *
-//         * @return a copy of the TimeOfDay with the field value changed
-//         */
-//        public TimeOfDay roundCeilingCopy() {
-//            TimeOfDay instant = iInstant;
-//            return (TimeOfDay) instant.withMillis(iField.roundCeiling(instant.getMillis()));
-//        }
-//
-//        /**
-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,
-//         * favoring the floor if halfway.
-//         *
-//         * @return a copy of the TimeOfDay with the field value changed
-//         */
-//        public TimeOfDay roundHalfFloorCopy() {
-//            TimeOfDay instant = iInstant;
-//            return (TimeOfDay) instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
-//        }
-//
-//        /**
-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,
-//         * favoring the ceiling if halfway.
-//         *
-//         * @return a copy of the TimeOfDay with the field value changed
-//         */
-//        public TimeOfDay roundHalfCeilingCopy() {
-//            TimeOfDay instant = iInstant;
-//            return (TimeOfDay) instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
-//        }
-//
-//        /**
-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay.
-//         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
-//         *
-//         * @return a copy of the TimeOfDay with the field value changed
-//         */
-//        public TimeOfDay roundHalfEvenCopy() {
-//            TimeOfDay instant = iInstant;
-//            return (TimeOfDay) instant.withMillis(iField.roundHalfEven(instant.getMillis()));
-//        }
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
index 46370d663..84797b982 100644
--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
@@ -60,7 +60,7 @@
 import org.joda.time.DateTimeField;
 
 /**
- * YearMonthDay is an immutable partial instant supporting the year, monthOfYear
+ * YearMonthDay is an immutable partial supporting the year, monthOfYear
  * and dayOfMonth fields.
  * <p>
  * Calculations on YearMonthDay are performed using a {@link Chronology}.
@@ -88,7 +88,7 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public final class YearMonthDay extends AbstractPartialInstant implements PartialInstant, Serializable {
+public final class YearMonthDay extends AbstractPartial implements ReadablePartial, Serializable {
 
     /** Serialization version */
     private static final long serialVersionUID = 797544782896179L;
@@ -325,21 +325,21 @@ public Property dayOfMonth() {
      */
     public static class Property extends AbstractPartialFieldProperty {
 
-        /** The instant */
-        private final YearMonthDay iInstant;
+        /** The partial */
+        private final YearMonthDay iYearMonthDay;
         /** The field index */
         private final int iFieldIndex;
 
         /**
          * Constructs a property.
          * 
-         * @param instant  the partial instant
+         * @param partial  the partial instance
          * @param field  the field
-         * @param fieldIndex  the index in the instant
+         * @param fieldIndex  the index in the partial
          */
-        Property(YearMonthDay instant, int fieldIndex) {
+        Property(YearMonthDay partial, int fieldIndex) {
             super();
-            iInstant = instant;
+            iYearMonthDay = partial;
             iFieldIndex = fieldIndex;
         }
 
@@ -349,34 +349,34 @@ public Property dayOfMonth() {
          * @return the field
          */
         public DateTimeField getField() {
-            return iInstant.getField(iFieldIndex);
+            return iYearMonthDay.getField(iFieldIndex);
         }
 
         /**
-         * Gets the instant that this property belongs to.
+         * Gets the partial that this property belongs to.
          * 
-         * @return the partial instant
+         * @return the partial
          */
-        public PartialInstant getPartialInstant() {
-            return iInstant;
+        public ReadablePartial getReadablePartial() {
+            return iYearMonthDay;
         }
 
         /**
-         * Gets the instant that this property belongs to.
+         * Gets the partial that this property belongs to.
          * 
-         * @return the partial instant
+         * @return the partial
          */
         public YearMonthDay getYearMonthDay() {
-            return iInstant;
+            return iYearMonthDay;
         }
 
         /**
-         * Gets the value of the field that the partial instant is set to.
+         * Gets the value of this field.
          * 
          * @return the field value
          */
         public int get() {
-            return iInstant.getValue(iFieldIndex);
+            return iYearMonthDay.getValue(iFieldIndex);
         }
 
         //-----------------------------------------------------------------------
@@ -398,9 +398,9 @@ public int get() {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public YearMonthDay addCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);
-            return new YearMonthDay(iInstant, newValues);
+            int[] newValues = iYearMonthDay.getValues();
+            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);
+            return new YearMonthDay(iYearMonthDay, newValues);
         }
 
         /**
@@ -422,9 +422,9 @@ public YearMonthDay addCopy(int valueToAdd) {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public YearMonthDay addInFieldCopy(int valueToAdd) {
-            int[] newValues = iInstant.getValues();
-            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);
-            return new YearMonthDay(iInstant, newValues);
+            int[] newValues = iYearMonthDay.getValues();
+            newValues = getField().addInField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);
+            return new YearMonthDay(iYearMonthDay, newValues);
         }
 
         //-----------------------------------------------------------------------
@@ -439,9 +439,9 @@ public YearMonthDay addInFieldCopy(int valueToAdd) {
          * @throws IllegalArgumentException if the value isn't valid
          */
         public YearMonthDay setCopy(int value) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, iFieldIndex, newValues, value);
-            return new YearMonthDay(iInstant, newValues);
+            int[] newValues = iYearMonthDay.getValues();
+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);
+            return new YearMonthDay(iYearMonthDay, newValues);
         }
 
         /**
@@ -456,9 +456,9 @@ public YearMonthDay setCopy(int value) {
          * @throws IllegalArgumentException if the text value isn't valid
          */
         public YearMonthDay setCopy(String text, Locale locale) {
-            int[] newValues = iInstant.getValues();
-            getField().set(iInstant, iFieldIndex, newValues, text, locale);
-            return new YearMonthDay(iInstant, newValues);
+            int[] newValues = iYearMonthDay.getValues();
+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);
+            return new YearMonthDay(iYearMonthDay, newValues);
         }
 
         /**
diff --git a/JodaTime/src/java/org/joda/time/partial/package.html b/JodaTime/src/java/org/joda/time/partial/package.html
new file mode 100644
index 000000000..60bf99170
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/partial/package.html
@@ -0,0 +1,82 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.convert package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-2004 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
+<body>
+<p>
+The partial package defines an interface and implementations of time classes
+that do not fully specify a single point in time. The main interface in ReadablePartial.
+Implementations include TimeOfDay (hour, minute, second, milli) and YearMonthDay.
+</p>
+<p>
+The API of a partial is remarkably similar to an instant, however there are internal differences.
+DateTime and Instant store a long millisecond value internally and calculate the
+field value on demand. The partial classes work the other way around, storing the
+field values internally and providing a means to resolve to a millisecond value
+on demand.
+</p>
+<p>
+Since a partial does not represent a single point in time, it must be <i>resolved</i>
+to create a full instant. For example, a TimeOfDay might represent 12:30. To convert to a
+DateTime requires the specification of a date, and is performed using the <code>resolve</code>
+methods of <code>ReadablePartial</code>. Thus
+TimeOfDay(12:30).resolveDateTime(DateTime(2004-06-07T06:00)) = DateTime(2004-06-07T12:30).
+</p>
+</body>
+</html>
diff --git a/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java b/JodaTime/src/test/org/joda/time/partial/MockPartial.java
similarity index 93%
rename from JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java
rename to JodaTime/src/test/org/joda/time/partial/MockPartial.java
index 0e42a267f..728ffa05e 100644
--- a/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java
+++ b/JodaTime/src/test/org/joda/time/partial/MockPartial.java
@@ -57,6 +57,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
 import org.joda.time.chrono.ISOChronology;
 
@@ -65,9 +66,9 @@
  *
  * @author Stephen Colebourne
  */
-public class MockPartialInstant implements PartialInstant {
+public class MockPartial implements ReadablePartial {
     
-    public static final PartialInstant EMPTY_INSTANCE = new MockPartialInstant();
+    public static final ReadablePartial EMPTY_INSTANCE = new MockPartial();
     
     public Chronology getChronology() {
         return ISOChronology.getInstance();
@@ -93,6 +94,8 @@ public long resolve(long baseMillis, DateTimeZone tz) {
     public DateTime resolveDateTime(ReadableInstant base) {
         return null;
     }
+    public void resolveInto(ReadWritableInstant base) {
+    }
     public DateTimeField[] getFields() {
         return new DateTimeField[0];
     }
diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
index da3e54d6f..a55c42996 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -700,10 +700,10 @@ public void testEqualsHashCode() {
         
         assertEquals(false, test1.equals("Hello"));
         assertEquals(true, test1.equals(new MockInstant()));
-        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));
+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));
     }
     
-    class MockInstant extends MockPartialInstant {
+    class MockInstant extends MockPartial {
         public DateTimeField[] getFields() {
             return new DateTimeField[] {
                 ISOChronology.getInstance().hourOfDay(),
@@ -812,7 +812,7 @@ public void testPropertyGetHour() {
         assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());
         assertEquals("hourOfDay", test.hourOfDay().getName());
         assertEquals("Property[hourOfDay]", test.hourOfDay().toString());
-        assertSame(test, test.hourOfDay().getPartialInstant());
+        assertSame(test, test.hourOfDay().getReadablePartial());
         assertSame(test, test.hourOfDay().getTimeOfDay());
         assertEquals(10, test.hourOfDay().get());
         assertEquals("10", test.hourOfDay().getAsText());
@@ -907,7 +907,7 @@ public void testPropertyCompareToHour() {
         assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);
         assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);
         try {
-            test1.hourOfDay().compareTo((PartialInstant) null);
+            test1.hourOfDay().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
@@ -928,7 +928,7 @@ public void testPropertyGetMinute() {
         assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());
         assertEquals("minuteOfHour", test.minuteOfHour().getName());
         assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());
-        assertSame(test, test.minuteOfHour().getPartialInstant());
+        assertSame(test, test.minuteOfHour().getReadablePartial());
         assertSame(test, test.minuteOfHour().getTimeOfDay());
         assertEquals(20, test.minuteOfHour().get());
         assertEquals("20", test.minuteOfHour().getAsText());
@@ -1038,7 +1038,7 @@ public void testPropertyCompareToMinute() {
         assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);
         assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);
         try {
-            test1.minuteOfHour().compareTo((PartialInstant) null);
+            test1.minuteOfHour().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
@@ -1059,7 +1059,7 @@ public void testPropertyGetSecond() {
         assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());
         assertEquals("secondOfMinute", test.secondOfMinute().getName());
         assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());
-        assertSame(test, test.secondOfMinute().getPartialInstant());
+        assertSame(test, test.secondOfMinute().getReadablePartial());
         assertSame(test, test.secondOfMinute().getTimeOfDay());
         assertEquals(30, test.secondOfMinute().get());
         assertEquals("30", test.secondOfMinute().getAsText());
@@ -1166,7 +1166,7 @@ public void testPropertyCompareToSecond() {
         assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);
         assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);
         try {
-            test1.secondOfMinute().compareTo((PartialInstant) null);
+            test1.secondOfMinute().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
@@ -1187,7 +1187,7 @@ public void testPropertyGetMilli() {
         assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());
         assertEquals("millisOfSecond", test.millisOfSecond().getName());
         assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());
-        assertSame(test, test.millisOfSecond().getPartialInstant());
+        assertSame(test, test.millisOfSecond().getReadablePartial());
         assertSame(test, test.millisOfSecond().getTimeOfDay());
         assertEquals(40, test.millisOfSecond().get());
         assertEquals("40", test.millisOfSecond().getAsText());
@@ -1291,7 +1291,7 @@ public void testPropertyCompareToMilli() {
         assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);
         assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);
         try {
-            test1.millisOfSecond().compareTo((PartialInstant) null);
+            test1.millisOfSecond().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
diff --git a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
index 392b4ea0e..3ff2e8b8f 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
@@ -511,10 +511,10 @@ public void testEqualsHashCode() {
         
         assertEquals(false, test1.equals("Hello"));
         assertEquals(true, test1.equals(new MockInstant()));
-        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));
+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));
     }
     
-    class MockInstant extends MockPartialInstant {
+    class MockInstant extends MockPartial {
         public DateTimeField[] getFields() {
             return new DateTimeField[] {
                 ISOChronology.getInstance().year(),
@@ -610,7 +610,7 @@ public void testPropertyGetYear() {
         assertSame(test.getChronology().year(), test.year().getField());
         assertEquals("year", test.year().getName());
         assertEquals("Property[year]", test.year().toString());
-        assertSame(test, test.year().getPartialInstant());
+        assertSame(test, test.year().getReadablePartial());
         assertSame(test, test.year().getYearMonthDay());
         assertEquals(1972, test.year().get());
         assertEquals("1972", test.year().getAsText());
@@ -699,7 +699,7 @@ public void testPropertyCompareToYear() {
         assertEquals(true, test2.year().compareTo(test1) > 0);
         assertEquals(true, test1.year().compareTo(test1) == 0);
         try {
-            test1.year().compareTo((PartialInstant) null);
+            test1.year().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
@@ -720,7 +720,7 @@ public void testPropertyGetMonth() {
         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
         assertEquals("monthOfYear", test.monthOfYear().getName());
         assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
-        assertSame(test, test.monthOfYear().getPartialInstant());
+        assertSame(test, test.monthOfYear().getReadablePartial());
         assertSame(test, test.monthOfYear().getYearMonthDay());
         assertEquals(6, test.monthOfYear().get());
         assertEquals("June", test.monthOfYear().getAsText());
@@ -843,7 +843,7 @@ public void testPropertyCompareToMonth() {
         assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);
         assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);
         try {
-            test1.monthOfYear().compareTo((PartialInstant) null);
+            test1.monthOfYear().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         
@@ -864,7 +864,7 @@ public void testPropertyGetDay() {
         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
         assertEquals("dayOfMonth", test.dayOfMonth().getName());
         assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
-        assertSame(test, test.dayOfMonth().getPartialInstant());
+        assertSame(test, test.dayOfMonth().getReadablePartial());
         assertSame(test, test.dayOfMonth().getYearMonthDay());
         assertEquals(9, test.dayOfMonth().get());
         assertEquals("9", test.dayOfMonth().getAsText());
@@ -984,7 +984,7 @@ public void testPropertyCompareToDay() {
         assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);
         assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);
         try {
-            test1.dayOfMonth().compareTo((PartialInstant) null);
+            test1.dayOfMonth().compareTo((ReadablePartial) null);
             fail();
         } catch (IllegalArgumentException ex) {}
         

From a592319c2ff38f671b65f02b241e26c8ad571eb8 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 22:21:34 +0000
Subject: [PATCH 0093/1934] Support printing of partials

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@243 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../format/AbstractDateTimeFormatter.java     |  11 +-
 .../org/joda/time/format/DateTimeFormat.java  |  25 ++
 .../time/format/DateTimeFormatterBuilder.java | 222 +++++++++++++++++-
 .../org/joda/time/format/DateTimePrinter.java |  26 ++
 .../joda/time/format/ISODateTimeFormat.java   |  94 +++++++-
 .../joda/time/partial/AbstractPartial.java    |  10 -
 .../java/org/joda/time/partial/TimeOfDay.java |  11 +
 .../org/joda/time/partial/YearMonthDay.java   |  11 +
 .../org/joda/time/partial/TestTimeOfDay.java  |   3 +-
 .../joda/time/partial/TestYearMonthDay.java   |   3 +-
 10 files changed, 384 insertions(+), 32 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
index ecf032399..3748cd3f9 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
@@ -62,6 +62,7 @@
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Abstract base class for implementing {@link DateTimePrinter}s,
@@ -190,12 +191,20 @@ public String print(final long instant, DateTimeZone zone) {
     }
 
     public String print(final long instant, final DateTimeZone zone, final long instantLocal) {
-        DateTimePrinter p = (DateTimePrinter)this;
+        DateTimePrinter p = (DateTimePrinter) this;
         StringBuffer buf = new StringBuffer(p.estimatePrintedLength());
         p.printTo(buf, instant, zone, instantLocal);
         return buf.toString();
     }
 
+    public String print(ReadablePartial partial) {
+        DateTimePrinter p = (DateTimePrinter) this;
+        StringBuffer buf = new StringBuffer(p.estimatePrintedLength());
+        p.printTo(buf, partial);
+        return buf.toString();
+    }
+
+    //-----------------------------------------------------------------------
     public int parseInto(final ReadWritableInstant instant, final String text, final int position) {
         DateTimeParser p = (DateTimeParser)this;
 
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index 6baac60df..69239dba9 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -69,6 +69,7 @@
 import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
 import org.joda.time.field.RemainderDateTimeField;
+import org.joda.time.partial.ReadablePartial;
 import org.joda.time.chrono.ISOChronology;
 
 /**
@@ -704,6 +705,14 @@ public void printTo(final Writer out, final long instant,
             mPrinter.printTo(out, instant, zone, instantLocal);
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial instant) {
+            mPrinter.printTo(buf, instant);
+        }
+
+        public void printTo(Writer out, ReadablePartial instant) throws IOException {
+            mPrinter.printTo(out, instant);
+        }
+
         public String print(final ReadableInstant instant) {
             return mPrinter.print(instant);
         }
@@ -720,6 +729,10 @@ public String print(final long instant, final DateTimeZone zone, final long inst
             return mPrinter.print(instant, zone, instantLocal);
         }
 
+        public String print(ReadablePartial partial) {
+            return mPrinter.print(partial);
+        }
+
         public int estimateParsedLength() {
             return 0;
         }
@@ -816,6 +829,14 @@ public void printTo(final Writer out, final long instant,
             throw unsupported();
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial instant) {
+            throw unsupported();
+        }
+
+        public void printTo(Writer out, ReadablePartial instant) throws IOException {
+            throw unsupported();
+        }
+
         public String print(final ReadableInstant instant) {
             throw unsupported();
         }
@@ -832,6 +853,10 @@ public String print(final long instant, final DateTimeZone zone, final long inst
             throw unsupported();
         }
 
+        public String print(ReadablePartial partial) {
+            throw unsupported();
+        }
+
         public int estimateParsedLength() {
             return mParser.estimateParsedLength();
         }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index a8b2cdbf2..2771ac959 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -64,6 +64,7 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.field.MillisDurationField;
 import org.joda.time.field.PreciseDateTimeField;
+import org.joda.time.partial.ReadablePartial;
 import org.joda.time.chrono.ISOChronology;
 
 /**
@@ -974,6 +975,18 @@ private boolean isFormatter(final Object f) {
         public Chronology getChronology() {
             return iChrono;
         }
+
+        protected void appendUnknownString(StringBuffer buf, int len) {
+            for (int i = len; --i >= 0;) {
+                buf.append('\ufffd');
+            }
+        }
+
+        protected void printUnknownString(Writer out, int len) throws IOException {
+            for (int i = len; --i >= 0;) {
+                out.write('\ufffd');
+            }
+        }
     }
 
     private static class CharacterLiteral extends AbstractFormatter
@@ -1000,10 +1013,22 @@ public void printTo(Writer out, long instant,
             out.write(iValue);
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            buf.append(iValue);
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            out.write(iValue);
+        }
+
         public String print(long instant, DateTimeZone zone, long instantLocal) {
             return String.valueOf(iValue);
         }
 
+        public String print(ReadablePartial partial) {
+            return String.valueOf(iValue);
+        }
+
         public int estimateParsedLength() {
             return 1;
         }
@@ -1056,10 +1081,22 @@ public void printTo(Writer out, long instant,
             out.write(iValue);
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            buf.append(iValue);
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            out.write(iValue);
+        }
+
         public String print(long instant, DateTimeZone zone, long instantLocal) {
             return iValue;
         }
 
+        public String print(ReadablePartial partial) {
+            return iValue;
+        }
+
         public int estimateParsedLength() {
             return iValue.length();
         }
@@ -1175,6 +1212,30 @@ public void printTo(Writer out, long instant,
                 out.write('\ufffd');
             }
         }
+
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            if (partial.isSupported(iField)) {
+                try {
+                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iField));
+                } catch (RuntimeException e) {
+                    buf.append('\ufffd');
+                }
+            } else {
+                buf.append('\ufffd');
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            if (partial.isSupported(iField)) {
+                try {
+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iField));
+                } catch (RuntimeException e) {
+                    out.write('\ufffd');
+                }
+            } else {
+                out.write('\ufffd');
+            }
+        }
     }
 
     private static class PaddedNumber extends NumberFormatter {
@@ -1195,24 +1256,42 @@ public int estimatePrintedLength() {
         public void printTo(StringBuffer buf, long instant,
                             DateTimeZone zone, long instantLocal) {
             try {
-                FormatUtils.appendPaddedInteger
-                    (buf, iField.get(instantLocal), iMinPrintedDigits);
+                FormatUtils.appendPaddedInteger(buf, iField.get(instantLocal), iMinPrintedDigits);
             } catch (RuntimeException e) {
-                for (int i=iMinPrintedDigits; --i>=0; ) {
-                    buf.append('\ufffd');
-                }
+                appendUnknownString(buf, iMinPrintedDigits);
             }
         }
 
         public void printTo(Writer out, long instant,
                             DateTimeZone zone, long instantLocal) throws IOException {
             try {
-                FormatUtils.writePaddedInteger
-                    (out, iField.get(instantLocal), iMinPrintedDigits);
+                FormatUtils.writePaddedInteger(out, iField.get(instantLocal), iMinPrintedDigits);
             } catch (RuntimeException e) {
-                for (int i=iMinPrintedDigits; --i>=0; ) {
-                    out.write('\ufffd');
+                printUnknownString(out, iMinPrintedDigits);
+            }
+        }
+
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            if (partial.isSupported(iField)) {
+                try {
+                    FormatUtils.appendPaddedInteger(buf, partial.get(iField), iMinPrintedDigits);
+                } catch (RuntimeException e) {
+                    appendUnknownString(buf, iMinPrintedDigits);
                 }
+            } else {
+                appendUnknownString(buf, iMinPrintedDigits);
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            if (partial.isSupported(iField)) {
+                try {
+                    FormatUtils.writePaddedInteger(out, partial.get(iField), iMinPrintedDigits);
+                } catch (RuntimeException e) {
+                    printUnknownString(out, iMinPrintedDigits);
+                }
+            } else {
+                printUnknownString(out, iMinPrintedDigits);
             }
         }
     }
@@ -1303,6 +1382,39 @@ private int getTwoDigitYear(long instantLocal) {
                 return -1;
             }
         }
+
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            int year = getTwoDigitYear(partial);
+            if (year < 0) {
+                buf.append('\ufffd');
+                buf.append('\ufffd');
+            } else {
+                FormatUtils.appendPaddedInteger(buf, year, 2);
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            int year = getTwoDigitYear(partial);
+            if (year < 0) {
+                out.write('\ufffd');
+                out.write('\ufffd');
+            } else {
+                FormatUtils.writePaddedInteger(out, year, 2);
+            }
+        }
+
+        private int getTwoDigitYear(ReadablePartial partial) {
+            if (partial.isSupported(iField)) {
+                try {
+                    int year = partial.get(iField);
+                    if (year < 0) {
+                        year = -year;
+                    }
+                    return year % 100;
+                } catch (RuntimeException e) {}
+            } 
+            return -1;
+        }
     }
 
     private static class TextField extends AbstractFormatter
@@ -1350,6 +1462,22 @@ public void printTo(Writer out, long instant,
             }
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            try {
+                buf.append(print(partial));
+            } catch (RuntimeException e) {
+                buf.append('\ufffd');
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            try {
+                out.write(print(partial));
+            } catch (RuntimeException e) {
+                out.write('\ufffd');
+            }
+        }
+
         public final String print(long instant, DateTimeZone zone, long instantLocal) {
             if (iShort) {
                 return iField.getAsShortText(instantLocal, iLocale);
@@ -1358,6 +1486,18 @@ public final String print(long instant, DateTimeZone zone, long instantLocal) {
             }
         }
 
+        public final String print(ReadablePartial partial) {
+            if (partial.isSupported(iField)) {
+                if (iShort) {
+                    return iField.getAsShortText(partial, iLocale);
+                } else {
+                    return iField.getAsText(partial, iLocale);
+                }
+            } else {
+                return "\ufffd";
+            }
+        }
+
         public int estimateParsedLength() {
             return estimatePrintedLength();
         }
@@ -1463,6 +1603,28 @@ public void printTo(Writer out, long instant,
             printTo(null, out, instantLocal);
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            if (partial.isSupported(iField)) {
+                long millis = partial.resolve(0L, DateTimeZone.UTC);
+                try {
+                    printTo(buf, null, millis);
+                } catch (IOException e) {
+                    // Not gonna happen.
+                }
+            } else {
+                buf.append('\ufffd');
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            if (partial.isSupported(iField)) {
+                long millis = partial.resolve(0L, DateTimeZone.UTC);
+                printTo(null, out, millis);
+            } else {
+                out.write('\ufffd');
+            }
+        }
+
         private void printTo(StringBuffer buf, Writer out, long instantLocal)
             throws IOException
         {
@@ -1742,6 +1904,14 @@ public void printTo(Writer out, long instant,
             FormatUtils.writePaddedInteger(out, offset, 3);
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            // no zone info
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            // no zone info
+        }
+
         public int estimateParsedLength() {
             return estimatePrintedLength();
         }
@@ -1986,6 +2156,14 @@ public String print(long instant, DateTimeZone zone, long instantLocal) {
                 return zone.getName(instant, this.iLocale);
             }
         }
+
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            // no zone info
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            // no zone info
+        }
     }
 
     private static final class Composite extends AbstractFormatter
@@ -2050,7 +2228,6 @@ public int estimatePrintedLength() {
         public void printTo(StringBuffer buf, long instant,
                             DateTimeZone zone, long instantLocal) {
             DateTimePrinter[] elements = iPrinters;
-
             if (elements == null) {
                 throw new UnsupportedOperationException();
             }
@@ -2064,7 +2241,6 @@ public void printTo(StringBuffer buf, long instant,
         public void printTo(Writer out, long instant,
                             DateTimeZone zone, long instantLocal) throws IOException {
             DateTimePrinter[] elements = iPrinters;
-
             if (elements == null) {
                 throw new UnsupportedOperationException();
             }
@@ -2075,6 +2251,30 @@ public void printTo(Writer out, long instant,
             }
         }
 
+        public void printTo(StringBuffer buf, ReadablePartial partial) {
+            DateTimePrinter[] elements = iPrinters;
+            if (elements == null) {
+                throw new UnsupportedOperationException();
+            }
+
+            int len = elements.length;
+            for (int i=0; i<len; i++) {
+                elements[i].printTo(buf, partial);
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial) throws IOException {
+            DateTimePrinter[] elements = iPrinters;
+            if (elements == null) {
+                throw new UnsupportedOperationException();
+            }
+
+            int len = elements.length;
+            for (int i=0; i<len; i++) {
+                elements[i].printTo(out, partial);
+            }
+        }
+
         public int estimateParsedLength() {
             return iParsedLengthEstimate;
         }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
index d9efc6e96..f5ee77ff5 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
@@ -59,6 +59,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
+import org.joda.time.partial.ReadablePartial;
 
 /**
  * Defines an interface for creating textual representations of datetimes.
@@ -170,6 +171,23 @@ void printTo(StringBuffer buf, long instant,
     void printTo(Writer out, long instant,
                  DateTimeZone zone, long instantLocal) throws IOException;
 
+    //-----------------------------------------------------------------------
+    /**
+     * Prints a ReadablePartial.
+     *
+     * @param buf  formatted partial is appended to this buffer
+     * @param partial  partial to format
+     */
+    void printTo(StringBuffer buf, ReadablePartial partial);
+
+    /**
+     * Prints a ReadablePartial.
+     *
+     * @param out  formatted partial is written out
+     * @param partial  partial to format
+     */
+    void printTo(Writer out, ReadablePartial partial) throws IOException;
+
     //-----------------------------------------------------------------------
     /**
      * Prints a ReadableInstant to a new String, attempting to use the
@@ -210,4 +228,12 @@ void printTo(Writer out, long instant,
      */
     String print(long instant, DateTimeZone zone, long instantLocal);
     
+    /**
+     * Prints a ReadablePartial to a new String.
+     *
+     * @param partial  partial to format
+     * @return the printed result
+     */
+    String print(ReadablePartial partial);
+
 }
diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 140f0f9a1..202c62fe5 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -151,7 +151,8 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         hde, // hourOfDay element (HH)
         mhe, // minuteOfHour element (:mm)
         sme, // secondOfMinute element (:ss)
-        fse, // fractionOfSecond element (.SSS)
+        lse, // millisOfSecond element (.SSS)
+        fse, // fractionOfSecond element (.SSSSSSSSS)
         ze,  // zone offset element
         
         //y,   // year (same as year element)
@@ -165,15 +166,18 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         //h,    // hour (same as hour element)
         hm,   // hour minute
         hms,  // hour minute second
+        hmsl, // hour minute second millis
         hmsf, // hour minute second fraction
 
         dh,    // date hour
         dhm,   // date hour minute
         dhms,  // date hour minute second
+        dhmsl, // date hour minute second millis
         dhmsf, // date hour minute second fraction
 
         //d,  // date (same as ymd)
         t,  // time
+        tt,  // Ttime
         dt, // date time
 
         //wd,  // week date (same as wwd)
@@ -181,6 +185,7 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
 
         bd,  // basic date
         bt,  // basic time
+        btt, // basic Ttime
         bdt, // basic date time
 
         bwd,  // basic week date
@@ -420,7 +425,7 @@ public DateTimeFormatter date() {
     public DateTimeFormatter time() {
         if (t == null) {
             t = new DateTimeFormatterBuilder(iChrono)
-                .append(hourMinuteSecondFraction())
+                .append(hourMinuteSecondMillis())
                 .append(offsetElement())
                 .toFormatter();
         }
@@ -428,15 +433,30 @@ public DateTimeFormatter time() {
     }
 
     /**
-     * Returns a formatter that combines a full date and time, separated by a
-     * 'T'. (yyyy-MM-dd'T'HH:mm:ss.SSSZ)
+     * Returns a formatter for a two digit hour of day, two digit minute of
+     * hour, two digit second of minute, three digit fraction of second, and
+     * time zone offset prefixed by 'T'. ('T'HH:mm:ss.SSSZ)
+     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
+     */
+    public DateTimeFormatter tTime() {
+        if (t == null) {
+            t = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral('T')
+                .append(time())
+                .toFormatter();
+        }
+        return t;
+    }
+
+    /**
+     * Returns a formatter that combines a full date and time, separated by a 'T'.
+     * (yyyy-MM-dd'T'HH:mm:ss.SSSZ)
      */
     public DateTimeFormatter dateTime() {
         if (dt == null) {
             dt = new DateTimeFormatterBuilder(iChrono)
                 .append(date())
-                .appendLiteral('T')
-                .append(time())
+                .append(tTime())
                 .toFormatter();
         }
         return dt;
@@ -498,6 +518,22 @@ public DateTimeFormatter basicTime() {
         return bt;
     }
 
+    /**
+     * Returns a basic formatter for a two digit hour of day, two digit minute
+     * of hour, two digit second of minute, and time zone offset prefixed by 'T'.
+     * ('T'HHmmssZ)
+     * The time zone offset is blank for zero, and of the form '\u00b1HHmm' for non-zero.
+     */
+    public DateTimeFormatter basicTTime() {
+        if (bt == null) {
+            bt = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral('T')
+                .append(basicTime())
+                .toFormatter();
+        }
+        return bt;
+    }
+
     /**
      * Returns a basic formatter that combines a basic date and time, separated
      * by a 'T'. (yyyyMMdd'T'HHmmssZ)
@@ -506,8 +542,7 @@ public DateTimeFormatter basicDateTime() {
         if (bdt == null) {
             bdt = new DateTimeFormatterBuilder(iChrono)
                 .append(basicDate())
-                .appendLiteral('T')
-                .append(basicTime())
+                .append(basicTTime())
                 .toFormatter();
         }
         return bdt;
@@ -653,6 +688,23 @@ public DateTimeFormatter hourMinuteSecond() {
         return hms;
     }
 
+    /**
+     * Returns a formatter for a two digit hour of day, two digit minute of
+     * hour, two digit second of minute, and three digit fraction of
+     * second. (HH:mm:ss.SSS)
+     */
+    public DateTimeFormatter hourMinuteSecondMillis() {
+        if (hmsl == null) {
+            hmsl = new DateTimeFormatterBuilder(iChrono)
+                .append(hourElement())
+                .append(minuteElement())
+                .append(secondElement())
+                .append(millisElement())
+                .toFormatter();
+        }
+        return hmsl;
+    }
+
     /**
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, and three digit fraction of
@@ -716,6 +768,22 @@ public DateTimeFormatter dateHourMinuteSecond() {
         return dhms;
     }
 
+    /**
+     * Returns a formatter that combines a full date, two digit hour of day,
+     * two digit minute of hour, two digit second of minute, and three digit
+     * fraction of second. (yyyy-MM-dd'T'HH:mm:ss.SSS)
+     */
+    public DateTimeFormatter dateHourMinuteSecondMillis() {
+        if (dhmsl == null) {
+            dhmsl = new DateTimeFormatterBuilder(iChrono)
+                .append(date())
+                .appendLiteral('T')
+                .append(hourMinuteSecondMillis())
+                .toFormatter();
+        }
+        return dhmsl;
+    }
+
     /**
      * Returns a formatter that combines a full date, two digit hour of day,
      * two digit minute of hour, two digit second of minute, and three digit
@@ -830,6 +898,16 @@ private DateTimeFormatter secondElement() {
         return sme;
     }
 
+    private DateTimeFormatter millisElement() {
+        if (lse == null) {
+            lse = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral('.')
+                .appendMillisOfSecond(3)
+                .toFormatter();
+        }
+        return lse;
+    }
+
     private DateTimeFormatter fractionElement() {
         if (fse == null) {
             fse = new DateTimeFormatterBuilder(iChrono)
diff --git a/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
index 1e7172b0c..1ebe64e12 100644
--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java
@@ -482,14 +482,4 @@ public int hashCode() {
         return total;
     }
 
-    /**
-     * Output the time in an ISO8601 format.
-     * 
-     * @return ISO8601 formatted string
-     */
-    public String toString() {
-        // TODO
-        return "";
-    }
-
 }
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index d4c87e65a..0436be5ec 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -58,6 +58,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
+import org.joda.time.format.ISODateTimeFormat;
 
 /**
  * TimeOfDay is an immutable partial supporting the hour, minute, second
@@ -407,6 +408,16 @@ public Property millisOfSecond() {
         return new Property(this, MILLIS_OF_SECOND);
     }
 
+    //-----------------------------------------------------------------------
+    /**
+     * Output the time in the ISO8601 format THH:mm:ss.SSS.
+     * 
+     * @return ISO8601 formatted string
+     */
+    public String toString() {
+        return ISODateTimeFormat.getInstanceUTC().tTime().print(this);
+    }
+
     //-----------------------------------------------------------------------
     /**
      * The property class for TimeOfDay.
diff --git a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
index 84797b982..473068a93 100644
--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
@@ -58,6 +58,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
+import org.joda.time.format.ISODateTimeFormat;
 
 /**
  * YearMonthDay is an immutable partial supporting the year, monthOfYear
@@ -319,6 +320,16 @@ public Property dayOfMonth() {
         return new Property(this, DAY_OF_MONTH);
     }
 
+    //-----------------------------------------------------------------------
+    /**
+     * Output the time in the ISO8601 format YYYY-MM-DD.
+     * 
+     * @return ISO8601 formatted string
+     */
+    public String toString() {
+        return ISODateTimeFormat.getInstanceUTC().yearMonthDay().print(this);
+    }
+
     //-----------------------------------------------------------------------
     /**
      * The property class for YearMonthDay.
diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
index a55c42996..8835d7b45 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -803,7 +803,8 @@ public void testSerialization() throws Exception {
 
     //-----------------------------------------------------------------------
     public void testToString() {
-        // TODO
+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
+        assertEquals("T10:20:30.040", test.toString());
     }
 
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
index 3ff2e8b8f..e9fa20cb4 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
@@ -601,7 +601,8 @@ public void testSerialization() throws Exception {
 
     //-----------------------------------------------------------------------
     public void testToString() {
-        // TODO
+        YearMonthDay test = new YearMonthDay(1972, 6, 9);
+        assertEquals("1972-06-09", test.toString());
     }
 
     //-----------------------------------------------------------------------

From eab5533ec9e6bc4fefa7b4a52f463bbd84c34d5d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 22:22:10 +0000
Subject: [PATCH 0094/1934] StringBuffer decorator

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@244 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/StringBufferWriter.java  | 115 ++++++++++++++++++
 1 file changed, 115 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/format/StringBufferWriter.java

diff --git a/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java b/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java
new file mode 100644
index 000000000..a65be6833
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java
@@ -0,0 +1,115 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+
+/**
+ * Writer that decorates a specified StringBuffer, a class that should be in the JDK.
+ * <p>
+ * StringBufferWriter is mutable and not thread-safe.
+ *
+ * @author Sun JDK StringWriter
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+class StringBufferWriter extends Writer {
+
+    /** The string buffer to decorate. */
+    private StringBuffer iBuffer;
+
+    /**
+     * Constructs a writer that decorates the specified buffer.
+     */
+    public StringBufferWriter(StringBuffer buf) {
+        iBuffer = buf;
+        lock = buf;
+    }
+
+    public void write(int ch) {
+        iBuffer.append((char) ch);
+    }
+
+    public void write(char chars[], int off, int len) {
+        if ((off < 0)
+            || (off > chars.length)
+            || (len < 0)
+            || ((off + len) > chars.length)
+            || ((off + len) < 0)) {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0) {
+            return;
+        }
+        iBuffer.append(chars, off, len);
+    }
+
+    public void write(String str) {
+        iBuffer.append(str);
+    }
+
+    public void write(String str, int off, int len) {
+        iBuffer.append(str.substring(off, off + len));
+    }
+
+    public void flush() {
+    }
+
+    public void close() throws IOException {
+    }
+
+    public String toString() {
+        return iBuffer.toString();
+    }
+}

From 827aa5f221f3e2c52a7b8145a179904b9452bddc Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 22:23:04 +0000
Subject: [PATCH 0095/1934] Remove as not in use

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@245 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/StringBufferWriter.java  | 115 ------------------
 1 file changed, 115 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/format/StringBufferWriter.java

diff --git a/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java b/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java
deleted file mode 100644
index a65be6833..000000000
--- a/JodaTime/src/java/org/joda/time/format/StringBufferWriter.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.format;
-
-import java.io.IOException;
-import java.io.Writer;
-
-/**
- * Writer that decorates a specified StringBuffer, a class that should be in the JDK.
- * <p>
- * StringBufferWriter is mutable and not thread-safe.
- *
- * @author Sun JDK StringWriter
- * @author Stephen Colebourne
- * @since 1.0
- */
-class StringBufferWriter extends Writer {
-
-    /** The string buffer to decorate. */
-    private StringBuffer iBuffer;
-
-    /**
-     * Constructs a writer that decorates the specified buffer.
-     */
-    public StringBufferWriter(StringBuffer buf) {
-        iBuffer = buf;
-        lock = buf;
-    }
-
-    public void write(int ch) {
-        iBuffer.append((char) ch);
-    }
-
-    public void write(char chars[], int off, int len) {
-        if ((off < 0)
-            || (off > chars.length)
-            || (len < 0)
-            || ((off + len) > chars.length)
-            || ((off + len) < 0)) {
-            throw new IndexOutOfBoundsException();
-        } else if (len == 0) {
-            return;
-        }
-        iBuffer.append(chars, off, len);
-    }
-
-    public void write(String str) {
-        iBuffer.append(str);
-    }
-
-    public void write(String str, int off, int len) {
-        iBuffer.append(str.substring(off, off + len));
-    }
-
-    public void flush() {
-    }
-
-    public void close() throws IOException {
-    }
-
-    public String toString() {
-        return iBuffer.toString();
-    }
-}

From cc50f0867f74af1718a2682f442895d1e5cc96c7 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 23:01:58 +0000
Subject: [PATCH 0096/1934] Test DateTimeConstants

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@246 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/DateTimeConstants.java |   2 +-
 JodaTime/src/test/org/joda/time/TestAll.java  |   1 +
 .../org/joda/time/TestDateTimeConstants.java  | 156 ++++++++++++++++++
 3 files changed, 158 insertions(+), 1 deletion(-)
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateTimeConstants.java

diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index 0e8cd2aaa..e081282df 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -64,7 +64,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class DateTimeConstants {
+public class DateTimeConstants {
 
     // These are ints not enumerations as they represent genuine int values
     /** Constant (1) representing January, the first month (ISO) */
diff --git a/JodaTime/src/test/org/joda/time/TestAll.java b/JodaTime/src/test/org/joda/time/TestAll.java
index 5cd67d197..6194f27de 100644
--- a/JodaTime/src/test/org/joda/time/TestAll.java
+++ b/JodaTime/src/test/org/joda/time/TestAll.java
@@ -73,6 +73,7 @@ public TestAll(String testName) {
     public static Test suite() {
         TestSuite suite = new TestSuite();
         suite.addTest(TestDateTimeComparator.suite());
+        suite.addTest(TestDateTimeConstants.suite());
         suite.addTest(TestParseISO.suite());
         return suite;
     }
diff --git a/JodaTime/src/test/org/joda/time/TestDateTimeConstants.java b/JodaTime/src/test/org/joda/time/TestDateTimeConstants.java
new file mode 100644
index 000000000..a46e8c74f
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestDateTimeConstants.java
@@ -0,0 +1,156 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import junit.framework.TestSuite;
+
+import org.joda.test.time.BulkTest;
+
+/**
+ * Test case.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateTimeConstants extends BulkTest {
+
+    /**
+     * The main method for this test program.
+     * @param args command line arguments.
+     */
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    /**
+     * TestSuite is a junit required method.
+     */
+    public static TestSuite suite() {
+        return BulkTest.makeSuite(TestDateTimeConstants.class);
+    }
+
+    /**
+     * TestDateTimeComparator constructor.
+     * @param name
+     */
+    public TestDateTimeConstants(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testConstructor() {
+        DateTimeConstants c = new DateTimeConstants() {
+        };
+        c.toString();
+    }
+
+    public void testHalfdaysOfDay() {
+        assertEquals(0, DateTimeConstants.AM);
+        assertEquals(1, DateTimeConstants.PM);
+    }
+
+    public void testDaysOfWeek() {
+        assertEquals(1, DateTimeConstants.MONDAY);
+        assertEquals(2, DateTimeConstants.TUESDAY);
+        assertEquals(3, DateTimeConstants.WEDNESDAY);
+        assertEquals(4, DateTimeConstants.THURSDAY);
+        assertEquals(5, DateTimeConstants.FRIDAY);
+        assertEquals(6, DateTimeConstants.SATURDAY);
+        assertEquals(7, DateTimeConstants.SUNDAY);
+    }
+
+    public void testMonthsOfYear() {
+        assertEquals(1, DateTimeConstants.JANUARY);
+        assertEquals(2, DateTimeConstants.FEBRUARY);
+        assertEquals(3, DateTimeConstants.MARCH);
+        assertEquals(4, DateTimeConstants.APRIL);
+        assertEquals(5, DateTimeConstants.MAY);
+        assertEquals(6, DateTimeConstants.JUNE);
+        assertEquals(7, DateTimeConstants.JULY);
+        assertEquals(8, DateTimeConstants.AUGUST);
+        assertEquals(9, DateTimeConstants.SEPTEMBER);
+        assertEquals(10, DateTimeConstants.OCTOBER);
+        assertEquals(11, DateTimeConstants.NOVEMBER);
+        assertEquals(12, DateTimeConstants.DECEMBER);
+    }
+
+    public void testEras() {
+        assertEquals(0, DateTimeConstants.BC);
+        assertEquals(0, DateTimeConstants.BCE);
+        assertEquals(1, DateTimeConstants.AD);
+        assertEquals(1, DateTimeConstants.CE);
+    }
+
+    public void testMaths() {
+        assertEquals(1000, DateTimeConstants.MILLIS_PER_SECOND);
+        assertEquals(60 * 1000, DateTimeConstants.MILLIS_PER_MINUTE);
+        assertEquals(60 * 60 * 1000, DateTimeConstants.MILLIS_PER_HOUR);
+        assertEquals(24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_DAY);
+        assertEquals(7 * 24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_WEEK);
+        
+        assertEquals(60, DateTimeConstants.SECONDS_PER_MINUTE);
+        assertEquals(60 * 60, DateTimeConstants.SECONDS_PER_HOUR);
+        assertEquals(24 * 60 * 60, DateTimeConstants.SECONDS_PER_DAY);
+        assertEquals(7 * 24 * 60 * 60, DateTimeConstants.SECONDS_PER_WEEK);
+        
+        assertEquals(60, DateTimeConstants.MINUTES_PER_HOUR);
+        assertEquals(24 * 60, DateTimeConstants.MINUTES_PER_DAY);
+        assertEquals(7 * 24 * 60, DateTimeConstants.MINUTES_PER_WEEK);
+        
+        assertEquals(24, DateTimeConstants.HOURS_PER_DAY);
+        assertEquals(7 * 24, DateTimeConstants.HOURS_PER_WEEK);
+        
+        assertEquals(7, DateTimeConstants.DAYS_PER_WEEK);
+    }
+
+}

From b10f4155832adc65efcae5de46328b5b65c17696 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jun 2004 23:03:05 +0000
Subject: [PATCH 0097/1934] Ignore junit files

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@247 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/.cvsignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/.cvsignore b/JodaTime/.cvsignore
index 42efc53d2..2422b6407 100644
--- a/JodaTime/.cvsignore
+++ b/JodaTime/.cvsignore
@@ -7,3 +7,4 @@ velocity.log
 maven.log
 jcoverage.ser
 build
+junit*.properties

From 67fa5aa4e02fdeee1bf71a79b460027f101e766c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 28 Jun 2004 00:36:14 +0000
Subject: [PATCH 0098/1934] Fix broken @link tags.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@248 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/field/BaseDateTimeField.java     | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index b26cc3e92..8c3a6e604 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -523,7 +523,7 @@ public long set(long instant, String text, Locale locale) {
      * If the specified locale is null, the default locale is used.
      * <p>
      * This implementation uses {@link #convertText(String, Locale)} and
-     * {@link #set(PartialInstant, int, int[], int)}.
+     * {@link #set(ReadablePartial, int, int[], int)}.
      *
      * @param instant  the partial instant
      * @param fieldIndex  the index of this field in the instant
@@ -645,7 +645,7 @@ public int getMinimumValue(ReadablePartial instant) {
      * Get the minimum value for this field using the partial instant and
      * the specified values.
      * <p>
-     * This implementation returns the same as {@link #getMinimumValue(PartialInstant)}.
+     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.
      * 
      * @param instant  the partial instant to query
      * @param values  the values to use
@@ -691,7 +691,7 @@ public int getMaximumValue(ReadablePartial instant) {
      * Get the maximum value for this field using the partial instant and
      * the specified values.
      * <p>
-     * This implementation returns the same as {@link #getMaximumValue(PartialInstant)}.
+     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.
      * 
      * @param instant  the partial instant to query
      * @param values  the values to use

From d4cbf85d927b16c140520e323393d9fece986ed3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 28 Jun 2004 00:41:07 +0000
Subject: [PATCH 0099/1934] Mix minor typos.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@249 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/partial/package.html | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/partial/package.html b/JodaTime/src/java/org/joda/time/partial/package.html
index 60bf99170..17423acec 100644
--- a/JodaTime/src/java/org/joda/time/partial/package.html
+++ b/JodaTime/src/java/org/joda/time/partial/package.html
@@ -61,8 +61,8 @@
 <body>
 <p>
 The partial package defines an interface and implementations of time classes
-that do not fully specify a single point in time. The main interface in ReadablePartial.
-Implementations include TimeOfDay (hour, minute, second, milli) and YearMonthDay.
+that do not fully specify a single point in time. The main interface is ReadablePartial.
+Implementations include TimeOfDay (hour, minute, second, millis) and YearMonthDay.
 </p>
 <p>
 The API of a partial is remarkably similar to an instant, however there are internal differences.

From e4c81f521f0c9f4279a733ab2416ce96b6b73b41 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jul 2004 22:37:14 +0000
Subject: [PATCH 0100/1934] Fix constructor javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@250 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTime.java        | 12 ++++++------
 .../src/java/org/joda/time/partial/TimeOfDay.java    |  4 ++--
 .../src/java/org/joda/time/partial/YearMonthDay.java |  4 ++--
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index d9c11ce0d..14ca57b71 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -184,8 +184,8 @@ public DateTime(long instant, Chronology chronology) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the instant is null or invalid
+     * @param instant  the datetime object, null means now
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public DateTime(Object instant) {
         super(instant);
@@ -202,9 +202,9 @@ public DateTime(Object instant) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
-     * @param instant  the datetime object, must not be null
+     * @param instant  the datetime object, null means now
      * @param zone  the time zone, null means default time zone
-     * @throws IllegalArgumentException if the instant is null or invalid
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public DateTime(Object instant, DateTimeZone zone) {
         super(instant, zone);
@@ -220,9 +220,9 @@ public DateTime(Object instant, DateTimeZone zone) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
      *
-     * @param instant  the datetime object, must not be null
+     * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology in default zone
-     * @throws IllegalArgumentException if the instant is null or invalid
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public DateTime(Object instant, Chronology chronology) {
         super(instant, chronology);
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 0436be5ec..300c372c6 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -169,7 +169,7 @@ public TimeOfDay(long instant, Chronology chronology) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, null means now
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant) {
         super(instant);
@@ -189,7 +189,7 @@ public TimeOfDay(Object instant) {
      *
      * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant, Chronology chronology) {
         super(instant, chronology);
diff --git a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
index 473068a93..70c77aa97 100644
--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
@@ -166,7 +166,7 @@ public YearMonthDay(long instant, Chronology chronology) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, null means now
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public YearMonthDay(Object instant) {
         super(instant);
@@ -186,7 +186,7 @@ public YearMonthDay(Object instant) {
      *
      * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public YearMonthDay(Object instant, Chronology chronology) {
         super(instant, chronology);

From 33589db6ad80f8d3616d3a45bffdcbb2f6312f71 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jul 2004 22:38:02 +0000
Subject: [PATCH 0101/1934] Remove ReadableInstant constructor

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@251 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/Instant.java | 15 ++-------------
 1 file changed, 2 insertions(+), 13 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 1372b2c98..1b4a6d9ed 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -101,25 +101,14 @@ public Instant(long instant) {
         iMillis = instant;
     }
 
-    /**
-     * Constructs an instance from a <code>ReadableInstant</code>.
-     * 
-     * @param instant  the ReadableInstant
-     * @throws IllegalArgumentException if the instant is null
-     */
-    public Instant(ReadableInstant instant) {
-        super();
-        iMillis = instant.getMillis();
-    }
-
     /**
      * Constructs an instance from an Object that represents a datetime.
      * <p>
      * The recognised object types are defined in {@link ConverterManager} and
      * include String, Calendar and Date.
      *
-     * @param instant  the datetime object, must not be null
-     * @throws IllegalArgumentException if the instant is null or invalid
+     * @param instant  the datetime object, null means now
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public Instant(Object instant) {
         super();

From 8acb3651b1e903438a4a98811b7422c0f4c00ff3 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jul 2004 22:38:21 +0000
Subject: [PATCH 0102/1934] Fixes resulting from testing

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@252 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDateTime.java  | 37 +++++++--------
 .../java/org/joda/time/AbstractInstant.java   | 46 +++++++++----------
 2 files changed, 39 insertions(+), 44 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index 1b37ea512..be6bdad34 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -57,10 +57,9 @@
 import java.util.Locale;
 
 import org.joda.time.chrono.ISOChronology;
-import org.joda.time.convert.InstantConverter;
 import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.DateTimeFormat;
-import org.joda.time.format.ISODateTimeFormat;
 
 /**
  * AbstractDateTime provides the common behaviour for datetime classes.
@@ -200,7 +199,7 @@ protected AbstractDateTime(final long instant, final Chronology chronology) {
     protected AbstractDateTime(final Object instant) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        iChronology = converter.getChronology(instant);
+        iChronology = selectChronology(converter.getChronology(instant));
         iMillis = converter.getInstantMillis(instant);
     }
 
@@ -221,7 +220,7 @@ protected AbstractDateTime(final Object instant) {
     protected AbstractDateTime(final Object instant, final DateTimeZone zone) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        iChronology = converter.getChronology(instant, zone);
+        iChronology = selectChronology(converter.getChronology(instant, zone));
         iMillis = converter.getInstantMillis(instant, zone);
     }
 
@@ -241,7 +240,7 @@ protected AbstractDateTime(final Object instant, final DateTimeZone zone) {
     protected AbstractDateTime(final Object instant, final Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        iChronology = converter.getChronology(instant, chronology);
+        iChronology = selectChronology(converter.getChronology(instant, chronology));
         iMillis = converter.getInstantMillis(instant, chronology);
     }
 
@@ -531,30 +530,32 @@ public final int getMillisOfSecond() {
      *
      * @return ISO8601 time formatted string.
      */
-    public String toString() {
-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
-    }
+    public abstract String toString();
 
     /**
      * Output the instant using the specified format pattern.
      *
-     * @param pattern  the pattern specification
-     * @throws IllegalArgumentException  if pattern is invalid
+     * @param pattern  the pattern specification, null means use <code>toString</code>
      * @see  org.joda.time.format.DateTimeFormat
      */
-    public String toString(String pattern) throws IllegalArgumentException {
+    public String toString(String pattern) {
+        if (pattern == null) {
+            return toString();
+        }
         return DateTimeFormat.getInstance(getChronology()).forPattern(pattern).print(this);
     }
 
     /**
      * Output the instant using the specified format pattern.
      *
-     * @param pattern  the pattern specification
-     * @param locale  Locale to use, or default if null
-     * @throws IllegalArgumentException  if pattern is invalid
+     * @param pattern  the pattern specification, null means use <code>toString</code>
+     * @param locale  Locale to use, null means default
      * @see  org.joda.time.format.DateTimeFormat
      */
     public String toString(String pattern, Locale locale) throws IllegalArgumentException {
+        if (pattern == null) {
+            return toString();
+        }
         return DateTimeFormat.getInstance(getChronology(), locale).forPattern(pattern).print(this);
     }
 
@@ -585,12 +586,8 @@ protected void setMillis(long instant) {
     protected void setMillis(Object instant) {
         // Don't set iMillis directly, as it may provide a backdoor to
         // immutable subclasses.
-        if (instant instanceof ReadableInstant) {
-            setMillis(((ReadableInstant) instant).getMillis());
-        } else {
-            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-            setMillis(converter.getInstantMillis(instant));
-        }
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        setMillis(converter.getInstantMillis(instant));
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index a1a1665d9..81055d314 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -199,8 +199,9 @@ public final DateTime toTrustedISODateTime() {
 
         DateTimeZone trusted = DateTimeZone.getInstance(zone.getID());
         
-        if (zone == trusted && this instanceof DateTime
-            && getChronology() instanceof ISOChronology) {
+        if (zone == trusted &&
+            getClass() == DateTime.class &&
+            getChronology().getClass() == ISOChronology.class) {
             return (DateTime) this;
         }
         
@@ -348,17 +349,17 @@ public int hashCode() {
      * <p>
      * All ReadableInstant instances are accepted.
      *
-     * @param readableInstant  a readable instant to check against
+     * @param instant  a readable instant to check against
      * @return negative value if this is less, 0 if equal, or positive value if greater
      * @throws NullPointerException if the object is null
      * @throws ClassCastException if the object type is not supported
      */
-    public final int compareTo(Object readableInstant) {
-        if (this == readableInstant) {
+    public final int compareTo(Object instant) {
+        if (this == instant) {
             return 0;
         }
 
-        ReadableInstant otherInstant = (ReadableInstant) readableInstant;
+        ReadableInstant otherInstant = (ReadableInstant) instant;
 
         long otherMillis = otherInstant.getMillis();
         long thisMillis = getMillis();
@@ -377,43 +378,40 @@ public final int compareTo(Object readableInstant) {
     /**
      * Is the millisecond value after the millisecond passed in.
      *
-     * @param readableInstant  an instant to check against
+     * @param instant  an instant to check against, null returns false
      * @return true if the instant is after the instant passed in
-     * @throws IllegalArgumentException if the object is null
      */
-    public final boolean isAfter(ReadableInstant readableInstant) {
-        if (readableInstant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
+    public final boolean isAfter(ReadableInstant instant) {
+        if (instant == null) {
+            return false;
         }
-        return (getMillis() > readableInstant.getMillis());
+        return (getMillis() > instant.getMillis());
     }
 
     /**
      * Is the millisecond value before the millisecond passed in.
      *
-     * @param readableInstant  an instant to check against
+     * @param instant  an instant to check against, null returns false
      * @return true if the instant is before the instant passed in
-     * @throws IllegalArgumentException if the object is null
      */
-    public final boolean isBefore(ReadableInstant readableInstant) {
-        if (readableInstant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
+    public final boolean isBefore(ReadableInstant instant) {
+        if (instant == null) {
+            return false;
         }
-        return (getMillis() < readableInstant.getMillis());
+        return (getMillis() < instant.getMillis());
     }
 
     /**
      * Is the millisecond value equal to the millisecond passed in.
      *
-     * @param readableInstant  an instant to check against
+     * @param instant  an instant to check against, null returns false
      * @return true if the instant is equal to the instant passed in
-     * @throws IllegalArgumentException if the object is null
      */
-    public final boolean isEqual(ReadableInstant readableInstant) {
-        if (readableInstant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
+    public final boolean isEqual(ReadableInstant instant) {
+        if (instant == null) {
+            return false;
         }
-        return (getMillis() == readableInstant.getMillis());
+        return (getMillis() == instant.getMillis());
     }
 
     // Output    

From 926d11d5c71c81d4d0092f9b8bc3a9817a2f0356 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jul 2004 22:39:23 +0000
Subject: [PATCH 0103/1934] Additional tests for DateTime and Instant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@253 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/test/org/joda/time/TestAll.java  |   7 +-
 .../org/joda/time/TestDateTime_Basics.java    | 668 ++++++++++++++++++
 .../joda/time/TestDateTime_Constructors.java  | 544 ++++++++++++++
 .../joda/time/TestDateTime_Properties.java    | 506 +++++++++++++
 .../org/joda/time/TestInstant_Basics.java     | 461 ++++++++++++
 .../joda/time/TestInstant_Constructors.java   | 194 +++++
 6 files changed, 2379 insertions(+), 1 deletion(-)
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestInstant_Basics.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestInstant_Constructors.java

diff --git a/JodaTime/src/test/org/joda/time/TestAll.java b/JodaTime/src/test/org/joda/time/TestAll.java
index 6194f27de..1b139c11a 100644
--- a/JodaTime/src/test/org/joda/time/TestAll.java
+++ b/JodaTime/src/test/org/joda/time/TestAll.java
@@ -72,9 +72,14 @@ public TestAll(String testName) {
 
     public static Test suite() {
         TestSuite suite = new TestSuite();
+        suite.addTest(TestDateTime_Constructors.suite());
+        suite.addTest(TestDateTime_Basics.suite());
+        suite.addTest(TestDateTime_Properties.suite());
         suite.addTest(TestDateTimeComparator.suite());
         suite.addTest(TestDateTimeConstants.suite());
-        suite.addTest(TestParseISO.suite());
+        suite.addTest(TestInstant_Constructors.suite());
+        suite.addTest(TestInstant_Basics.suite());
+//        suite.addTest(TestParseISO.suite());
         return suite;
     }
 
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
new file mode 100644
index 000000000..3575c959c
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
@@ -0,0 +1,668 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+
+/**
+ * This class is a Junit unit test for DateTime.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateTime_Basics extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    // 1970-06-09
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    // 1970-04-05
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    // 1971-05-06
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateTime_Basics.class);
+    }
+
+    public TestDateTime_Basics(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGet() {
+        DateTime test = new DateTime();
+        assertEquals(1, test.get(ISOChronology.getInstance().era()));
+        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));
+        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));
+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));
+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));
+        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));
+        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));
+        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));
+        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));
+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));
+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));
+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));
+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));
+        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));
+        try {
+            test.get(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetMethods() {
+        DateTime test = new DateTime();
+        
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(LONDON, test.getZone());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        
+        assertEquals(1, test.getEra());
+        assertEquals(19, test.getCenturyOfEra());
+        assertEquals(70, test.getYearOfCentury());
+        assertEquals(1970, test.getYearOfEra());
+        assertEquals(1970, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        assertEquals(1970, test.getWeekyear());
+        assertEquals(24, test.getWeekOfWeekyear());
+        assertEquals(2, test.getDayOfWeek());
+        assertEquals(160, test.getDayOfYear());
+        assertEquals(1, test.getHourOfDay());
+        assertEquals(0, test.getMinuteOfHour());
+        assertEquals(60, test.getMinuteOfDay());
+        assertEquals(0, test.getSecondOfMinute());
+        assertEquals(60 * 60, test.getSecondOfDay());
+        assertEquals(0, test.getMillisOfSecond());
+        assertEquals(60 * 60 * 1000, test.getMillisOfDay());
+    }
+
+    public void testEqualsHashCode() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME1);
+        assertEquals(true, test1.equals(test2));
+        assertEquals(true, test2.equals(test1));
+        assertEquals(true, test1.equals(test1));
+        assertEquals(true, test2.equals(test2));
+        assertEquals(true, test1.hashCode() == test2.hashCode());
+        assertEquals(true, test1.hashCode() == test1.hashCode());
+        assertEquals(true, test2.hashCode() == test2.hashCode());
+        
+        DateTime test3 = new DateTime(TEST_TIME2);
+        assertEquals(false, test1.equals(test3));
+        assertEquals(false, test2.equals(test3));
+        assertEquals(false, test3.equals(test1));
+        assertEquals(false, test3.equals(test2));
+        assertEquals(false, test1.hashCode() == test3.hashCode());
+        assertEquals(false, test2.hashCode() == test3.hashCode());
+        
+        assertEquals(false, test1.equals("Hello"));
+        assertEquals(true, test1.equals(new MockInstant()));
+        assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GregorianChronology.getInstance())));
+    }
+    
+    class MockInstant extends AbstractInstant {
+        public String toString() {
+            return null;
+        }
+        public long getMillis() {
+            return TEST_TIME1;
+        }
+        public Chronology getChronology() {
+            return ISOChronology.getInstance();
+        }
+    }
+
+    public void testCompareTo() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test1a = new DateTime(TEST_TIME1);
+        assertEquals(0, test1.compareTo(test1a));
+        assertEquals(0, test1a.compareTo(test1));
+        assertEquals(0, test1.compareTo(test1));
+        assertEquals(0, test1a.compareTo(test1a));
+        
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(-1, test1.compareTo(test2));
+        assertEquals(+1, test2.compareTo(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(-1, test1.compareTo(test3));
+        assertEquals(+1, test3.compareTo(test1));
+        assertEquals(0, test3.compareTo(test2));
+        
+        assertEquals(+1, test2.compareTo(new MockInstant()));
+        assertEquals(0, test1.compareTo(new MockInstant()));
+        
+        try {
+            test1.compareTo(null);
+            fail();
+        } catch (NullPointerException ex) {}
+        try {
+            test1.compareTo(new Date());
+            fail();
+        } catch (ClassCastException ex) {}
+    }
+    
+    public void testIsEqual() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test1a = new DateTime(TEST_TIME1);
+        assertEquals(true, test1.isEqual(test1a));
+        assertEquals(true, test1a.isEqual(test1));
+        assertEquals(true, test1.isEqual(test1));
+        assertEquals(true, test1a.isEqual(test1a));
+        
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(false, test1.isEqual(test2));
+        assertEquals(false, test2.isEqual(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(false, test1.isEqual(test3));
+        assertEquals(false, test3.isEqual(test1));
+        assertEquals(true, test3.isEqual(test2));
+        
+        assertEquals(false, test2.isEqual(new MockInstant()));
+        assertEquals(true, test1.isEqual(new MockInstant()));
+        assertEquals(false, test1.isEqual(null));
+    }
+    
+    public void testIsBefore() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test1a = new DateTime(TEST_TIME1);
+        assertEquals(false, test1.isBefore(test1a));
+        assertEquals(false, test1a.isBefore(test1));
+        assertEquals(false, test1.isBefore(test1));
+        assertEquals(false, test1a.isBefore(test1a));
+        
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.isBefore(test2));
+        assertEquals(false, test2.isBefore(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(true, test1.isBefore(test3));
+        assertEquals(false, test3.isBefore(test1));
+        assertEquals(false, test3.isBefore(test2));
+        
+        assertEquals(false, test2.isBefore(new MockInstant()));
+        assertEquals(false, test1.isBefore(new MockInstant()));
+        assertEquals(false, test1.isBefore(null));
+    }
+    
+    public void testIsAfter() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test1a = new DateTime(TEST_TIME1);
+        assertEquals(false, test1.isAfter(test1a));
+        assertEquals(false, test1a.isAfter(test1));
+        assertEquals(false, test1.isAfter(test1));
+        assertEquals(false, test1a.isAfter(test1a));
+        
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(false, test1.isAfter(test2));
+        assertEquals(true, test2.isAfter(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(false, test1.isAfter(test3));
+        assertEquals(true, test3.isAfter(test1));
+        assertEquals(false, test3.isAfter(test2));
+        
+        assertEquals(true, test2.isAfter(new MockInstant()));
+        assertEquals(false, test1.isAfter(new MockInstant()));
+        assertEquals(false, test1.isAfter(null));
+    }
+    
+    //-----------------------------------------------------------------------
+    public void testSerialization() throws Exception {
+        DateTime test = new DateTime(TEST_TIME_NOW);
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject(test);
+        byte[] bytes = baos.toByteArray();
+        oos.close();
+        
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        ObjectInputStream ois = new ObjectInputStream(bais);
+        DateTime result = (DateTime) ois.readObject();
+        ois.close();
+        
+        assertEquals(test, result);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        DateTime test = new DateTime(TEST_TIME_NOW);
+        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString());
+        
+        test = new DateTime(TEST_TIME_NOW, PARIS);
+        assertEquals("1970-06-09T02:00:00.000+02:00", test.toString());
+    }
+
+    public void testToString_String() {
+        DateTime test = new DateTime(TEST_TIME_NOW);
+        assertEquals("1970 01", test.toString("yyyy HH"));
+        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null));
+    }
+
+    public void testToString_String_String() {
+        DateTime test = new DateTime(TEST_TIME_NOW);
+        assertEquals("Tue 9/6", test.toString("EEE d/M", Locale.ENGLISH));
+        assertEquals("mar. 9/6", test.toString("EEE d/M", Locale.FRENCH));
+        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));
+        assertEquals("Tue 9/6", test.toString("EEE d/M", null));
+        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null, null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToInstant() {
+        DateTime test = new DateTime(TEST_TIME1);
+        Instant result = test.toInstant();
+        assertEquals(TEST_TIME1, result.getMillis());
+    }
+
+    public void testToDateTime() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.toDateTime();
+        assertSame(test, result);
+    }
+
+    public void testToDateTime_DateTimeZone() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.toDateTime(LONDON);
+        assertSame(test, result);
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toDateTime(PARIS);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(PARIS, result.getZone());
+
+        test = new DateTime(TEST_TIME1, PARIS);
+        result = test.toDateTime((DateTimeZone) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(LONDON, result.getZone());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toDateTime((DateTimeZone) null);
+        assertSame(test, result);
+    }
+
+    public void testToDateTime_Chronology() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.toDateTime(ISOChronology.getInstance());
+        assertSame(test, result);
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toDateTime(GregorianChronology.getInstance(PARIS));
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());
+
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.toDateTime((Chronology) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toDateTime((Chronology) null);
+        assertSame(test, result);
+    }
+
+    public void testToTrustedISODateTime() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.toTrustedISODateTime();
+        assertSame(test, result);
+        assertSame(DateTime.class, result.getClass());
+        assertSame(ISOChronology.class, result.getChronology().getClass());
+
+        test = new MockUntrustedDateTime(TEST_TIME1);
+        result = test.toTrustedISODateTime();
+        assertSame(DateTime.class, result.getClass());
+        assertSame(ISOChronology.class, result.getChronology().getClass());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1, new MockUntrustedZone("Europe/Paris"));
+        result = test.toTrustedISODateTime();
+        assertSame(DateTime.class, result.getClass());
+        assertSame(ISOChronology.class, result.getChronology().getClass());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+    }
+
+    static class MockUntrustedDateTime extends DateTime {
+        MockUntrustedDateTime(long millis) {
+            super(millis);
+        }
+    }
+
+    static class MockUntrustedZone extends DateTimeZone {
+        MockUntrustedZone(String id) {
+            super(id);
+        }
+        public String getNameKey(long instant) {
+            return null;
+        }
+        public int getOffset(long instant) {
+            return 60 * 60 * 1000;
+        }
+        public int getStandardOffset(long instant) {
+            return 60 * 60 * 1000;
+        }
+        public boolean isFixed() {
+            return true;
+        }
+        public long nextTransition(long instant) {
+            return 0;
+        }
+        public long previousTransition(long instant) {
+            return 0;
+        }
+        public boolean equals(Object object) {
+            return false;
+        }
+    }
+
+    public void testToMutableDateTime() {
+        DateTime test = new DateTime(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime();
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToMutableDateTime_DateTimeZone() {
+        DateTime test = new DateTime(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime(LONDON);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toMutableDateTime(PARIS);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+
+        test = new DateTime(TEST_TIME1, PARIS);
+        result = test.toMutableDateTime((DateTimeZone) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toMutableDateTime((DateTimeZone) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToMutableDateTime_Chronology() {
+        DateTime test = new DateTime(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());
+
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.toMutableDateTime((Chronology) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new DateTime(TEST_TIME1);
+        result = test.toMutableDateTime((Chronology) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToDate() {
+        DateTime test = new DateTime(TEST_TIME1);
+        Date result = test.toDate();
+        assertEquals(test.getMillis(), result.getTime());
+    }
+
+    public void testToCalendar_Locale() {
+        DateTime test = new DateTime(TEST_TIME1);
+        Calendar result = test.toCalendar(null);
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());
+
+        test = new DateTime(TEST_TIME1, PARIS);
+        result = test.toCalendar(null);
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());
+
+        test = new DateTime(TEST_TIME1, PARIS);
+        result = test.toCalendar(Locale.UK);
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());
+    }
+
+    public void testToGregorianCalendar() {
+        DateTime test = new DateTime(TEST_TIME1);
+        GregorianCalendar result = test.toGregorianCalendar();
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());
+
+        test = new DateTime(TEST_TIME1, PARIS);
+        result = test.toGregorianCalendar();
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testWithMillis_long() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.withMillis(TEST_TIME2);
+        assertEquals(TEST_TIME2, result.getMillis());
+        assertEquals(test.getChronology(), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.withMillis(TEST_TIME2);
+        assertEquals(TEST_TIME2, result.getMillis());
+        assertEquals(test.getChronology(), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1);
+        result = test.withMillis(TEST_TIME1);
+        assertSame(test, result);
+    }
+
+    public void testWithChronology_Chronology() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.withChronology(GregorianChronology.getInstance(PARIS));
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.withChronology(null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1);
+        result = test.withChronology(null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1);
+        result = test.withChronology(ISOChronology.getInstance());
+        assertSame(test, result);
+    }
+
+    public void testWithZone_DateTimeZone() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.withZone(PARIS);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.withZone(null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1);
+        result = test.withZone(null);
+        assertSame(test, result);
+    }
+
+    public void testWithZoneRetainFields_DateTimeZone() {
+        DateTime test = new DateTime(TEST_TIME1);
+        DateTime result = test.withZoneRetainFields(PARIS);
+        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+        
+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
+        result = test.withZoneRetainFields(null);
+        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());
+        assertEquals(GregorianChronology.getInstance(), result.getChronology());
+    }
+    
+    public void testImmutable() {
+        MockChangeDateTime test = new MockChangeDateTime(TEST_TIME_NOW);
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        test.testSetMillis();
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        
+        test = new MockChangeDateTime(TEST_TIME_NOW);
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        test.testSetMillisObject();
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        
+        test = new MockChangeDateTime(TEST_TIME_NOW);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        test.testSetChronology();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        
+        test = new MockChangeDateTime(TEST_TIME_NOW);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        test.testSetZone();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        
+        test = new MockChangeDateTime(TEST_TIME_NOW);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        test.testSetZoneRetainFields();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+    }
+    
+    static class MockChangeDateTime extends DateTime {
+        MockChangeDateTime(long instant) {
+            super(instant);
+        }
+        public void testSetMillis() {
+            setMillis(0L);
+        }
+        public void testSetMillisObject() {
+            setMillis(new Date(0L));
+        }
+        public void testSetChronology() {
+            setChronology(GregorianChronology.getInstance(PARIS));
+        }
+        public void testSetZone() {
+            setZone(PARIS);
+        }
+        public void testSetZoneRetainFields() {
+            setZoneRetainFields(PARIS);
+        }
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java b/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
new file mode 100644
index 000000000..66af2e17d
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
@@ -0,0 +1,544 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.util.Date;
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.MockZeroNullIntegerConverter;
+
+/**
+ * This class is a Junit unit test for DateTime.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateTime_Constructors extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    // 1970-06-09
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    // 1970-04-05
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    // 1971-05-06
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateTime_Constructors.class);
+    }
+
+    public TestDateTime_Constructors(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        DateTime test = new DateTime();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (DateTimeZone)
+     */
+    public void testConstructor_DateTimeZone() throws Throwable {
+        DateTime test = new DateTime(PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (DateTimeZone=null)
+     */
+    public void testConstructor_nullDateTimeZone() throws Throwable {
+        DateTime test = new DateTime((DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Chronology)
+     */
+    public void testConstructor_Chronology() throws Throwable {
+        DateTime test = new DateTime(GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Chronology=null)
+     */
+    public void testConstructor_nullChronology() throws Throwable {
+        DateTime test = new DateTime((Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long1() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME1);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long2() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME2);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME2, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone)
+     */
+    public void testConstructor_long1_DateTimeZone() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME1, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone)
+     */
+    public void testConstructor_long2_DateTimeZone() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME2, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME2, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone=null)
+     */
+    public void testConstructor_long_nullDateTimeZone() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long1_Chronology() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long2_Chronology() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME2, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology=null)
+     */
+    public void testConstructor_long_nullChronology() throws Throwable {
+        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        DateTime test = new DateTime(date);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_invalidObject() throws Throwable {
+        try {
+            new DateTime(new Object());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_nullObject() throws Throwable {
+        DateTime test = new DateTime((Object) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateTime test = new DateTime(new Integer(0));
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_Object_DateTimeZone() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        DateTime test = new DateTime(date, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {
+        try {
+            new DateTime(new Object(), PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null, DateTimeZone)
+     */
+    public void testConstructor_nullObject_DateTimeZone() throws Throwable {
+        DateTime test = new DateTime((Object) null, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone=null)
+     */
+    public void testConstructor_Object_nullDateTimeZone() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        DateTime test = new DateTime(date, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null, DateTimeZone=null)
+     */
+    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {
+        DateTime test = new DateTime((Object) null, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_Object_Chronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        DateTime test = new DateTime(date, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_invalidObject_Chronology() throws Throwable {
+        try {
+            new DateTime(new Object(), GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology)
+     */
+    public void testConstructor_nullObject_Chronology() throws Throwable {
+        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology=null)
+     */
+    public void testConstructor_Object_nullChronology() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        DateTime test = new DateTime(date, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology=null)
+     */
+    public void testConstructor_nullObject_nullChronology() throws Throwable {
+        DateTime test = new DateTime((Object) null, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_badconverterObject_Chronology() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (int, int, int)
+     */
+    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {
+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0);  // +01:00
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(LONDON, test.getZone());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        try {
+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 0, 9, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 13, 9, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 0, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 31, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateTime(1970, 7, 31, 0, 0, 0, 0);
+        try {
+            new DateTime(1970, 7, 32, 0, 0, 0, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, DateTimeZone)
+     */
+    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {
+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, PARIS);  // +01:00
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        try {
+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 0, 9, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 13, 9, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 0, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 31, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateTime(1970, 7, 31, 0, 0, 0, 0, PARIS);
+        try {
+            new DateTime(1970, 7, 32, 0, 0, 0, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, DateTimeZone=null)
+     */
+    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {
+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {
+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+        try {
+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateTime(1970, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateTime(1970, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
+        try {
+            new DateTime(1970, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {
+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
new file mode 100644
index 000000000..dffab6507
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -0,0 +1,506 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * This class is a Junit unit test for DateTime.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateTime_Properties extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    // 1970-06-09
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    // 1970-04-05
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    // 1971-05-06
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateTime_Properties.class);
+    }
+
+    public TestDateTime_Properties(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().year(), test.year().getField());
+        assertEquals("year", test.year().getName());
+        assertEquals("Property[year]", test.year().toString());
+        assertSame(test, test.year().getInstant());
+        assertSame(test, test.year().getDateTime());
+        assertEquals(1972, test.year().get());
+        assertEquals("1972", test.year().getAsText());
+        assertEquals("1972", test.year().getAsText(Locale.FRENCH));
+        assertEquals("1972", test.year().getAsShortText());
+        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().years(), test.year().getDurationField());
+        assertEquals(null, test.year().getRangeDurationField());
+        assertEquals(9, test.year().getMaximumTextLength(null));
+        assertEquals(9, test.year().getMaximumShortTextLength(null));
+    }
+
+    public void testPropertyGetMaxMinValuesYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(-292275054, test.year().getMinimumValue());
+        assertEquals(-292275054, test.year().getMinimumValueOverall());
+        assertEquals(292277023, test.year().getMaximumValue());
+        assertEquals(292277023, test.year().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.year().addToCopy(9);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1981-06-09T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.year().addToCopy(0);
+        assertEquals("1972-06-09T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.year().addToCopy(292277023 - 1972);
+        assertEquals(292277023, copy.getYear());
+        
+        try {
+            test.year().addToCopy(292277023 - 1972 + 1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        copy = test.year().addToCopy(-1972);
+        assertEquals(0, copy.getYear());
+        
+        copy = test.year().addToCopy(-1973);
+        assertEquals(-1, copy.getYear());
+        
+        try {
+            test.year().addToCopy(-292275054 - 1972 - 1);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertyAddInFieldYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.year().addWrappedToCopy(9);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1981-06-09T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.year().addWrappedToCopy(0);
+        assertEquals(1972, copy.getYear());
+        
+        copy = test.year().addWrappedToCopy(292277023 - 1972 + 1);
+        assertEquals(-292275054, copy.getYear());
+        
+        copy = test.year().addWrappedToCopy(-292275054 - 1972 - 1);
+        assertEquals(292277023, copy.getYear());
+    }
+
+    public void testPropertySetYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.year().setCopy(1960);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertySetTextYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.year().setCopy("1960");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertyCompareToYear() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.year().compareTo(test2) < 0);
+        assertEquals(true, test2.year().compareTo(test1) > 0);
+        assertEquals(true, test1.year().compareTo(test1) == 0);
+        try {
+            test1.year().compareTo(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+//    //-----------------------------------------------------------------------
+//    public void testPropertyGetMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
+//        assertEquals("monthOfYear", test.monthOfYear().getName());
+//        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
+//        assertSame(test, test.monthOfYear().getReadablePartial());
+//        assertSame(test, test.monthOfYear().getDateTime());
+//        assertEquals(6, test.monthOfYear().get());
+//        assertEquals("June", test.monthOfYear().getAsText());
+//        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));
+//        assertEquals("Jun", test.monthOfYear().getAsShortText());
+//        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));
+//        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());
+//        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
+//        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
+//        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
+//        test = new DateTime(1972, 7, 9);
+//        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
+//        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));
+//    }
+//
+//    public void testPropertyGetMaxMinValuesMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        assertEquals(1, test.monthOfYear().getMinimumValue());
+//        assertEquals(1, test.monthOfYear().getMinimumValueOverall());
+//        assertEquals(12, test.monthOfYear().getMaximumValue());
+//        assertEquals(12, test.monthOfYear().getMaximumValueOverall());
+//    }
+//
+//    public void testPropertyAddMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.monthOfYear().addCopy(6);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 12, 9);
+//        
+//        copy = test.monthOfYear().addCopy(7);
+//        check(copy, 1973, 1, 9);
+//        
+//        copy = test.monthOfYear().addCopy(-5);
+//        check(copy, 1972, 1, 9);
+//        
+//        copy = test.monthOfYear().addCopy(-6);
+//        check(copy, 1971, 12, 9);
+//        
+//        test = new DateTime(1972, 1, 31);
+//        copy = test.monthOfYear().addCopy(1);
+//        check(copy, 1972, 2, 29);
+//        
+//        copy = test.monthOfYear().addCopy(2);
+//        check(copy, 1972, 3, 31);
+//        
+//        copy = test.monthOfYear().addCopy(3);
+//        check(copy, 1972, 4, 30);
+//        
+//        test = new DateTime(1971, 1, 31);
+//        copy = test.monthOfYear().addCopy(1);
+//        check(copy, 1971, 2, 28);
+//    }
+//
+//    public void testPropertyAddInFieldMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.monthOfYear().addWrappedToCopy(4);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 10, 9);
+//        
+//        copy = test.monthOfYear().addWrappedToCopy(8);
+//        check(copy, 1972, 2, 9);
+//        
+//        copy = test.monthOfYear().addWrappedToCopy(-8);
+//        check(copy, 1972, 10, 9);
+//        
+//        test = new DateTime(1972, 1, 31);
+//        copy = test.monthOfYear().addWrappedToCopy(1);
+//        check(copy, 1972, 2, 29);
+//        
+//        copy = test.monthOfYear().addWrappedToCopy(2);
+//        check(copy, 1972, 3, 31);
+//        
+//        copy = test.monthOfYear().addWrappedToCopy(3);
+//        check(copy, 1972, 4, 30);
+//        
+//        test = new DateTime(1971, 1, 31);
+//        copy = test.monthOfYear().addWrappedToCopy(1);
+//        check(copy, 1971, 2, 28);
+//    }
+//
+//    public void testPropertySetMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.monthOfYear().setCopy(12);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 12, 9);
+//        
+//        test = new DateTime(1972, 1, 31);
+//        copy = test.monthOfYear().setCopy(2);
+//        check(copy, 1972, 2, 29);
+//        
+//        try {
+//            test.monthOfYear().setCopy(13);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//        try {
+//            test.monthOfYear().setCopy(0);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//    }
+//
+//    public void testPropertySetTextMonth() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.monthOfYear().setCopy("12");
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 12, 9);
+//        
+//        copy = test.monthOfYear().setCopy("December");
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 12, 9);
+//        
+//        copy = test.monthOfYear().setCopy("Dec");
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 12, 9);
+//    }
+//
+//    public void testPropertyCompareToMonth() {
+//        DateTime test1 = new DateTime(TEST_TIME1);
+//        DateTime test2 = new DateTime(TEST_TIME2);
+//        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);
+//        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);
+//        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);
+//        try {
+//            test1.monthOfYear().compareTo((ReadablePartial) null);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//        
+//        DateTime dt1 = new DateTime(TEST_TIME1);
+//        DateTime dt2 = new DateTime(TEST_TIME2);
+//        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);
+//        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);
+//        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);
+//        try {
+//            test1.monthOfYear().compareTo((ReadableInstant) null);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//    }
+//
+//    //-----------------------------------------------------------------------
+//    public void testPropertyGetDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
+//        assertEquals("dayOfMonth", test.dayOfMonth().getName());
+//        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
+//        assertSame(test, test.dayOfMonth().getReadablePartial());
+//        assertSame(test, test.dayOfMonth().getDateTime());
+//        assertEquals(9, test.dayOfMonth().get());
+//        assertEquals("9", test.dayOfMonth().getAsText());
+//        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));
+//        assertEquals("9", test.dayOfMonth().getAsShortText());
+//        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));
+//        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());
+//        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());
+//        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));
+//        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));
+//    }
+//
+//    public void testPropertyGetMaxMinValuesDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        assertEquals(1, test.dayOfMonth().getMinimumValue());
+//        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
+//        assertEquals(30, test.dayOfMonth().getMaximumValue());
+//        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
+//        test = new DateTime(1972, 7, 9);
+//        assertEquals(31, test.dayOfMonth().getMaximumValue());
+//        test = new DateTime(1972, 2, 9);
+//        assertEquals(29, test.dayOfMonth().getMaximumValue());
+//        test = new DateTime(1971, 2, 9);
+//        assertEquals(28, test.dayOfMonth().getMaximumValue());
+//    }
+//
+//    public void testPropertyAddDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.dayOfMonth().addCopy(9);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 6, 18);
+//        
+//        copy = test.dayOfMonth().addCopy(21);
+//        check(copy, 1972, 6, 30);
+//        
+//        copy = test.dayOfMonth().addCopy(22);
+//        check(copy, 1972, 7, 1);
+//        
+//        copy = test.dayOfMonth().addCopy(22 + 30);
+//        check(copy, 1972, 7, 31);
+//        
+//        copy = test.dayOfMonth().addCopy(22 + 31);
+//        check(copy, 1972, 8, 1);
+//
+//        copy = test.dayOfMonth().addCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+//        check(copy, 1972, 12, 31);
+//        
+//        copy = test.dayOfMonth().addCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+//        check(copy, 1973, 1, 1);
+//        
+//        copy = test.dayOfMonth().addCopy(-8);
+//        check(copy, 1972, 6, 1);
+//        
+//        copy = test.dayOfMonth().addCopy(-9);
+//        check(copy, 1972, 5, 31);
+//        
+//        copy = test.dayOfMonth().addCopy(-8 - 31 - 30 - 31 - 29 - 31);
+//        check(copy, 1972, 1, 1);
+//        
+//        copy = test.dayOfMonth().addCopy(-9 - 31 - 30 - 31 - 29 - 31);
+//        check(copy, 1971, 12, 31);
+//    }
+//
+//    public void testPropertyAddInFieldDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.dayOfMonth().addWrappedToCopy(21);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 6, 30);
+//        
+//        copy = test.dayOfMonth().addWrappedToCopy(22);
+//        check(copy, 1972, 6, 1);
+//        
+//        copy = test.dayOfMonth().addWrappedToCopy(-12);
+//        check(copy, 1972, 6, 27);
+//        
+//        test = new DateTime(1972, 7, 9);
+//        copy = test.dayOfMonth().addWrappedToCopy(21);
+//        check(copy, 1972, 7, 30);
+//    
+//        copy = test.dayOfMonth().addWrappedToCopy(22);
+//        check(copy, 1972, 7, 31);
+//    
+//        copy = test.dayOfMonth().addWrappedToCopy(23);
+//        check(copy, 1972, 7, 1);
+//    
+//        copy = test.dayOfMonth().addWrappedToCopy(-12);
+//        check(copy, 1972, 7, 28);
+//    }
+//
+//    public void testPropertySetDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.dayOfMonth().setCopy(12);
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 6, 12);
+//        
+//        try {
+//            test.dayOfMonth().setCopy(31);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//        try {
+//            test.dayOfMonth().setCopy(0);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//    }
+//
+//    public void testPropertySetTextDay() {
+//        DateTime test = new DateTime(1972, 6, 9);
+//        DateTime copy = test.dayOfMonth().setCopy("12");
+//        check(test, 1972, 6, 9);
+//        check(copy, 1972, 6, 12);
+//    }
+//
+//    public void testPropertyCompareToDay() {
+//        DateTime test1 = new DateTime(TEST_TIME1);
+//        DateTime test2 = new DateTime(TEST_TIME2);
+//        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);
+//        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);
+//        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);
+//        try {
+//            test1.dayOfMonth().compareTo((ReadablePartial) null);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//        
+//        DateTime dt1 = new DateTime(TEST_TIME1);
+//        DateTime dt2 = new DateTime(TEST_TIME2);
+//        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);
+//        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);
+//        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);
+//        try {
+//            test1.dayOfMonth().compareTo((ReadableInstant) null);
+//            fail();
+//        } catch (IllegalArgumentException ex) {}
+//    }
+//
+//    //-----------------------------------------------------------------------
+//    private void check(DateTime test, int hour, int min, int sec) {
+//        assertEquals(hour, test.getYear());
+//        assertEquals(min, test.getMonthOfYear());
+//        assertEquals(sec, test.getDayOfMonth());
+//    }
+}
diff --git a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java
new file mode 100644
index 000000000..c847878fc
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java
@@ -0,0 +1,461 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.lang.reflect.Modifier;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+
+/**
+ * This class is a Junit unit test for Instant.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestInstant_Basics extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    // 1970-06-09
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    // 1970-04-05
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    // 1971-05-06
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestInstant_Basics.class);
+    }
+
+    public TestInstant_Basics(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGet() {
+        Instant test = new Instant();
+        assertEquals(1, test.get(ISOChronology.getInstance().era()));
+        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));
+        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));
+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));
+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));
+        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));
+        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));
+        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));
+        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));
+        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));
+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));
+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));
+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));
+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));
+        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));
+        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));
+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));
+        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));
+        try {
+            test.get(null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testGetMethods() {
+        Instant test = new Instant();
+        
+        assertEquals(null, test.getChronology());
+        assertEquals(null, test.getZone());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    public void testEqualsHashCode() {
+        Instant test1 = new Instant(TEST_TIME1);
+        Instant test2 = new Instant(TEST_TIME1);
+        assertEquals(true, test1.equals(test2));
+        assertEquals(true, test2.equals(test1));
+        assertEquals(true, test1.equals(test1));
+        assertEquals(true, test2.equals(test2));
+        assertEquals(true, test1.hashCode() == test2.hashCode());
+        assertEquals(true, test1.hashCode() == test1.hashCode());
+        assertEquals(true, test2.hashCode() == test2.hashCode());
+        
+        Instant test3 = new Instant(TEST_TIME2);
+        assertEquals(false, test1.equals(test3));
+        assertEquals(false, test2.equals(test3));
+        assertEquals(false, test3.equals(test1));
+        assertEquals(false, test3.equals(test2));
+        assertEquals(false, test1.hashCode() == test3.hashCode());
+        assertEquals(false, test2.hashCode() == test3.hashCode());
+        
+        assertEquals(false, test1.equals("Hello"));
+        assertEquals(true, test1.equals(new MockInstant()));
+        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));
+    }
+    
+    class MockInstant extends AbstractInstant {
+        public String toString() {
+            return null;
+        }
+        public long getMillis() {
+            return TEST_TIME1;
+        }
+        public Chronology getChronology() {
+            return null;
+        }
+    }
+
+    public void testCompareTo() {
+        Instant test1 = new Instant(TEST_TIME1);
+        Instant test1a = new Instant(TEST_TIME1);
+        assertEquals(0, test1.compareTo(test1a));
+        assertEquals(0, test1a.compareTo(test1));
+        assertEquals(0, test1.compareTo(test1));
+        assertEquals(0, test1a.compareTo(test1a));
+        
+        Instant test2 = new Instant(TEST_TIME2);
+        assertEquals(-1, test1.compareTo(test2));
+        assertEquals(+1, test2.compareTo(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(-1, test1.compareTo(test3));
+        assertEquals(+1, test3.compareTo(test1));
+        assertEquals(0, test3.compareTo(test2));
+        
+        assertEquals(+1, test2.compareTo(new MockInstant()));
+        assertEquals(0, test1.compareTo(new MockInstant()));
+        
+        try {
+            test1.compareTo(null);
+            fail();
+        } catch (NullPointerException ex) {}
+        try {
+            test1.compareTo(new Date());
+            fail();
+        } catch (ClassCastException ex) {}
+    }
+    
+    public void testIsEqual() {
+        Instant test1 = new Instant(TEST_TIME1);
+        Instant test1a = new Instant(TEST_TIME1);
+        assertEquals(true, test1.isEqual(test1a));
+        assertEquals(true, test1a.isEqual(test1));
+        assertEquals(true, test1.isEqual(test1));
+        assertEquals(true, test1a.isEqual(test1a));
+        
+        Instant test2 = new Instant(TEST_TIME2);
+        assertEquals(false, test1.isEqual(test2));
+        assertEquals(false, test2.isEqual(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(false, test1.isEqual(test3));
+        assertEquals(false, test3.isEqual(test1));
+        assertEquals(true, test3.isEqual(test2));
+        
+        assertEquals(false, test2.isEqual(new MockInstant()));
+        assertEquals(true, test1.isEqual(new MockInstant()));
+        assertEquals(false, test1.isEqual(null));
+    }
+    
+    public void testIsBefore() {
+        Instant test1 = new Instant(TEST_TIME1);
+        Instant test1a = new Instant(TEST_TIME1);
+        assertEquals(false, test1.isBefore(test1a));
+        assertEquals(false, test1a.isBefore(test1));
+        assertEquals(false, test1.isBefore(test1));
+        assertEquals(false, test1a.isBefore(test1a));
+        
+        Instant test2 = new Instant(TEST_TIME2);
+        assertEquals(true, test1.isBefore(test2));
+        assertEquals(false, test2.isBefore(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(true, test1.isBefore(test3));
+        assertEquals(false, test3.isBefore(test1));
+        assertEquals(false, test3.isBefore(test2));
+        
+        assertEquals(false, test2.isBefore(new MockInstant()));
+        assertEquals(false, test1.isBefore(new MockInstant()));
+        assertEquals(false, test1.isBefore(null));
+    }
+    
+    public void testIsAfter() {
+        Instant test1 = new Instant(TEST_TIME1);
+        Instant test1a = new Instant(TEST_TIME1);
+        assertEquals(false, test1.isAfter(test1a));
+        assertEquals(false, test1a.isAfter(test1));
+        assertEquals(false, test1.isAfter(test1));
+        assertEquals(false, test1a.isAfter(test1a));
+        
+        Instant test2 = new Instant(TEST_TIME2);
+        assertEquals(false, test1.isAfter(test2));
+        assertEquals(true, test2.isAfter(test1));
+        
+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));
+        assertEquals(false, test1.isAfter(test3));
+        assertEquals(true, test3.isAfter(test1));
+        assertEquals(false, test3.isAfter(test2));
+        
+        assertEquals(true, test2.isAfter(new MockInstant()));
+        assertEquals(false, test1.isAfter(new MockInstant()));
+        assertEquals(false, test1.isAfter(null));
+    }
+    
+    //-----------------------------------------------------------------------
+    public void testSerialization() throws Exception {
+        Instant test = new Instant(TEST_TIME_NOW);
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject(test);
+        byte[] bytes = baos.toByteArray();
+        oos.close();
+        
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        ObjectInputStream ois = new ObjectInputStream(bais);
+        Instant result = (Instant) ois.readObject();
+        ois.close();
+        
+        assertEquals(test, result);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        Instant test = new Instant(TEST_TIME_NOW);
+        assertEquals("1970-06-09T00:00:00.000Z", test.toString());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToInstant() {
+        Instant test = new Instant(TEST_TIME1);
+        Instant result = test.toInstant();
+        assertSame(test, result);
+    }
+
+    public void testToDateTime() {
+        Instant test = new Instant(TEST_TIME1);
+        DateTime result = test.toDateTime();
+        assertEquals(TEST_TIME1, result.getMillis());
+    }
+
+    public void testToDateTime_DateTimeZone() {
+        Instant test = new Instant(TEST_TIME1);
+        DateTime result = test.toDateTime(LONDON);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toDateTime(PARIS);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toDateTime((DateTimeZone) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToDateTime_Chronology() {
+        Instant test = new Instant(TEST_TIME1);
+        DateTime result = test.toDateTime(ISOChronology.getInstance());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toDateTime(GregorianChronology.getInstance(PARIS));
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toDateTime((Chronology) null);
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToTrustedISODateTime() {
+        Instant test = new Instant(TEST_TIME1);
+        DateTime result = test.toTrustedISODateTime();
+        assertSame(DateTime.class, result.getClass());
+        assertSame(ISOChronology.class, result.getChronology().getClass());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToMutableDateTime() {
+        Instant test = new Instant(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime();
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToMutableDateTime_DateTimeZone() {
+        Instant test = new Instant(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime(LONDON);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toMutableDateTime(PARIS);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toMutableDateTime((DateTimeZone) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToMutableDateTime_Chronology() {
+        Instant test = new Instant(TEST_TIME1);
+        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toMutableDateTime((Chronology) null);
+        assertEquals(test.getMillis(), result.getMillis());
+        assertEquals(ISOChronology.getInstance(), result.getChronology());
+    }
+
+    public void testToDate() {
+        Instant test = new Instant(TEST_TIME1);
+        Date result = test.toDate();
+        assertEquals(test.getMillis(), result.getTime());
+    }
+
+    public void testToCalendar_Locale() {
+        Instant test = new Instant(TEST_TIME1);
+        Calendar result = test.toCalendar(null);
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());
+
+        test = new Instant(TEST_TIME1);
+        result = test.toCalendar(Locale.UK);
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());
+    }
+
+    public void testToGregorianCalendar() {
+        Instant test = new Instant(TEST_TIME1);
+        GregorianCalendar result = test.toGregorianCalendar();
+        assertEquals(test.getMillis(), result.getTime().getTime());
+        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testWithMillis_long() {
+        Instant test = new Instant(TEST_TIME1);
+        Instant result = test.withMillis(TEST_TIME2);
+        assertEquals(TEST_TIME2, result.getMillis());
+        assertEquals(test.getChronology(), result.getChronology());
+        
+        test = new Instant(TEST_TIME1);
+        result = test.withMillis(TEST_TIME1);
+        assertSame(test, result);
+    }
+
+    public void testImmutable() {
+        assertTrue(Modifier.isFinal(Instant.class.getModifiers()));
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java b/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java
new file mode 100644
index 000000000..6fd5088c7
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java
@@ -0,0 +1,194 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.util.Date;
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.MockZeroNullIntegerConverter;
+
+/**
+ * This class is a Junit unit test for Instant.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestInstant_Constructors extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    // 1970-06-09
+    private long TEST_TIME_NOW =
+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            
+    // 1970-04-05
+    private long TEST_TIME1 =
+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 12L * DateTimeConstants.MILLIS_PER_HOUR
+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    // 1971-05-06
+    private long TEST_TIME2 =
+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
+        + 14L * DateTimeConstants.MILLIS_PER_HOUR
+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+        
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestInstant_Constructors.class);
+    }
+
+    public TestInstant_Constructors(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        Instant test = new Instant();
+        assertEquals(null, test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long1() throws Throwable {
+        Instant test = new Instant(TEST_TIME1);
+        assertEquals(null, test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long2() throws Throwable {
+        Instant test = new Instant(TEST_TIME2);
+        assertEquals(null, test.getChronology());
+        assertEquals(TEST_TIME2, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        Date date = new Date(TEST_TIME1);
+        Instant test = new Instant(date);
+        assertEquals(null, test.getChronology());
+        assertEquals(TEST_TIME1, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_invalidObject() throws Throwable {
+        try {
+            new Instant(new Object());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_nullObject() throws Throwable {
+        Instant test = new Instant((Object) null);
+        assertEquals(null, test.getChronology());
+        assertEquals(TEST_TIME_NOW, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            Instant test = new Instant(new Integer(0));
+            assertEquals(null, test.getChronology());
+            assertEquals(0L, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+}

From 41bf694486c947573079a315f7f44fae1b0041f3 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 6 Jul 2004 22:27:10 +0000
Subject: [PATCH 0104/1934] Fixes from testing

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@254 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/convert/AbstractConverter.java   | 2 +-
 .../src/java/org/joda/time/convert/CalendarConverter.java   | 6 +++---
 JodaTime/src/java/org/joda/time/convert/LongConverter.java  | 3 ++-
 3 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
index 2561f1c3b..26a552351 100644
--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -168,7 +168,7 @@ public Chronology getChronology(Object object, Chronology chrono) {
      * @return a debugging string
      */
     public String toString() {
-        return "Converter[" + getSupportedType() + "]";
+        return "Converter[" + (getSupportedType() == null ? "null" : getSupportedType().getName()) + "]";
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
index 0a9e442e7..9f46d820d 100644
--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
@@ -126,7 +126,9 @@ public Chronology getChronology(Object object) {
      * @return the chronology, never null
      */
     public Chronology getChronology(Object object, DateTimeZone zone) {
-        if (object instanceof GregorianCalendar) {
+        if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
+            return BuddhistChronology.getInstance(zone);
+        } else if (object instanceof GregorianCalendar) {
             GregorianCalendar gc = (GregorianCalendar) object;
             long cutover = gc.getGregorianChange().getTime();
             if (cutover == Long.MIN_VALUE) {
@@ -136,8 +138,6 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
             } else {
                 return GJChronology.getInstance(zone, cutover, 4);
             }
-        } else if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
-            return BuddhistChronology.getInstance(zone);
         } else {
             return ISOChronology.getInstance(zone);
         }
diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index ebedfc3dc..6efd294f9 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -58,6 +58,7 @@
 
 /**
  * LongConverter converts a Long to milliseconds in the ISOChronology.
+ * The duration type created is the millis type.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
@@ -127,7 +128,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getAverageYearMonthType();
+        return DurationType.getMillisType();
     }
 
     //-----------------------------------------------------------------------

From e94730d5f9a0b4cfa60325e4c500728343d24765 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 6 Jul 2004 22:27:42 +0000
Subject: [PATCH 0105/1934] Test classes for converters

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@255 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/convert/MockUnknownCalendar.java     | 104 +++++++++
 .../test/org/joda/time/convert/TestAll.java   |   6 +
 .../time/convert/TestCalendarConverter.java   | 220 ++++++++++++++++++
 .../joda/time/convert/TestDateConverter.java  | 153 ++++++++++++
 .../joda/time/convert/TestLongConverter.java  |  16 +-
 .../joda/time/convert/TestNullConverter.java  | 169 ++++++++++++++
 .../TestReadableDurationConverter.java        | 144 ++++++++++++
 .../convert/TestReadableInstantConverter.java | 165 +++++++++++++
 8 files changed, 975 insertions(+), 2 deletions(-)
 create mode 100644 JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestDateConverter.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestNullConverter.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java

diff --git a/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java b/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
new file mode 100644
index 000000000..a98f83cc1
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
@@ -0,0 +1,104 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.util.Calendar;
+import java.util.TimeZone;
+
+/**
+ * A basic mock testing class for an unknown calendar.
+ *
+ * @author Stephen Colebourne
+ */
+public class MockUnknownCalendar extends Calendar {
+    
+    private long millis;
+    private TimeZone zone;
+    
+    MockUnknownCalendar(long millis) {
+        this.millis = millis;
+    }
+    MockUnknownCalendar(TimeZone zone) {
+        this.zone = zone;
+    }
+    
+    public long getTimeInMillis() {
+        return millis;
+    }
+    public TimeZone getTimeZone() {
+        return zone;
+    }
+
+    protected void computeTime() {
+    }
+    protected void computeFields() {
+    }
+    public void add(int field, int amount) {
+    }
+    public void roll(int field, boolean up) {
+    }
+    public int getMinimum(int field) {
+        return 0;
+    }
+    public int getMaximum(int field) {
+        return 0;
+    }
+    public int getGreatestMinimum(int field) {
+        return 0;
+    }
+    public int getLeastMaximum(int field) {
+        return 0;
+    }
+    
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestAll.java b/JodaTime/src/test/org/joda/time/convert/TestAll.java
index 50439037c..dc596bdab 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestAll.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestAll.java
@@ -72,7 +72,13 @@ public TestAll(String testName) {
 
     public static Test suite() {
         TestSuite suite = new TestSuite();
+        suite.addTest(TestCalendarConverter.suite());
+        suite.addTest(TestDateConverter.suite());
         suite.addTest(TestLongConverter.suite());
+        suite.addTest(TestNullConverter.suite());
+        suite.addTest(TestReadableInstantConverter.suite());
+        
+        suite.addTest(TestReadableDurationConverter.suite());
         return suite;
     }
 
diff --git a/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
new file mode 100644
index 000000000..5446f27ee
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
@@ -0,0 +1,220 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.BuddhistChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for CalendarConverter.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestCalendarConverter extends TestCase {
+
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone MOSCOW = DateTimeZone.getInstance("Europe/Moscow");
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO = ISOChronology.getInstance();
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestCalendarConverter.class);
+    }
+
+    public TestCalendarConverter(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = CalendarConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(Calendar.class, CalendarConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetInstantMillis_Object() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar();
+        cal.setTime(new Date(123L));
+        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal));
+    }
+
+    public void testGetInstantMillis_Object_Zone() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar();
+        cal.setTime(new Date(123L));
+        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, PARIS));
+        assertEquals(123L, cal.getTime().getTime());
+        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (DateTimeZone) null));
+        assertEquals(123L, cal.getTime().getTime());
+    }
+
+    public void testGetInstantMillis_Object_Chronology() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar();
+        cal.setTime(new Date(123L));
+        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));
+        assertEquals(123L, cal.getTime().getTime());
+        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (Chronology) null));
+        assertEquals(123L, cal.getTime().getTime());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetChronology_Object() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));
+        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(0L));
+        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(Long.MAX_VALUE));
+        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(Long.MIN_VALUE));
+        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));
+        
+        Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc));
+        
+        try {
+            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();
+            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));
+            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc));
+        } catch (ClassNotFoundException ex) {
+            // ignore
+        }
+    }
+
+    public void testGetChronology_Object_Zone() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));
+        assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(0L));
+        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(Long.MAX_VALUE));
+        assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));
+        
+        cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        cal.setGregorianChange(new Date(Long.MIN_VALUE));
+        assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));
+        
+        Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));
+        assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS));
+        
+        try {
+            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();
+            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));
+            assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS));
+        } catch (ClassNotFoundException ex) {
+            // ignore
+        }
+    }
+
+    public void testGetChronology_Object_Chronology() throws Exception {
+        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));
+        assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN));
+        assertEquals(ISO, CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[java.util.Calendar]", CalendarConverter.INSTANCE.toString());
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java b/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java
new file mode 100644
index 000000000..89757b35b
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java
@@ -0,0 +1,153 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Date;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for DateConverter.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateConverter extends TestCase {
+
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final Chronology ISO = ISOChronology.getInstance();
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateConverter.class);
+    }
+
+    public TestDateConverter(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = DateConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(Date.class, DateConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetInstantMillis_Object() throws Exception {
+        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L)));
+    }
+
+    public void testGetInstantMillis_Object_Zone() throws Exception {
+        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), PARIS));
+        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (DateTimeZone) null));
+    }
+
+    public void testGetInstantMillis_Object_Chronology() throws Exception {
+        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));
+        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetChronology_Object() throws Exception {
+        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L)));
+    }
+
+    public void testGetChronology_Object_Zone() throws Exception {
+        assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS));
+        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null));
+    }
+
+    public void testGetChronology_Object_Chronology() throws Exception {
+        assertEquals(JULIAN, DateConverter.INSTANCE.getChronology(new Date(123L), JULIAN));
+        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[java.util.Date]", DateConverter.INSTANCE.toString());
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
index 2c9cc8c86..8a4f2cca7 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
@@ -62,11 +62,12 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationType;
 import org.joda.time.chrono.ISOChronology;
 import org.joda.time.chrono.JulianChronology;
 
 /**
- * This class is a Junit unit test for TimeOfDay.
+ * This class is a Junit unit test for LongConverter.
  *
  * @author Stephen Colebourne
  */
@@ -145,7 +146,18 @@ public void testGetChronology_Object_Chronology() throws Exception {
     }
 
     //-----------------------------------------------------------------------
-    // TODO duration tests
+    public void testGetDurationMillis_Object() throws Exception {
+        assertEquals(123L, LongConverter.INSTANCE.getDurationMillis(new Long(123L)));
+    }
+
+    public void testGetDurationType_Object() throws Exception {
+        assertEquals(DurationType.getMillisType(), LongConverter.INSTANCE.getDurationType(new Long(123L)));
+    }
+
+    public void testIsPrecise_Object() throws Exception {
+        assertEquals(true, LongConverter.INSTANCE.isPrecise(new Long(123L)));
+    }
+
     //-----------------------------------------------------------------------
     public void testToString() {
         assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());
diff --git a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java
new file mode 100644
index 000000000..438065d0c
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java
@@ -0,0 +1,169 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeUtils;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for NullConverter.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestNullConverter extends TestCase {
+
+    private long TEST_TIME_NOW =
+            20 * DateTimeConstants.MILLIS_PER_DAY
+            + 10L * DateTimeConstants.MILLIS_PER_HOUR
+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE
+            + 30L * DateTimeConstants.MILLIS_PER_SECOND
+            + 40L;
+            
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final Chronology ISO = ISOChronology.getInstance();
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestNullConverter.class);
+    }
+
+    public TestNullConverter(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = NullConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(null, NullConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetInstantMillis_Object() throws Exception {
+        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null));
+    }
+
+    public void testGetInstantMillis_Object_Zone() throws Exception {
+        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, PARIS));
+        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (DateTimeZone) null));
+    }
+
+    public void testGetInstantMillis_Object_Chronology() throws Exception {
+        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN));
+        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetChronology_Object() throws Exception {
+        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null));
+    }
+
+    public void testGetChronology_Object_Zone() throws Exception {
+        assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS));
+        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null));
+    }
+
+    public void testGetChronology_Object_Chronology() throws Exception {
+        assertEquals(JULIAN, NullConverter.INSTANCE.getChronology(null, JULIAN));
+        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[null]", NullConverter.INSTANCE.toString());
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
new file mode 100644
index 000000000..984a3c933
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
@@ -0,0 +1,144 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.Duration;
+import org.joda.time.DurationType;
+import org.joda.time.ReadableDuration;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for ReadableDurationConverter.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestReadableDurationConverter extends TestCase {
+
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final Chronology ISO = ISOChronology.getInstance();
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestReadableDurationConverter.class);
+    }
+
+    public TestReadableDurationConverter(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = ReadableDurationConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(ReadableDuration.class, ReadableDurationConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetDurationMillis_Object() throws Exception {
+        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(DurationType.getMillisType(), 123L)));
+        try {
+            ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0));
+            fail();
+        } catch (Exception ex) {}
+    }
+
+    public void testGetDurationType_Object() throws Exception {
+        assertEquals(DurationType.getMillisType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(DurationType.getMillisType(), 123L)));
+        assertEquals(DurationType.getYearMonthType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0)));
+    }
+
+    public void testIsPrecise_Object() throws Exception {
+        assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(DurationType.getMillisType(), 123L)));
+        assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0)));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString());
+    }
+
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java
new file mode 100644
index 000000000..aec135d01
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java
@@ -0,0 +1,165 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.joda.time.Instant;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.chrono.JulianChronology;
+
+/**
+ * This class is a Junit unit test for ReadableInstantConverter.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestReadableInstantConverter extends TestCase {
+
+    private static final DateTimeZone UTC = DateTimeZone.UTC;
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final Chronology ISO = ISOChronology.getInstance();
+    private static final Chronology JULIAN = JulianChronology.getInstance();
+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
+    
+    private DateTimeZone zone = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestReadableInstantConverter.class);
+    }
+
+    public TestReadableInstantConverter(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSingleton() throws Exception {
+        Class cls = ReadableInstantConverter.class;
+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));
+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));
+        
+        Constructor con = cls.getDeclaredConstructor(null);
+        assertEquals(1, cls.getDeclaredConstructors().length);
+        assertEquals(true, Modifier.isProtected(con.getModifiers()));
+        
+        Field fld = cls.getDeclaredField("INSTANCE");
+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));
+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));
+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testSupportedType() throws Exception {
+        assertEquals(ReadableInstant.class, ReadableInstantConverter.INSTANCE.getSupportedType());
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetInstantMillis_Object() throws Exception {
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L)));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L)));
+    }
+
+    public void testGetInstantMillis_Object_Zone() throws Exception {
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), PARIS));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), PARIS));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (DateTimeZone) null));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (DateTimeZone) null));
+    }
+
+    public void testGetInstantMillis_Object_Chronology() throws Exception {
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null));
+        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testGetChronology_Object() throws Exception {
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L)));
+    }
+
+    public void testGetChronology_Object_Zone() throws Exception {
+        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));
+        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));
+    }
+
+    public void testGetChronology_Object_Chronology() throws Exception {
+        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN));
+        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN));
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));
+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testToString() {
+        assertEquals("Converter[org.joda.time.ReadableInstant]", ReadableInstantConverter.INSTANCE.toString());
+    }
+
+}

From 0748504f40e397c69d857db3b9ecbeee4c705fc7 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 6 Jul 2004 23:12:38 +0000
Subject: [PATCH 0106/1934] Javadoc API clarifications

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@256 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/convert/LongConverter.java | 11 ++++++++---
 .../time/convert/ReadableDurationConverter.java   | 15 +++++++++++----
 2 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index 6efd294f9..66783774c 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -84,6 +84,8 @@ protected LongConverter() {
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond instant
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object is an invalid type
      */
     public long getInstantMillis(Object object) {
         return ((Long) object).longValue();
@@ -102,6 +104,8 @@ public boolean isPrecise(Object object) {
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond duration
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object is an invalid type
      */
     public long getDurationMillis(Object object) {
         return ((Long) object).longValue();
@@ -114,6 +118,8 @@ public long getDurationMillis(Object object) {
      * @param duration duration to get modified
      * @param object  the object to convert, must not be null
      * @return the millisecond duration
+     * @throws NullPointerException if the duration or object is null
+     * @throws ClassCastException if the object is an invalid type
      * @throws IllegalArgumentException if the object is invalid
      */
     public void setInto(ReadWritableDuration duration, Object object) {
@@ -121,11 +127,10 @@ public void setInto(ReadWritableDuration duration, Object object) {
     }
 
     /**
-     * Selects a suitable duration type for the given object.
+     * Returns the millis duration type.
      *
      * @param object  the object to examine, must not be null
-     * @return the duration type, never null
-     * @throws ClassCastException if the object is invalid
+     * @return the millis duration type
      */
     public DurationType getDurationType(Object object) {
         return DurationType.getMillisType();
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
index 28f8a752c..1a7332402 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
@@ -83,7 +83,8 @@ protected ReadableDurationConverter() {
      * Returns true if the given support object represents a precice
      * duration. If so, getDurationMillis can be called.
      *
-     * @throws ClassCastException if the object is invalid
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object is an invalid type
      */
     public boolean isPrecise(Object object) {
         return ((ReadableDuration) object).isPrecise();
@@ -94,6 +95,9 @@ public boolean isPrecise(Object object) {
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond value
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object is an invalid type
+     * @throws IllegalArgumentException if the object is invalid
      */
     public long getDurationMillis(Object object) {
         return ((ReadableDuration) object).getTotalMillis();
@@ -106,7 +110,9 @@ public long getDurationMillis(Object object) {
      * @param duration duration to get modified
      * @param object  the object to convert, must not be null
      * @return the millisecond duration
-     * @throws ClassCastException if the object is invalid
+     * @throws NullPointerException if the duration or object is null
+     * @throws ClassCastException if the object is an invalid type
+     * @throws IllegalArgumentException if the object is invalid
      */
     public void setInto(ReadWritableDuration duration, Object object) {
         duration.setDuration((ReadableDuration) object);
@@ -116,8 +122,9 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * Selects a suitable duration type for the given object.
      *
      * @param object  the object to examine, must not be null
-     * @return the duration type, never null
-     * @throws ClassCastException if the object is invalid
+     * @return the duration type from the readable duration
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object is an invalid type
      */
     public DurationType getDurationType(Object object) {
         return ((ReadableDuration) object).getDurationType();

From 35495b79950fee47d479bb8625e4d4cf967a61af Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 6 Jul 2004 23:13:32 +0000
Subject: [PATCH 0107/1934] Increase converter test coverage

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@257 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/MockBadChronology.java  | 85 +++++++++++++++++
 .../time/convert/MockUnknownCalendar.java     |  2 +-
 .../time/convert/MockUnknownTimeZone.java     | 93 +++++++++++++++++++
 .../time/convert/TestCalendarConverter.java   |  3 +
 .../joda/time/convert/TestLongConverter.java  |  7 ++
 .../TestReadableDurationConverter.java        | 14 +++
 .../convert/TestReadableInstantConverter.java |  2 +
 7 files changed, 205 insertions(+), 1 deletion(-)
 create mode 100644 JodaTime/src/test/org/joda/time/convert/MockBadChronology.java
 create mode 100644 JodaTime/src/test/org/joda/time/convert/MockUnknownTimeZone.java

diff --git a/JodaTime/src/test/org/joda/time/convert/MockBadChronology.java b/JodaTime/src/test/org/joda/time/convert/MockBadChronology.java
new file mode 100644
index 000000000..4ebeb7ee2
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/MockBadChronology.java
@@ -0,0 +1,85 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.AbstractChronology;
+
+/**
+ * A basic mock testing class for an unknown calendar.
+ *
+ * @author Stephen Colebourne
+ */
+class MockBadChronology extends AbstractChronology {
+    
+    MockBadChronology() {
+        super();
+    }
+
+    public Chronology withZone(DateTimeZone zone) {
+        return null;
+    }
+    
+    public DateTimeZone getZone() {
+        return null;
+    }
+    public Chronology withUTC() {
+        return null;
+    }
+    public String toString() {
+        return null;
+    }
+    
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java b/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
index a98f83cc1..72bc0253e 100644
--- a/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
+++ b/JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
@@ -61,7 +61,7 @@
  *
  * @author Stephen Colebourne
  */
-public class MockUnknownCalendar extends Calendar {
+class MockUnknownCalendar extends Calendar {
     
     private long millis;
     private TimeZone zone;
diff --git a/JodaTime/src/test/org/joda/time/convert/MockUnknownTimeZone.java b/JodaTime/src/test/org/joda/time/convert/MockUnknownTimeZone.java
new file mode 100644
index 000000000..614f83acf
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/convert/MockUnknownTimeZone.java
@@ -0,0 +1,93 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * A basic mock testing class for an unknown time zone.
+ *
+ * @author Stephen Colebourne
+ */
+class MockUnknownTimeZone extends TimeZone {
+    
+    MockUnknownTimeZone() {
+        super();
+    }
+    
+    public String getID() {
+        return "!!!";
+    }
+    public String getDisplayName(boolean daylight, int style, Locale locale) {
+        return "!!!";
+    }
+
+    public int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds) {
+        return 0;
+    }
+    public void setRawOffset(int offsetMillis) {
+    }
+    public int getRawOffset() {
+        return 0;
+    }
+    public boolean useDaylightTime() {
+        return false;
+    }
+    public boolean inDaylightTime(Date date) {
+        return false;
+    }
+    
+}
diff --git a/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
index 5446f27ee..f8ed72bbf 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java
@@ -163,6 +163,9 @@ public void testGetChronology_Object() throws Exception {
         cal.setGregorianChange(new Date(Long.MIN_VALUE));
         assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));
         
+        cal = new GregorianCalendar(new MockUnknownTimeZone());
+        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal));
+        
         Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));
         assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc));
         
diff --git a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
index 8a4f2cca7..87d216311 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java
@@ -63,6 +63,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationType;
+import org.joda.time.MutableDuration;
 import org.joda.time.chrono.ISOChronology;
 import org.joda.time.chrono.JulianChronology;
 
@@ -158,6 +159,12 @@ public void testIsPrecise_Object() throws Exception {
         assertEquals(true, LongConverter.INSTANCE.isPrecise(new Long(123L)));
     }
 
+    public void testSetInto_Object() throws Exception {
+        MutableDuration m = new MutableDuration(DurationType.getMillisType());
+        LongConverter.INSTANCE.setInto(m, new Long(123L));
+        assertEquals(123L, m.getTotalMillis());
+    }
+
     //-----------------------------------------------------------------------
     public void testToString() {
         assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());
diff --git a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
index 984a3c933..f12977095 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
@@ -64,6 +64,7 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.Duration;
 import org.joda.time.DurationType;
+import org.joda.time.MutableDuration;
 import org.joda.time.ReadableDuration;
 import org.joda.time.chrono.ISOChronology;
 import org.joda.time.chrono.JulianChronology;
@@ -136,6 +137,19 @@ public void testIsPrecise_Object() throws Exception {
         assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0)));
     }
 
+    public void testSetInto_Object() throws Exception {
+        MutableDuration m = new MutableDuration(DurationType.getYearMonthType());
+        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(DurationType.getYearMonthType(), 1, 2, 0, 3, 0, 0, 0, 0));
+        assertEquals(1, m.getYears());
+        assertEquals(2, m.getMonths());
+        assertEquals(0, m.getWeeks());
+        assertEquals(3, m.getDays());
+        assertEquals(0, m.getHours());
+        assertEquals(0, m.getMinutes());
+        assertEquals(0, m.getSeconds());
+        assertEquals(0, m.getMillis());
+    }
+
     //-----------------------------------------------------------------------
     public void testToString() {
         assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString());
diff --git a/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java
index aec135d01..44fed71e8 100644
--- a/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java
+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java
@@ -148,6 +148,8 @@ public void testGetChronology_Object_Zone() throws Exception {
         assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));
         assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));
         assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));
+        
+        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS));
     }
 
     public void testGetChronology_Object_Chronology() throws Exception {

From ad21e73f2f9b3e4249aab38a27a19a938b7bae4c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:26:53 +0000
Subject: [PATCH 0108/1934] Fix tests now that null means now in comparator

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@258 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/TestDateTimeComparator.java | 91 +++++++------------
 1 file changed, 33 insertions(+), 58 deletions(-)

diff --git a/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
index 42eaed214..053aad841 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java
@@ -794,82 +794,57 @@ public void testListTime() {
      * Test comparator operation with null object(s).
      */
     public void testNullDT() {
-        try
-        {
-            aDateTime = getADate( "2000-01-01T00:00:00" );
-            assertEquals("NULLDT Expected Fail", 0,     // should not matter
-                    cYear.compare( null, aDateTime ) );
-        }
-        catch(IllegalArgumentException iae)
-        {
-            return;
-        }
-        fail("null object failed");
-    } // end of testNullDT
+        // null means now
+        aDateTime = getADate("2000-01-01T00:00:00");
+        assertTrue(cYear.compare(null, aDateTime) > 0);
+        assertTrue(cYear.compare(aDateTime, null) < 0);
+    }
 
     /**
      * Test comparator operation with an invalid object type.
      */
     public void testInvalidObj() {
-        try
-        {
-            aDateTime = getADate( "2000-01-01T00:00:00" );
-            assertEquals("INVLO Expected Fail", 0,  // should not matter
-                    cYear.compare( "FreeBird" , aDateTime ) );
-        }
-        catch(ClassCastException cce)
-        {
-            return;
-        }
-        catch(IllegalArgumentException iae)
-        {
-            return;
-        }
-        fail("Invalid object failed");
-    } // end of testInvalidObj
-
+        aDateTime = getADate("2000-01-01T00:00:00");
+        try {
+            cYear.compare("FreeBird", aDateTime);
+            fail("Invalid object failed");
+        } catch (IllegalArgumentException cce) {}
+    }
 
-    /*
-     * -----------------------------------------
-     * private convenience methods
-     * -----------------------------------------
-     */
-    /*
-     * getADate
+    // private convenience methods
+    //-----------------------------------------------------------------------
+    /**
+     * Creates a date to test with.
      */
     private DateTime getADate(String s) {
         DateTime retDT = null;
-        try
-        {
-            retDT = new DateTime( s, DateTimeZone.UTC );
-        }
-        catch(IllegalArgumentException pe)
-        {
+        try {
+            retDT = new DateTime(s, DateTimeZone.UTC);
+        } catch (IllegalArgumentException pe) {
             pe.printStackTrace();
         }
         return retDT;
-    } // end of getADate
-    /*
-     * loadAList
+    }
+
+    /**
+     * Load a string array.
      */
     private List loadAList(String[] someStrs) {
         List newList = new ArrayList();
-        try
-        {
+        try {
             for (int i = 0; i < someStrs.length; ++i) {
-                newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );
+                newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));
             } // end of the for
-        }
-        catch(IllegalArgumentException pe)
-        {
+        } catch (IllegalArgumentException pe) {
             pe.printStackTrace();
         }
         return newList;
-    } // end of loadAList
-    /*
-     * isListSorted
+    }
+
+    /**
+     * Check if the list is sorted.
      */
-    private boolean isListSorted( List tl ) {
+    private boolean isListSorted(List tl) {
         // tl must be populated with DateTime objects.
         DateTime lhDT = (DateTime)tl.get(0);
         DateTime rhDT = null;
@@ -882,8 +857,8 @@ private boolean isListSorted( List tl ) {
             //
             lhVal = rhVal;  // swap for next iteration
             lhDT = rhDT;    // swap for next iteration
-        } // end of the for
+        }
         return true;
-    } // end of isListSorted
+    }
 
-} // end of class TestDateTimeComparator
+}

From 360b3ed729f6ed8435c275b602931a86c77d8ad3 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:28:46 +0000
Subject: [PATCH 0109/1934] Update javadoc and implementation, including
 defining null input as now

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@259 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/DateTimeComparator.java     | 54 ++++++++++---------
 1 file changed, 30 insertions(+), 24 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeComparator.java b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
index 6a0c19195..9885ebc6d 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
@@ -71,6 +71,7 @@
  * <li>Calendar
  * <li>Date
  * <li>Long (milliseconds)
+ * <li>null (now)
  * </ul>
  *
  * <p>
@@ -97,6 +98,8 @@
     //-----------------------------------------------------------------------
     /**
      * Returns a DateTimeComparator the compares the entire date time value.
+     * 
+     * @return a comparator over all fields
      */
     public static DateTimeComparator getInstance() {
         return INSTANCE;
@@ -106,7 +109,8 @@ public static DateTimeComparator getInstance() {
      * Returns a DateTimeComparator with a lower limit only. Fields of a
      * magnitude less than the lower limit are excluded from comparisons.
      *
-     * @param lowerLimit inclusive lower limit for fields to be compared
+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit
+     * @return a comparator over all fields above the lower limit
      */
     public static DateTimeComparator getInstance(DateTimeField lowerLimit) {
         return getInstance(lowerLimit, null);
@@ -119,8 +123,9 @@ public static DateTimeComparator getInstance(DateTimeField lowerLimit) {
      * excluded from comparisons. Either limit may be specified as null, which
      * indicates an unbounded limit.
      *
-     * @param lowerLimit optional, inclusive lower limit for fields to be compared
-     * @param upperLimit optional, exclusive upper limit for fields to be compared
+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit
+     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit
+     * @return a comparator over all fields between the limits
      */
     public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {
         if (lowerLimit == null && upperLimit == null) {
@@ -130,23 +135,32 @@ public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeF
     }
 
     /**
-     * Returns a comparator that only considers date fields. Time of day is
-     * ignored.
+     * Returns a comparator that only considers date fields.
+     * Time of day is ignored.
+     * 
+     * @param chrono  the chronology to use
+     * @return a comparator over all date fields
      */
     public static DateTimeComparator getDateOnlyInstance(Chronology chrono) {
         return getInstance(chrono.dayOfYear(), null);
     }
 
     /**
-     * Returns a comparator that only considers time fields. Date is ignored.
+     * Returns a comparator that only considers time fields.
+     * Date is ignored.
+     * 
+     * @param chrono  the chronology to use
+     * @return a comparator over all time fields
      */
     public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {
         return getInstance(null, chrono.dayOfYear());
     }
 
-    //-----------------------------------------------------------------------
     /**
      * Restricted constructor.
+     * 
+     * @param lowerLimit  the lower field limit, null means no limit
+     * @param upperLimit  the upper field limit, null means no limit
      */
     private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
         super();
@@ -154,6 +168,7 @@ private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
         iUpperLimit = upperLimit;
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Gets the field that represents the lower limit of comparison.
      * 
@@ -176,26 +191,17 @@ public DateTimeField getUpperLimit() {
      * Compare two objects against only the range of date time fields as
      * specified in the constructor.
      * 
-     * @param lhsObj The first object, logically on the left of a &lt; comparison
-     * @param rhsObj The second object, logically on the right of a &lt; comparison
-     * @return zero if order does not matter, negative value if lhsObj &lt;
-     *  rhsObj, positive value otherwise.
+     * @param lhsObj  the first object,
+     *      logically on the left of a &lt; comparison, null means now
+     * @param rhsObj  the second object,
+     *      logically on the right of a &lt; comparison, null means now
+     * @return zero if order does not matter,
+     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.
      * @throws IllegalArgumentException if either argument is not supported
      */
     public int compare(Object lhsObj, Object rhsObj) {
-        long lhsMillis, rhsMillis;
-
-        if (lhsObj instanceof ReadableInstant) {
-            lhsMillis = ((ReadableInstant) lhsObj).getMillis();
-        } else {
-            lhsMillis = getMillisFromObject(lhsObj);
-        }
-
-        if (rhsObj instanceof ReadableInstant) {
-            rhsMillis = ((ReadableInstant) rhsObj).getMillis();
-        } else {
-            rhsMillis = getMillisFromObject(rhsObj);
-        }
+        long lhsMillis = getMillisFromObject(lhsObj);
+        long rhsMillis = getMillisFromObject(rhsObj);
 
         DateTimeField field;
         if ((field = iLowerLimit) != null) {

From 07955d2735c33f19ec9ee0bdc7f38afd085476da Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:33:06 +0000
Subject: [PATCH 0110/1934] Use correct UnsupportedDurationType

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@260 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DurationType.java  | 32 +++++++++----------
 .../time/chrono/BuddhistEraDateTimeField.java |  2 +-
 .../time/chrono/CopticEraDateTimeField.java   |  2 +-
 .../joda/time/chrono/GJEraDateTimeField.java  |  2 +-
 4 files changed, 19 insertions(+), 19 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 485977150..1626064c2 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -337,7 +337,7 @@ protected DurationType() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField years() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("years");
     }
 
     /**
@@ -346,7 +346,7 @@ public DurationField years() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField months() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("months");
     }
 
     /**
@@ -355,7 +355,7 @@ public DurationField months() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField weeks() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("weeks");
     }
 
     /**
@@ -364,7 +364,7 @@ public DurationField weeks() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField days() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("days");
     }
 
     /**
@@ -373,7 +373,7 @@ public DurationField days() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField hours() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("hours");
     }
 
     /**
@@ -382,7 +382,7 @@ public DurationField hours() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField minutes() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("minutes");
     }
 
     /**
@@ -391,7 +391,7 @@ public DurationField minutes() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField seconds() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("seconds");
     }
 
     /**
@@ -400,7 +400,7 @@ public DurationField seconds() {
      * @return DurationField or UnsupportedDurationField if unsupported
      */
     public DurationField millis() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("millis");
     }
 
     /**
@@ -829,56 +829,56 @@ public boolean isPrecise() {
 
         public DurationField years() {
             if ((iMask & (1 << 0)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("years");
             }
             return iType.years();
         }
 
         public DurationField months() {
             if ((iMask & (1 << 1)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("months");
             }
             return iType.months();
         }
 
         public DurationField weeks() {
             if ((iMask & (1 << 2)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("weeks");
             }
             return iType.weeks();
         }
 
         public DurationField days() {
             if ((iMask & (1 << 3)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("days");
             }
             return iType.days();
         }
 
         public DurationField hours() {
             if ((iMask & (1 << 4)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("hours");
             }
             return iType.hours();
         }
 
         public DurationField minutes() {
             if ((iMask & (1 << 5)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("minutes");
             }
             return iType.minutes();
         }
 
         public DurationField seconds() {
             if ((iMask & (1 << 6)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("seconds");
             }
             return iType.seconds();
         }
 
         public DurationField millis() {
             if ((iMask & (1 << 7)) != 0) {
-                return UnsupportedDurationField.INSTANCE;
+                return UnsupportedDurationField.getInstance("millis");
             }
             return iType.millis();
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
index 7c7019d51..9473308c4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
@@ -151,7 +151,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
index 26a2a8403..a890e8ede 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
@@ -150,7 +150,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
index 81356ebb4..d1fa3058c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
@@ -161,7 +161,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {

From ab921d9379840cd3c740895a02b26d4e0e0e9422 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:35:10 +0000
Subject: [PATCH 0111/1934] Change DurationField from interface to Class

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@261 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DurationField.java | 38 +++++++++----------
 .../time/field/AbstractDurationField.java     |  7 ++--
 .../time/field/DelegatedDurationField.java    |  5 ++-
 .../joda/time/field/MillisDurationField.java  |  4 +-
 .../time/field/UnsupportedDurationField.java  | 27 ++++++++++++-
 5 files changed, 53 insertions(+), 28 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DurationField.java b/JodaTime/src/java/org/joda/time/DurationField.java
index 6fa859907..2431330a0 100644
--- a/JodaTime/src/java/org/joda/time/DurationField.java
+++ b/JodaTime/src/java/org/joda/time/DurationField.java
@@ -65,7 +65,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public interface DurationField extends Comparable {
+public abstract class DurationField implements Comparable {
 
     /**
      * Get the name of the field, intended for debugging purposes only. By
@@ -73,14 +73,14 @@
      * 
      * @return field name
      */
-    String getName();
+    public abstract String getName();
 
     /**
      * Returns true if this field is supported.
      * 
      * @return true if this field is supported
      */
-    boolean isSupported();
+    public abstract boolean isSupported();
 
     /**
      * Is this field precise. A precise field can calculate its value from
@@ -90,7 +90,7 @@
      * @return true if precise
      * @see #getUnitMillis()
      */
-    boolean isPrecise();
+    public abstract boolean isPrecise();
     
     /**
      * Returns the amount of milliseconds per unit value of this field. For
@@ -103,7 +103,7 @@
      * @return the unit size of this field, in milliseconds
      * @see #isPrecise()
      */
-    long getUnitMillis();
+    public abstract long getUnitMillis();
 
     //------------------------------------------------------------------------
     /**
@@ -115,7 +115,7 @@
      * negative
      * @throws ArithmeticException if the value is too large for an int
      */
-    int getValue(long duration);
+    public abstract int getValue(long duration);
 
     /**
      * Get the value of this field from the milliseconds, which is approximate
@@ -125,7 +125,7 @@
      * @return the value of the field, in the units of the field, which may be
      * negative
      */
-    long getValueAsLong(long duration);
+    public abstract long getValueAsLong(long duration);
 
     /**
      * Get the value of this field from the milliseconds relative to an
@@ -141,7 +141,7 @@
      * negative
      * @throws ArithmeticException if the value is too large for an int
      */
-    int getValue(long duration, long instant);
+    public abstract int getValue(long duration, long instant);
 
     /**
      * Get the value of this field from the milliseconds relative to an
@@ -156,7 +156,7 @@
      * @return the value of the field, in the units of the field, which may be
      * negative
      */
-    long getValueAsLong(long duration, long instant);
+    public abstract long getValueAsLong(long duration, long instant);
 
     //------------------------------------------------------------------------
     /**
@@ -167,7 +167,7 @@
      * @return the milliseconds that the field represents, which may be
      * negative
      */
-    long getMillis(int value);
+    public abstract long getMillis(int value);
 
     /**
      * Get the millisecond duration of this field from its value, which is
@@ -177,7 +177,7 @@
      * @return the milliseconds that the field represents, which may be
      * negative
      */
-    long getMillis(long value);
+    public abstract long getMillis(long value);
 
     /**
      * Get the millisecond duration of this field from its value relative to an
@@ -192,7 +192,7 @@
      * @return the millisecond duration that the field represents, which may be
      * negative
      */
-    long getMillis(int value, long instant);
+    public abstract long getMillis(int value, long instant);
 
     /**
      * Get the millisecond duration of this field from its value relative to an
@@ -207,7 +207,7 @@
      * @return the millisecond duration that the field represents, which may be
      * negative
      */
-    long getMillis(long value, long instant);
+    public abstract long getMillis(long value, long instant);
 
     /**
      * Adds a duration value (which may be negative) to the instant.
@@ -216,7 +216,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    long add(long instant, int value);
+    public abstract long add(long instant, int value);
 
     /**
      * Adds a duration value (which may be negative) to the instant.
@@ -225,7 +225,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    long add(long instant, long value);
+    public abstract long add(long instant, long value);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -246,7 +246,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    int getDifference(long minuendInstant, long subtrahendInstant);
+    public abstract int getDifference(long minuendInstant, long subtrahendInstant);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -267,7 +267,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
+    public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
 
     /**
      * Compares this duration field with another duration field for ascending
@@ -279,7 +279,7 @@
      * @throws NullPointerException if the object is null
      * @throws ClassCastException if the object type is not supported
      */
-    int compareTo(Object durationField);
+    public abstract int compareTo(Object durationField);
 
     /**
      * Returns a localized unit name of this field, using the given value as an
@@ -313,6 +313,6 @@
      * 
      * @return debug string
      */
-    String toString();
+    public abstract String toString();
     
 }
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
index 06e82bdee..e566e6b30 100644
--- a/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
@@ -70,11 +70,12 @@
  * @author Brian S O'Neill
  * @see DecoratedDurationField
  */
-public abstract class AbstractDurationField implements DurationField, Serializable {
+public abstract class AbstractDurationField extends DurationField implements Serializable {
 
-    static final long serialVersionUID = -2554245107589433218L;
+    /** Serialization lock. */
+    private static final long serialVersionUID = -2554245107589433218L;
 
-    /** A desriptive name for the field */
+    /** A desriptive name for the field. */
     private final String iName;
 
     protected AbstractDurationField(String name) {
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
index 21d9c6d08..4521a5c60 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
@@ -66,9 +66,10 @@
  * @author Brian S O'Neill
  * @see DecoratedDurationField
  */
-public class DelegatedDurationField implements DurationField, Serializable {
+public class DelegatedDurationField extends DurationField implements Serializable {
 
-    static final long serialVersionUID = -5576443481242007829L;
+    /** Serialization lock. */
+    private static final long serialVersionUID = -5576443481242007829L;
 
     /** The DurationField being wrapped */
     private final DurationField iField;
diff --git a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
index 617d9bf5c..5bb148764 100644
--- a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
@@ -64,9 +64,9 @@
  *
  * @author Brian S O'Neill
  */
-public final class MillisDurationField implements DurationField, Serializable {
+public final class MillisDurationField extends DurationField implements Serializable {
 
-    /** Serialization version. */
+    /** Serialization lock. */
     private static final long serialVersionUID = 2656707858124633367L;
 
     /** Singleton instance. */
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
index 88f66b7d9..98c846011 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
@@ -64,9 +64,10 @@
  *
  * @author Brian S O'Neill
  */
-public final class UnsupportedDurationField implements DurationField, Serializable {
+public final class UnsupportedDurationField extends DurationField implements Serializable {
 
-    static final long serialVersionUID = -6390301302770925357L;
+    /** Serialization lock. */
+    private static final long serialVersionUID = -6390301302770925357L;
 
     /**
      * Instance with the name "unsupported".
@@ -248,6 +249,28 @@ public int compareTo(Object durationField) {
     }
 
     //------------------------------------------------------------------------
+    /**
+     * Compares this duration field to another.
+     * 
+     * @param obj  the object to compare to
+     * @return true if equal
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof UnsupportedDurationField) {
+            return (((UnsupportedDurationField) obj).getName().equals(getName()));
+        }
+        return false;
+    }
+
+    /**
+     * Gets a suitable hashcode.
+     * 
+     * @return the hashcode
+     */
+    public int hashCode() {
+        return getName().hashCode();
+    }
+
     /**
      * Get a suitable debug string.
      * 

From c6886146e9f2290652d71c8d846a1ebe8c4053e0 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:35:25 +0000
Subject: [PATCH 0112/1934] More tests

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@262 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/TestDateTime_Properties.java    | 665 ++++++++++--------
 1 file changed, 374 insertions(+), 291 deletions(-)

diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
index dffab6507..6a30aad61 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -114,6 +114,84 @@ protected void tearDown() throws Exception {
         zone = null;
     }
 
+    //-----------------------------------------------------------------------
+    public void testPropertyGetEra() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().era(), test.era().getField());
+        assertEquals("era", test.era().getName());
+        assertEquals("Property[era]", test.era().toString());
+        assertSame(test, test.era().getInstant());
+        assertSame(test, test.era().getDateTime());
+        assertEquals(1, test.era().get());
+        assertEquals("AD", test.era().getAsText());
+        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));
+        assertEquals("AD", test.era().getAsShortText());
+        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().eras(), test.era().getDurationField());
+        assertEquals(null, test.era().getRangeDurationField());
+        assertEquals(2, test.era().getMaximumTextLength(null));
+        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));
+        assertEquals(2, test.era().getMaximumShortTextLength(null));
+        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetYearOfEra() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());
+        assertEquals("yearOfEra", test.yearOfEra().getName());
+        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());
+        assertSame(test, test.yearOfEra().getInstant());
+        assertSame(test, test.yearOfEra().getDateTime());
+        assertEquals(1972, test.yearOfEra().get());
+        assertEquals("1972", test.yearOfEra().getAsText());
+        assertEquals("1972", test.yearOfEra().getAsText(Locale.FRENCH));
+        assertEquals("1972", test.yearOfEra().getAsShortText());
+        assertEquals("1972", test.yearOfEra().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
+        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
+        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetCenturyOfEra() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());
+        assertEquals("centuryOfEra", test.centuryOfEra().getName());
+        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());
+        assertSame(test, test.centuryOfEra().getInstant());
+        assertSame(test, test.centuryOfEra().getDateTime());
+        assertEquals(19, test.centuryOfEra().get());
+        assertEquals("19", test.centuryOfEra().getAsText());
+        assertEquals("19", test.centuryOfEra().getAsText(Locale.FRENCH));
+        assertEquals("19", test.centuryOfEra().getAsShortText());
+        assertEquals("19", test.centuryOfEra().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
+        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
+        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetYearOfCentury() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());
+        assertEquals("yearOfCentury", test.yearOfCentury().getName());
+        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());
+        assertSame(test, test.yearOfCentury().getInstant());
+        assertSame(test, test.yearOfCentury().getDateTime());
+        assertEquals(72, test.yearOfCentury().get());
+        assertEquals("72", test.yearOfCentury().getAsText());
+        assertEquals("72", test.yearOfCentury().getAsText(Locale.FRENCH));
+        assertEquals("72", test.yearOfCentury().getAsShortText());
+        assertEquals("72", test.yearOfCentury().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());
+        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());
+        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));
+        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));
+    }
+
     //-----------------------------------------------------------------------
     public void testPropertyGetYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
@@ -212,295 +290,300 @@ public void testPropertyCompareToYear() {
         } catch (IllegalArgumentException ex) {}
     }
 
-//    //-----------------------------------------------------------------------
-//    public void testPropertyGetMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
-//        assertEquals("monthOfYear", test.monthOfYear().getName());
-//        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
-//        assertSame(test, test.monthOfYear().getReadablePartial());
-//        assertSame(test, test.monthOfYear().getDateTime());
-//        assertEquals(6, test.monthOfYear().get());
-//        assertEquals("June", test.monthOfYear().getAsText());
-//        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));
-//        assertEquals("Jun", test.monthOfYear().getAsShortText());
-//        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));
-//        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());
-//        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
-//        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
-//        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
-//        test = new DateTime(1972, 7, 9);
-//        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
-//        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));
-//    }
-//
-//    public void testPropertyGetMaxMinValuesMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        assertEquals(1, test.monthOfYear().getMinimumValue());
-//        assertEquals(1, test.monthOfYear().getMinimumValueOverall());
-//        assertEquals(12, test.monthOfYear().getMaximumValue());
-//        assertEquals(12, test.monthOfYear().getMaximumValueOverall());
-//    }
-//
-//    public void testPropertyAddMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.monthOfYear().addCopy(6);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 12, 9);
-//        
-//        copy = test.monthOfYear().addCopy(7);
-//        check(copy, 1973, 1, 9);
-//        
-//        copy = test.monthOfYear().addCopy(-5);
-//        check(copy, 1972, 1, 9);
-//        
-//        copy = test.monthOfYear().addCopy(-6);
-//        check(copy, 1971, 12, 9);
-//        
-//        test = new DateTime(1972, 1, 31);
-//        copy = test.monthOfYear().addCopy(1);
-//        check(copy, 1972, 2, 29);
-//        
-//        copy = test.monthOfYear().addCopy(2);
-//        check(copy, 1972, 3, 31);
-//        
-//        copy = test.monthOfYear().addCopy(3);
-//        check(copy, 1972, 4, 30);
-//        
-//        test = new DateTime(1971, 1, 31);
-//        copy = test.monthOfYear().addCopy(1);
-//        check(copy, 1971, 2, 28);
-//    }
-//
-//    public void testPropertyAddInFieldMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.monthOfYear().addWrappedToCopy(4);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 10, 9);
-//        
-//        copy = test.monthOfYear().addWrappedToCopy(8);
-//        check(copy, 1972, 2, 9);
-//        
-//        copy = test.monthOfYear().addWrappedToCopy(-8);
-//        check(copy, 1972, 10, 9);
-//        
-//        test = new DateTime(1972, 1, 31);
-//        copy = test.monthOfYear().addWrappedToCopy(1);
-//        check(copy, 1972, 2, 29);
-//        
-//        copy = test.monthOfYear().addWrappedToCopy(2);
-//        check(copy, 1972, 3, 31);
-//        
-//        copy = test.monthOfYear().addWrappedToCopy(3);
-//        check(copy, 1972, 4, 30);
-//        
-//        test = new DateTime(1971, 1, 31);
-//        copy = test.monthOfYear().addWrappedToCopy(1);
-//        check(copy, 1971, 2, 28);
-//    }
-//
-//    public void testPropertySetMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.monthOfYear().setCopy(12);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 12, 9);
-//        
-//        test = new DateTime(1972, 1, 31);
-//        copy = test.monthOfYear().setCopy(2);
-//        check(copy, 1972, 2, 29);
-//        
-//        try {
-//            test.monthOfYear().setCopy(13);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//        try {
-//            test.monthOfYear().setCopy(0);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//    }
-//
-//    public void testPropertySetTextMonth() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.monthOfYear().setCopy("12");
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 12, 9);
-//        
-//        copy = test.monthOfYear().setCopy("December");
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 12, 9);
-//        
-//        copy = test.monthOfYear().setCopy("Dec");
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 12, 9);
-//    }
-//
-//    public void testPropertyCompareToMonth() {
-//        DateTime test1 = new DateTime(TEST_TIME1);
-//        DateTime test2 = new DateTime(TEST_TIME2);
-//        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);
-//        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);
-//        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);
-//        try {
-//            test1.monthOfYear().compareTo((ReadablePartial) null);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//        
-//        DateTime dt1 = new DateTime(TEST_TIME1);
-//        DateTime dt2 = new DateTime(TEST_TIME2);
-//        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);
-//        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);
-//        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);
-//        try {
-//            test1.monthOfYear().compareTo((ReadableInstant) null);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//    }
-//
-//    //-----------------------------------------------------------------------
-//    public void testPropertyGetDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
-//        assertEquals("dayOfMonth", test.dayOfMonth().getName());
-//        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
-//        assertSame(test, test.dayOfMonth().getReadablePartial());
-//        assertSame(test, test.dayOfMonth().getDateTime());
-//        assertEquals(9, test.dayOfMonth().get());
-//        assertEquals("9", test.dayOfMonth().getAsText());
-//        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));
-//        assertEquals("9", test.dayOfMonth().getAsShortText());
-//        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));
-//        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());
-//        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());
-//        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));
-//        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));
-//    }
-//
-//    public void testPropertyGetMaxMinValuesDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        assertEquals(1, test.dayOfMonth().getMinimumValue());
-//        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
-//        assertEquals(30, test.dayOfMonth().getMaximumValue());
-//        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
-//        test = new DateTime(1972, 7, 9);
-//        assertEquals(31, test.dayOfMonth().getMaximumValue());
-//        test = new DateTime(1972, 2, 9);
-//        assertEquals(29, test.dayOfMonth().getMaximumValue());
-//        test = new DateTime(1971, 2, 9);
-//        assertEquals(28, test.dayOfMonth().getMaximumValue());
-//    }
-//
-//    public void testPropertyAddDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.dayOfMonth().addCopy(9);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 6, 18);
-//        
-//        copy = test.dayOfMonth().addCopy(21);
-//        check(copy, 1972, 6, 30);
-//        
-//        copy = test.dayOfMonth().addCopy(22);
-//        check(copy, 1972, 7, 1);
-//        
-//        copy = test.dayOfMonth().addCopy(22 + 30);
-//        check(copy, 1972, 7, 31);
-//        
-//        copy = test.dayOfMonth().addCopy(22 + 31);
-//        check(copy, 1972, 8, 1);
-//
-//        copy = test.dayOfMonth().addCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
-//        check(copy, 1972, 12, 31);
-//        
-//        copy = test.dayOfMonth().addCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
-//        check(copy, 1973, 1, 1);
-//        
-//        copy = test.dayOfMonth().addCopy(-8);
-//        check(copy, 1972, 6, 1);
-//        
-//        copy = test.dayOfMonth().addCopy(-9);
-//        check(copy, 1972, 5, 31);
-//        
-//        copy = test.dayOfMonth().addCopy(-8 - 31 - 30 - 31 - 29 - 31);
-//        check(copy, 1972, 1, 1);
-//        
-//        copy = test.dayOfMonth().addCopy(-9 - 31 - 30 - 31 - 29 - 31);
-//        check(copy, 1971, 12, 31);
-//    }
-//
-//    public void testPropertyAddInFieldDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.dayOfMonth().addWrappedToCopy(21);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 6, 30);
-//        
-//        copy = test.dayOfMonth().addWrappedToCopy(22);
-//        check(copy, 1972, 6, 1);
-//        
-//        copy = test.dayOfMonth().addWrappedToCopy(-12);
-//        check(copy, 1972, 6, 27);
-//        
-//        test = new DateTime(1972, 7, 9);
-//        copy = test.dayOfMonth().addWrappedToCopy(21);
-//        check(copy, 1972, 7, 30);
-//    
-//        copy = test.dayOfMonth().addWrappedToCopy(22);
-//        check(copy, 1972, 7, 31);
-//    
-//        copy = test.dayOfMonth().addWrappedToCopy(23);
-//        check(copy, 1972, 7, 1);
-//    
-//        copy = test.dayOfMonth().addWrappedToCopy(-12);
-//        check(copy, 1972, 7, 28);
-//    }
-//
-//    public void testPropertySetDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.dayOfMonth().setCopy(12);
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 6, 12);
-//        
-//        try {
-//            test.dayOfMonth().setCopy(31);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//        try {
-//            test.dayOfMonth().setCopy(0);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//    }
-//
-//    public void testPropertySetTextDay() {
-//        DateTime test = new DateTime(1972, 6, 9);
-//        DateTime copy = test.dayOfMonth().setCopy("12");
-//        check(test, 1972, 6, 9);
-//        check(copy, 1972, 6, 12);
-//    }
-//
-//    public void testPropertyCompareToDay() {
-//        DateTime test1 = new DateTime(TEST_TIME1);
-//        DateTime test2 = new DateTime(TEST_TIME2);
-//        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);
-//        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);
-//        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);
-//        try {
-//            test1.dayOfMonth().compareTo((ReadablePartial) null);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//        
-//        DateTime dt1 = new DateTime(TEST_TIME1);
-//        DateTime dt2 = new DateTime(TEST_TIME2);
-//        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);
-//        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);
-//        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);
-//        try {
-//            test1.dayOfMonth().compareTo((ReadableInstant) null);
-//            fail();
-//        } catch (IllegalArgumentException ex) {}
-//    }
-//
-//    //-----------------------------------------------------------------------
-//    private void check(DateTime test, int hour, int min, int sec) {
-//        assertEquals(hour, test.getYear());
-//        assertEquals(min, test.getMonthOfYear());
-//        assertEquals(sec, test.getDayOfMonth());
-//    }
+    //-----------------------------------------------------------------------
+    public void testPropertyGetMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
+        assertEquals("monthOfYear", test.monthOfYear().getName());
+        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
+        assertSame(test, test.monthOfYear().getInstant());
+        assertSame(test, test.monthOfYear().getDateTime());
+        assertEquals(6, test.monthOfYear().get());
+        assertEquals("June", test.monthOfYear().getAsText());
+        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));
+        assertEquals("Jun", test.monthOfYear().getAsShortText());
+        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());
+        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
+        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
+        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));
+        assertEquals(1, test.monthOfYear().getMinimumValue());
+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());
+        assertEquals(12, test.monthOfYear().getMaximumValue());
+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());
+    }
+
+    public void testPropertyGetMaxMinValuesMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(1, test.monthOfYear().getMinimumValue());
+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());
+        assertEquals(12, test.monthOfYear().getMaximumValue());
+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.monthOfYear().addToCopy(6);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addToCopy(7);
+        assertEquals("1973-01-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addToCopy(-5);
+        assertEquals("1972-01-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addToCopy(-6);
+        assertEquals("1971-12-09T00:00:00.000Z", copy.toString());
+        
+        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        copy = test.monthOfYear().addToCopy(1);
+        assertEquals("1972-01-31T00:00:00.000Z", test.toString());
+        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addToCopy(2);
+        assertEquals("1972-03-31T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addToCopy(3);
+        assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
+        
+        test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
+        copy = test.monthOfYear().addToCopy(1);
+        assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyAddInFieldMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.monthOfYear().addWrappedToCopy(4);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.monthOfYear().addWrappedToCopy(8);
+        assertEquals("1972-02-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addWrappedToCopy(-8);
+        assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
+        
+        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        copy = test.monthOfYear().addWrappedToCopy(1);
+        assertEquals("1972-01-31T00:00:00.000Z", test.toString());
+        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().addWrappedToCopy(2);
+        assertEquals("1972-03-31T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.monthOfYear().addWrappedToCopy(3);
+        assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
+        
+        test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
+        copy = test.monthOfYear().addWrappedToCopy(1);
+        assertEquals("1971-01-31T00:00:00.000Z", test.toString());
+        assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertySetMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.monthOfYear().setCopy(12);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        
+        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        copy = test.monthOfYear().setCopy(2);
+        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        
+        try {
+            test.monthOfYear().setCopy(13);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.monthOfYear().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextMonth() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.monthOfYear().setCopy("12");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().setCopy("December");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        
+        copy = test.monthOfYear().setCopy("Dec");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyCompareToMonth() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);
+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);
+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);
+        try {
+            test1.monthOfYear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);
+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);
+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);
+        try {
+            test1.monthOfYear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
+        assertEquals("dayOfMonth", test.dayOfMonth().getName());
+        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
+        assertSame(test, test.dayOfMonth().getInstant());
+        assertSame(test, test.dayOfMonth().getDateTime());
+        assertEquals(9, test.dayOfMonth().get());
+        assertEquals("9", test.dayOfMonth().getAsText());
+        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));
+        assertEquals("9", test.dayOfMonth().getAsShortText());
+        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());
+        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());
+        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));
+        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));
+        assertEquals(1, test.dayOfMonth().getMinimumValue());
+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
+        assertEquals(30, test.dayOfMonth().getMaximumValue());
+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
+    }
+
+    public void testPropertyGetMaxMinValuesDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(1, test.dayOfMonth().getMinimumValue());
+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
+        assertEquals(30, test.dayOfMonth().getMaximumValue());
+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
+        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        assertEquals(31, test.dayOfMonth().getMaximumValue());
+        test = new DateTime(1972, 2, 9, 0, 0, 0, 0);
+        assertEquals(29, test.dayOfMonth().getMaximumValue());
+        test = new DateTime(1971, 2, 9, 0, 0, 0, 0);
+        assertEquals(28, test.dayOfMonth().getMaximumValue());
+    }
+
+    public void testPropertyAddDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfMonth().addToCopy(9);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-18T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(21);
+        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(22);
+        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(22 + 30);
+        assertEquals("1972-07-31T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(22 + 31);
+        assertEquals("1972-08-01T00:00:00.000+01:00", copy.toString());
+
+        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(-8);
+        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(-9);
+        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyAddInFieldDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfMonth().addWrappedToCopy(21);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addWrappedToCopy(22);
+        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfMonth().addWrappedToCopy(-12);
+        assertEquals("1972-06-27T00:00:00.000+01:00", copy.toString());
+        
+        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        copy = test.dayOfMonth().addWrappedToCopy(21);
+        assertEquals("1972-07-30T00:00:00.000+01:00", copy.toString());
+    
+        copy = test.dayOfMonth().addWrappedToCopy(22);
+        assertEquals("1972-07-31T00:00:00.000+01:00", copy.toString());
+    
+        copy = test.dayOfMonth().addWrappedToCopy(23);
+        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+    
+        copy = test.dayOfMonth().addWrappedToCopy(-12);
+        assertEquals("1972-07-28T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertySetDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfMonth().setCopy(12);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        
+        try {
+            test.dayOfMonth().setCopy(31);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.dayOfMonth().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextDay() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfMonth().setCopy("12");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertyCompareToDay() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);
+        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);
+        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);
+        try {
+            test1.dayOfMonth().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);
+        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);
+        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);
+        try {
+            test1.dayOfMonth().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
 }

From 6d0c7db8dd96b9105a415d98770ad271ad6a01ee Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:37:23 +0000
Subject: [PATCH 0113/1934] Rename AbstractDurationField to BaseDurationField

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@263 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java   | 4 ++--
 .../{AbstractDurationField.java => BaseDurationField.java}    | 4 ++--
 .../src/java/org/joda/time/field/DecoratedDurationField.java  | 2 +-
 .../src/java/org/joda/time/field/ImpreciseDateTimeField.java  | 2 +-
 .../src/java/org/joda/time/field/PreciseDurationField.java    | 2 +-
 5 files changed, 7 insertions(+), 7 deletions(-)
 rename JodaTime/src/java/org/joda/time/field/{AbstractDurationField.java => BaseDurationField.java} (98%)

diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 9b97d1f1a..8bc325de9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -62,7 +62,7 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
 import org.joda.time.field.BaseDateTimeField;
-import org.joda.time.field.AbstractDurationField;
+import org.joda.time.field.BaseDurationField;
 
 /**
  * Wraps another Chronology to add support for time zones.
@@ -281,7 +281,7 @@ public String toString() {
      * fields, can nullify or reverse an add when crossing a transition.
      */
 
-    static class ZonedDurationField extends AbstractDurationField {
+    static class ZonedDurationField extends BaseDurationField {
         static final long serialVersionUID = -485345310999208286L;
 
         final DurationField iField;
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
rename to JodaTime/src/java/org/joda/time/field/BaseDurationField.java
index e566e6b30..1299bed16 100644
--- a/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
@@ -70,7 +70,7 @@
  * @author Brian S O'Neill
  * @see DecoratedDurationField
  */
-public abstract class AbstractDurationField extends DurationField implements Serializable {
+public abstract class BaseDurationField extends DurationField implements Serializable {
 
     /** Serialization lock. */
     private static final long serialVersionUID = -2554245107589433218L;
@@ -78,7 +78,7 @@
     /** A desriptive name for the field. */
     private final String iName;
 
-    protected AbstractDurationField(String name) {
+    protected BaseDurationField(String name) {
         super();
         if (name == null) {
             throw new IllegalArgumentException("The name must not be null");
diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
index be255e298..d4cc1f888 100644
--- a/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
@@ -71,7 +71,7 @@
  * @author Brian S O'Neill
  * @see DelegatedDurationField
  */
-public class DecoratedDurationField extends AbstractDurationField {
+public class DecoratedDurationField extends BaseDurationField {
 
     static final long serialVersionUID = 8019982251647420015L;
 
diff --git a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
index 6c3dd2365..a03aa1ad1 100644
--- a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
@@ -181,7 +181,7 @@ protected final long getDurationUnitMillis() {
         return iUnitMillis;
     }
 
-    private final class LinkedDurationField extends AbstractDurationField {
+    private final class LinkedDurationField extends BaseDurationField {
         static final long serialVersionUID = -203813474600094134L;
 
         LinkedDurationField(String name) {
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
index 7e736f34e..8f082e8ca 100644
--- a/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
@@ -62,7 +62,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class PreciseDurationField extends AbstractDurationField {
+public class PreciseDurationField extends BaseDurationField {
     
     static final long serialVersionUID = -8346152187724495365L;
 

From c9bb201571e8646aae2ae4f47db903eacb40c5b1 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 22:44:00 +0000
Subject: [PATCH 0114/1934] Rename Property.getInstant to getReadableInstant

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@264 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../AbstractReadableInstantFieldProperty.java | 22 +++++++++----------
 .../time/property/DateTimeFieldProperty.java  |  2 +-
 .../ReadWritableInstantFieldProperty.java     |  2 +-
 .../joda/time/TestDateTime_Properties.java    | 14 ++++++------
 4 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
index b6bf79181..ddad80ad3 100644
--- a/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
@@ -107,7 +107,7 @@ public String getName() {
      * 
      * @return the instant
      */
-    public abstract ReadableInstant getInstant();
+    public abstract ReadableInstant getReadableInstant();
 
     //-----------------------------------------------------------------------
     /**
@@ -117,7 +117,7 @@ public String getName() {
      * @see DateTimeField#get
      */
     public int get() {
-        return getField().get(getInstant().getMillis());
+        return getField().get(getReadableInstant().getMillis());
     }
 
     /**
@@ -128,7 +128,7 @@ public int get() {
      * @see DateTimeField#getAsText
      */
     public String getAsText(Locale locale) {
-        return getField().getAsText(getInstant().getMillis(), locale);
+        return getField().getAsText(getReadableInstant().getMillis(), locale);
     }
 
     /**
@@ -149,7 +149,7 @@ public final String getAsText() {
      * @see DateTimeField#getAsShortText
      */
     public String getAsShortText(Locale locale) {
-        return getField().getAsShortText(getInstant().getMillis(), locale);
+        return getField().getAsShortText(getReadableInstant().getMillis(), locale);
     }
 
     /**
@@ -177,7 +177,7 @@ public int getDifference(ReadableInstant instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        return getField().getDifference(getInstant().getMillis(), instant.getMillis());
+        return getField().getDifference(getReadableInstant().getMillis(), instant.getMillis());
     }
 
     /**
@@ -194,7 +194,7 @@ public long getDifferenceAsLong(ReadableInstant instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());
+        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());
     }
 
     //-----------------------------------------------------------------------
@@ -225,7 +225,7 @@ public DurationField getRangeDurationField() {
      * @see DateTimeField#isLeap
      */
     public boolean isLeap() {
-        return getField().isLeap(getInstant().getMillis());
+        return getField().isLeap(getReadableInstant().getMillis());
     }
 
     /**
@@ -235,7 +235,7 @@ public boolean isLeap() {
      * @see DateTimeField#getLeapAmount
      */
     public int getLeapAmount() {
-        return getField().getLeapAmount(getInstant().getMillis());
+        return getField().getLeapAmount(getReadableInstant().getMillis());
     }
 
     /**
@@ -264,7 +264,7 @@ public int getMinimumValueOverall() {
      * @see DateTimeField#getMinimumValue
      */
     public int getMinimumValue() {
-        return getField().getMinimumValue(getInstant().getMillis());
+        return getField().getMinimumValue(getReadableInstant().getMillis());
     }
 
     /**
@@ -284,7 +284,7 @@ public int getMaximumValueOverall() {
      * @see DateTimeField#getMaximumValue
      */
     public int getMaximumValue() {
-        return getField().getMaximumValue(getInstant().getMillis());
+        return getField().getMaximumValue(getReadableInstant().getMillis());
     }
 
     /**
@@ -317,7 +317,7 @@ public int getMaximumShortTextLength(Locale locale) {
      * @return remainder duration, in milliseconds
      */
     public long remainder() {
-        return getField().remainder(getInstant().getMillis());
+        return getField().remainder(getReadableInstant().getMillis());
     }
 
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index be8e6f28f..036957f22 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -124,7 +124,7 @@ public DateTimeField getField() {
      * 
      * @return the instant
      */
-    public ReadableInstant getInstant() {
+    public ReadableInstant getReadableInstant() {
         return iInstant;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
index c07e7e933..cafc0e388 100644
--- a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
@@ -115,7 +115,7 @@ public DateTimeField getField() {
      * 
      * @return the instant
      */
-    public ReadableInstant getInstant() {
+    public ReadableInstant getReadableInstant() {
         return iInstant;
     }
 
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
index 6a30aad61..f09d0e675 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -120,7 +120,7 @@ public void testPropertyGetEra() {
         assertSame(test.getChronology().era(), test.era().getField());
         assertEquals("era", test.era().getName());
         assertEquals("Property[era]", test.era().toString());
-        assertSame(test, test.era().getInstant());
+        assertSame(test, test.era().getReadableInstant());
         assertSame(test, test.era().getDateTime());
         assertEquals(1, test.era().get());
         assertEquals("AD", test.era().getAsText());
@@ -141,7 +141,7 @@ public void testPropertyGetYearOfEra() {
         assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());
         assertEquals("yearOfEra", test.yearOfEra().getName());
         assertEquals("Property[yearOfEra]", test.yearOfEra().toString());
-        assertSame(test, test.yearOfEra().getInstant());
+        assertSame(test, test.yearOfEra().getReadableInstant());
         assertSame(test, test.yearOfEra().getDateTime());
         assertEquals(1972, test.yearOfEra().get());
         assertEquals("1972", test.yearOfEra().getAsText());
@@ -160,7 +160,7 @@ public void testPropertyGetCenturyOfEra() {
         assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());
         assertEquals("centuryOfEra", test.centuryOfEra().getName());
         assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());
-        assertSame(test, test.centuryOfEra().getInstant());
+        assertSame(test, test.centuryOfEra().getReadableInstant());
         assertSame(test, test.centuryOfEra().getDateTime());
         assertEquals(19, test.centuryOfEra().get());
         assertEquals("19", test.centuryOfEra().getAsText());
@@ -179,7 +179,7 @@ public void testPropertyGetYearOfCentury() {
         assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());
         assertEquals("yearOfCentury", test.yearOfCentury().getName());
         assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());
-        assertSame(test, test.yearOfCentury().getInstant());
+        assertSame(test, test.yearOfCentury().getReadableInstant());
         assertSame(test, test.yearOfCentury().getDateTime());
         assertEquals(72, test.yearOfCentury().get());
         assertEquals("72", test.yearOfCentury().getAsText());
@@ -198,7 +198,7 @@ public void testPropertyGetYear() {
         assertSame(test.getChronology().year(), test.year().getField());
         assertEquals("year", test.year().getName());
         assertEquals("Property[year]", test.year().toString());
-        assertSame(test, test.year().getInstant());
+        assertSame(test, test.year().getReadableInstant());
         assertSame(test, test.year().getDateTime());
         assertEquals(1972, test.year().get());
         assertEquals("1972", test.year().getAsText());
@@ -296,7 +296,7 @@ public void testPropertyGetMonth() {
         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
         assertEquals("monthOfYear", test.monthOfYear().getName());
         assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
-        assertSame(test, test.monthOfYear().getInstant());
+        assertSame(test, test.monthOfYear().getReadableInstant());
         assertSame(test, test.monthOfYear().getDateTime());
         assertEquals(6, test.monthOfYear().get());
         assertEquals("June", test.monthOfYear().getAsText());
@@ -447,7 +447,7 @@ public void testPropertyGetDay() {
         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
         assertEquals("dayOfMonth", test.dayOfMonth().getName());
         assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
-        assertSame(test, test.dayOfMonth().getInstant());
+        assertSame(test, test.dayOfMonth().getReadableInstant());
         assertSame(test, test.dayOfMonth().getDateTime());
         assertEquals(9, test.dayOfMonth().get());
         assertEquals("9", test.dayOfMonth().getAsText());

From 19ae379e0f9c3f9b83478bac403ffce7ebdb0d76 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 9 Jul 2004 23:18:35 +0000
Subject: [PATCH 0115/1934] Unify addWrapped and addInField to addWrapField

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@265 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/Examples.java       |  18 +--
 .../src/java/org/joda/time/DateTimeField.java |  24 ++--
 .../java/org/joda/time/MutableDateTime.java   |   6 +-
 .../org/joda/time/ReadWritableInstant.java    |   2 +-
 .../time/chrono/CopticYearDateTimeField.java  |   2 +-
 .../org/joda/time/chrono/GJChronology.java    |   4 +-
 .../chrono/GJMonthOfYearDateTimeField.java    |   5 +-
 .../time/chrono/GJWeekyearDateTimeField.java  |   4 +-
 .../joda/time/chrono/GJYearDateTimeField.java |   2 +-
 .../time/chrono/GJYearOfEraDateTimeField.java |   8 +-
 .../chrono/ISOYearOfEraDateTimeField.java     |   8 +-
 .../org/joda/time/chrono/LimitChronology.java |   4 +-
 .../org/joda/time/chrono/ZonedChronology.java |   4 +-
 .../joda/time/field/BaseDateTimeField.java    |  24 ++--
 .../time/field/DelegatedDateTimeField.java    |   8 +-
 .../joda/time/field/DividedDateTimeField.java |   2 +-
 .../java/org/joda/time/field/FieldUtils.java  |   2 +-
 .../joda/time/field/NonZeroDateTimeField.java |   8 +-
 .../joda/time/field/OffsetDateTimeField.java  |   2 +-
 .../joda/time/field/PreciseDateTimeField.java |   2 +-
 .../time/field/RemainderDateTimeField.java    |   2 +-
 .../time/field/UnsupportedDateTimeField.java  |   4 +-
 .../java/org/joda/time/partial/TimeOfDay.java |   8 +-
 .../org/joda/time/partial/YearMonthDay.java   |   8 +-
 .../time/property/DateTimeFieldProperty.java  |   6 +-
 .../ReadWritableInstantFieldProperty.java     |   6 +-
 .../test/time/AbstractTestDateTimeField.java  |  14 +--
 .../test/time/TestBuddhistChronology.java     |   6 +-
 .../joda/time/TestDateTime_Properties.java    |  42 +++----
 .../org/joda/time/chrono/gj/MainTest.java     |   8 +-
 .../chrono/gj/TestJulianWeekyearField.java    |   2 +-
 .../time/chrono/gj/TestJulianYearField.java   |   2 +-
 .../org/joda/time/partial/TestTimeOfDay.java  | 112 +++++++++---------
 .../joda/time/partial/TestYearMonthDay.java   |  94 +++++++--------
 34 files changed, 226 insertions(+), 227 deletions(-)

diff --git a/JodaTime/src/example/org/joda/example/time/Examples.java b/JodaTime/src/example/org/joda/example/time/Examples.java
index a89b41027..cff0361de 100644
--- a/JodaTime/src/example/org/joda/example/time/Examples.java
+++ b/JodaTime/src/example/org/joda/example/time/Examples.java
@@ -127,15 +127,15 @@ private void runDateTime() {
         System.out.println("Get monthOfYear:      in.getMonthOfYear():      " + in.getMonthOfYear());
         System.out.println("Get dayOfMonth:       in.getDayOfMonth():       " + in.getDayOfMonth());
         System.out.println("...");
-        System.out.println("Property access:      in.dayOfWeek().get():                " + in.dayOfWeek().get());
-        System.out.println("Day of week as text:  in.dayOfWeek().getAsText():          " + in.dayOfWeek().getAsText());
-        System.out.println("Day as short text:    in.dayOfWeek().getAsShortText():     " + in.dayOfWeek().getAsShortText());
-        System.out.println("Day in french:        in.dayOfWeek().getAsText(Locale.FRENCH): " + in.dayOfWeek().getAsText(Locale.FRENCH));
-        System.out.println("Max allowed value:    in.dayOfWeek().getMaximumValue():    " + in.dayOfWeek().getMaximumValue());
-        System.out.println("Min allowed value:    in.dayOfWeek().getMinimumValue():    " + in.dayOfWeek().getMinimumValue());
-        System.out.println("Copy & set to Jan:    in.monthOfYear().setCopy(1):         " + in.monthOfYear().setCopy(1));
-        System.out.println("Copy & add 14 months: in.monthOfYear().addCopy(14):        " + in.monthOfYear().addToCopy(14));
-        System.out.println("Add 14 mnths in field:in.monthOfYear().addInFieldCopy(14): " + in.monthOfYear().addWrappedToCopy(14));
+        System.out.println("Property access:      in.dayOfWeek().get():                   " + in.dayOfWeek().get());
+        System.out.println("Day of week as text:  in.dayOfWeek().getAsText():             " + in.dayOfWeek().getAsText());
+        System.out.println("Day as short text:    in.dayOfWeek().getAsShortText():        " + in.dayOfWeek().getAsShortText());
+        System.out.println("Day in french:        in.dayOfWeek().getAsText(Locale.FRENCH):" + in.dayOfWeek().getAsText(Locale.FRENCH));
+        System.out.println("Max allowed value:    in.dayOfWeek().getMaximumValue():       " + in.dayOfWeek().getMaximumValue());
+        System.out.println("Min allowed value:    in.dayOfWeek().getMinimumValue():       " + in.dayOfWeek().getMinimumValue());
+        System.out.println("Copy & set to Jan:    in.monthOfYear().setCopy(1):            " + in.monthOfYear().setCopy(1));
+        System.out.println("Copy & add 14 months: in.monthOfYear().addCopy(14):           " + in.monthOfYear().addToCopy(14));
+        System.out.println("Add 14 mnths in field:in.monthOfYear().addWrapFieldCopy(14):  " + in.monthOfYear().addWrapFieldToCopy(14));
         System.out.println("...");
         System.out.println("Convert to Instant:   in.toInstant():           " + in.toInstant());
         System.out.println("Convert to DateTime:  in.toDateTime():          " + in.toDateTime());
diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 980d1b971..bfa3dea28 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -271,17 +271,17 @@ public String getAsShortText(ReadablePartial partial, Locale locale) {
      * smaller field is adjusted to be in range.
      * <p>
      * For example, in the ISO chronology:<br>
-     * 2000-08-20 addWrapped six months is 2000-02-20<br>
-     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>
-     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>
-     * 2001-01-31 addWrapped one month  is 2001-02-28<br>
-     * 2001-01-31 addWrapped two months is 2001-03-31<br>
+     * 2000-08-20 addWrapField six months is 2000-02-20<br>
+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapField two months is 2001-03-31<br>
      * 
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public abstract long addWrapped(long instant, int value) ;
+    public abstract long addWrapField(long instant, int value) ;
 
     /**
      * Adds a value (which may be negative) to the partial instant,
@@ -294,11 +294,11 @@ public String getAsShortText(ReadablePartial partial, Locale locale) {
      * smaller field is adjusted to be in range.
      * <p>
      * For example, in the ISO chronology:<br>
-     * 2000-08-20 addInField six months is 2000-02-20<br>
-     * 2000-08-20 addInField twenty months is 2000-04-20<br>
-     * 2000-08-20 addInField minus nine months is 2000-11-20<br>
-     * 2001-01-31 addInField one month  is 2001-02-28<br>
-     * 2001-01-31 addInField two months is 2001-03-31<br>
+     * 2000-08-20 addWrapField six months is 2000-02-20<br>
+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapField two months is 2001-03-31<br>
      * 
      * @param instant  the partial instant
      * @param fieldIndex  the index of this field in the instant
@@ -307,7 +307,7 @@ public String getAsShortText(ReadablePartial partial, Locale locale) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public abstract int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);
+    public abstract int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);
 
     /**
      * Computes the difference between two instants, as measured in the units
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 514cc2bc2..950bf3898 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -525,15 +525,15 @@ public void add(final DateTimeField field, final int value) {
      * For example:
      * <pre>
      * MutableDateTime dt = new MutableDateTime();
-     * dt.addWrapped(GJChronology.getInstance().monthOfYear(), 6);
+     * addWrapField(GJChronology.getInstance().monthOfYear(), 6);
      * </pre>
      * 
      * @param field  the DateTimeField to use
      * @param value the value
      * @throws NullPointerException if the field is null
      */
-    public void addWrapped(final DateTimeField field, final int value) {
-        setMillis(field.addWrapped(getMillis(), value));
+    public void addWrapField(final DateTimeField field, final int value) {
+        setMillis(field.addWrapField(getMillis(), value));
     }
 
     // Date methods
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index 28dc09be4..8624e11cf 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -262,6 +262,6 @@
      * @param value  the value of that field for the millis set in the implementation
      * @throws IllegalArgumentException if the value is invalid
      */
-    void addWrapped(DateTimeField field, int value);
+    void addWrapField(DateTimeField field, int value);
     
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
index 4ba2c729d..a782933c4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
@@ -96,7 +96,7 @@ public long add(long instant, long years) {
         return add(instant, FieldUtils.safeToInt(years));
     }
 
-    public long addWrapped(long instant, int years) {
+    public long addWrapField(long instant, int years) {
         if (years == 0) {
             return instant;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index e28324e99..c2782326e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -597,7 +597,7 @@ long gregorianToJulianByWeekyear(long instant) {
 
     /**
      * This basic cutover field adjusts calls to 'get' and 'set' methods, and
-     * assumes that calls to add and addWrapped are unaffected by the cutover.
+     * assumes that calls to add and addWrapField are unaffected by the cutover.
      */
     private class CutoverField extends BaseDateTimeField {
         static final long serialVersionUID = 3528501219481026402L;
@@ -879,7 +879,7 @@ protected long gregorianToJulian(long instant) {
     /**
      * Cutover field for variable length fields. These fields internally call
      * set whenever add is called. As a result, the same correction applied to
-     * set must be applied to add and addWrapped. Knowing when to use this
+     * set must be applied to add and addWrapField. Knowing when to use this
      * field requires specific knowledge of how the GJ fields are implemented.
      */
     private final class ImpreciseCutoverField extends CutoverField {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
index 05cb3f279..d1adc239c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
@@ -240,13 +240,12 @@ public long add(long instant, long months) {
      * Add to the Month component of the specified time instant
      * wrapping around within that component if necessary.
      * 
-     * @see org.joda.time.DateTimeField#addWrapped
-     * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)
+     * @see org.joda.time.DateTimeField#addWrapField
      * @param instant  the time instant in millis to update.
      * @param months  the months to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int months) {
+    public long addWrapField(long instant, int months) {
         return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
index b7c1950e7..4aa97f448 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
@@ -123,12 +123,12 @@ public long add(long instant, long value) {
      * Add to the year component of the specified time instant
      * wrapping around within that component if necessary.
      * 
-     * @see org.joda.time.DateTimeField#addWrapped
+     * @see org.joda.time.DateTimeField#addWrapField
      * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int years) {
+    public long addWrapField(long instant, int years) {
         return add(instant, years);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
index c7312a863..db4cbf204 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
@@ -125,7 +125,7 @@ public long add(long instant, long years) {
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int years) {
+    public long addWrapField(long instant, int years) {
         if (years == 0) {
             return instant;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index bc3df81de..5ef68cabd 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -93,12 +93,12 @@ public long add(long instant, long years) {
         return getWrappedField().add(instant, years);
     }
 
-    public long addWrapped(long instant, int years) {
-        return getWrappedField().addWrapped(instant, years);
+    public long addWrapField(long instant, int years) {
+        return getWrappedField().addWrapField(instant, years);
     }
 
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
-        return getWrappedField().addInField(instant, fieldIndex, values, years);
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
+        return getWrappedField().addWrapField(instant, fieldIndex, values, years);
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
index 686f2fcf4..169e892f0 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
@@ -95,12 +95,12 @@ public long add(long instant, long years) {
         return getWrappedField().add(instant, years);
     }
 
-    public long addWrapped(long instant, int years) {
-        return getWrappedField().addWrapped(instant, years);
+    public long addWrapField(long instant, int years) {
+        return getWrappedField().addWrapField(instant, years);
     }
 
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
-        return getWrappedField().addInField(instant, fieldIndex, values, years);
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {
+        return getWrappedField().addWrapField(instant, fieldIndex, values, years);
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index ca492ae82..053843cd8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -508,9 +508,9 @@ public long add(long instant, long amount) {
             return result;
         }
 
-        public long addWrapped(long instant, int amount) {
+        public long addWrapField(long instant, int amount) {
             checkLimits(instant, null);
-            long result = getWrappedField().addWrapped(instant, amount);
+            long result = getWrappedField().addWrapField(instant, amount);
             checkLimits(result, "resulting");
             return result;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 8bc325de9..6cc015ecf 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -410,9 +410,9 @@ public long add(long instant, long value) {
             return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
-        public long addWrapped(long instant, int value) {
+        public long addWrapField(long instant, int value) {
             int offset = this.iZone.getOffset(instant);
-            instant = iField.addWrapped(instant + offset, value);
+            instant = iField.addWrapField(instant + offset, value);
             return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 8c3a6e604..38c527b90 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -341,11 +341,11 @@ public long add(long instant, long value) {
      * smaller field is adjusted to be in range.
      * <p>
      * For example, in the ISO chronology:<br>
-     * 2000-08-20 addWrapped six months is 2000-02-20<br>
-     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>
-     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>
-     * 2001-01-31 addWrapped one month  is 2001-02-28<br>
-     * 2001-01-31 addWrapped two months is 2001-03-31<br>
+     * 2000-08-20 addWrapField six months is 2000-02-20<br>
+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapField two months is 2001-03-31<br>
      * <p>
      * The default implementation internally calls set. Subclasses are
      * encouraged to provide a more efficient implementation.
@@ -354,7 +354,7 @@ public long add(long instant, long value) {
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long addWrapped(long instant, int value) {
+    public long addWrapField(long instant, int value) {
         int current = get(instant);
         int wrapped = FieldUtils.getWrappedValue
             (current, value, getMinimumValue(instant), getMaximumValue(instant));
@@ -372,11 +372,11 @@ public long addWrapped(long instant, int value) {
      * smaller field is adjusted to be in range.
      * <p>
      * For example, in the ISO chronology:<br>
-     * 2000-08-20 addInField six months is 2000-02-20<br>
-     * 2000-08-20 addInField twenty months is 2000-04-20<br>
-     * 2000-08-20 addInField minus nine months is 2000-11-20<br>
-     * 2001-01-31 addInField one month  is 2001-02-28<br>
-     * 2001-01-31 addInField two months is 2001-03-31<br>
+     * 2000-08-20 addWrapField six months is 2000-02-20<br>
+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapField two months is 2001-03-31<br>
      * <p>
      * The default implementation internally calls set. Subclasses are
      * encouraged to provide a more efficient implementation.
@@ -388,7 +388,7 @@ public long addWrapped(long instant, int value) {
      * @return the passed in values
      * @throws IllegalArgumentException if the value is invalid
      */
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         int current = values[fieldIndex];
         int wrapped = FieldUtils.getWrappedValue
             (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 473c8384f..9eec0ca0f 100644
--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -173,12 +173,12 @@ public long add(long instant, long value) {
         return iField.add(instant, fieldIndex, values, valueToAdd);
     }
 
-    public long addWrapped(long instant, int value) {
-        return iField.addWrapped(instant, value);
+    public long addWrapField(long instant, int value) {
+        return iField.addWrapField(instant, value);
     }
 
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
-        return iField.addInField(instant, fieldIndex, values, valueToAdd);
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
+        return iField.addWrapField(instant, fieldIndex, values, valueToAdd);
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
diff --git a/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
index 81e5cd8dc..faa586fc1 100644
--- a/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
@@ -186,7 +186,7 @@ public long add(long instant, long amount) {
      * @param amount  the amount of scaled units to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int amount) {
+    public long addWrapField(long instant, int amount) {
         return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/FieldUtils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
index 4064aa778..f00bd563f 100644
--- a/JodaTime/src/java/org/joda/time/field/FieldUtils.java
+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
@@ -171,7 +171,7 @@ public static void verifyValueBounds(String fieldName,
     }
 
     /**
-     * Utility method used by addWrapped implementations to ensure the new
+     * Utility method used by addWrapField implementations to ensure the new
      * value lies within the field's legal value range.
      *
      * @param currentValue the current value of the data, which may lie outside
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index d49f0083e..48dc17618 100644
--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -98,12 +98,12 @@ public long add(long instant, long value) {
         return getWrappedField().add(instant, value);
     }
 
-    public long addWrapped(long instant, int value) {
-        return getWrappedField().addWrapped(instant, value);
+    public long addWrapField(long instant, int value) {
+        return getWrappedField().addWrapField(instant, value);
     }
 
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
-        return getWrappedField().addInField(instant, fieldIndex, values, valueToAdd);
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
+        return getWrappedField().addWrapField(instant, fieldIndex, values, valueToAdd);
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
diff --git a/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
index 9b997fd77..984eba663 100644
--- a/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
@@ -162,7 +162,7 @@ public long add(long instant, long amount) {
      * @param amount  the amount of units to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int amount) {
+    public long addWrapField(long instant, int amount) {
         return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
index 31ae3023b..acf6db952 100644
--- a/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
@@ -128,7 +128,7 @@ public int get(long instant) {
      * @param amount  the amount of units to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int amount) {
+    public long addWrapField(long instant, int amount) {
         int thisValue = get(instant);
         int wrappedValue = FieldUtils.getWrappedValue
             (thisValue, amount, getMinimumValue(), getMaximumValue());
diff --git a/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
index efee8d77b..3c91a873a 100644
--- a/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
@@ -140,7 +140,7 @@ public int get(long instant) {
      * @param amount  the amount to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long instant, int amount) {
+    public long addWrapField(long instant, int amount) {
         return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
     }
 
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index 38e4cbaff..542ac61cb 100644
--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -216,7 +216,7 @@ public long add(long instant, long value) {
      *
      * @throws UnsupportedOperationException
      */
-    public long addWrapped(long instant, int value) {
+    public long addWrapField(long instant, int value) {
         throw unsupported();
     }
 
@@ -225,7 +225,7 @@ public long addWrapped(long instant, int value) {
      *
      * @throws UnsupportedOperationException
      */
-    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {
         throw unsupported();
     }
 
diff --git a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
index 300c372c6..6366c98e4 100644
--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
@@ -496,7 +496,7 @@ public int get() {
          * @return a copy of the TimeOfDay with the field value changed
          * @throws IllegalArgumentException if the value isn't valid
          */
-        public TimeOfDay addCopy(int valueToAdd) {
+        public TimeOfDay addToCopy(int valueToAdd) {
             int[] newValues = iTimeOfDay.getValues();
             newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);
             return new TimeOfDay(iTimeOfDay, newValues);
@@ -511,7 +511,7 @@ public TimeOfDay addCopy(int valueToAdd) {
          * Other fields are unaffected.
          * <p>
          * For example,
-         * <code>12:59:37</code> addInField one minute returns <code>12:00:37</code>.
+         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.
          * <p>
          * The TimeOfDay attached to this property is unchanged by this call.
          * Instead, a new instance is returned.
@@ -520,9 +520,9 @@ public TimeOfDay addCopy(int valueToAdd) {
          * @return a copy of the TimeOfDay with the field value changed
          * @throws IllegalArgumentException if the value isn't valid
          */
-        public TimeOfDay addInFieldCopy(int valueToAdd) {
+        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {
             int[] newValues = iTimeOfDay.getValues();
-            newValues = getField().addInField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);
+            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);
             return new TimeOfDay(iTimeOfDay, newValues);
         }
 
diff --git a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
index 70c77aa97..a233ce96b 100644
--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
@@ -408,7 +408,7 @@ public int get() {
          * @return a copy of the YearMonthDay with the field value changed
          * @throws IllegalArgumentException if the value isn't valid
          */
-        public YearMonthDay addCopy(int valueToAdd) {
+        public YearMonthDay addToCopy(int valueToAdd) {
             int[] newValues = iYearMonthDay.getValues();
             newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);
             return new YearMonthDay(iYearMonthDay, newValues);
@@ -423,7 +423,7 @@ public YearMonthDay addCopy(int valueToAdd) {
          * Other fields are unaffected.
          * <p>
          * For example,
-         * <code>2004-12-20</code> addInField one month returns <code>2004-01-20</code>.
+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.
          * <p>
          * The YearMonthDay attached to this property is unchanged by this call.
          * Instead, a new instance is returned.
@@ -432,9 +432,9 @@ public YearMonthDay addCopy(int valueToAdd) {
          * @return a copy of the YearMonthDay with the field value changed
          * @throws IllegalArgumentException if the value isn't valid
          */
-        public YearMonthDay addInFieldCopy(int valueToAdd) {
+        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {
             int[] newValues = iYearMonthDay.getValues();
-            newValues = getField().addInField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);
+            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);
             return new YearMonthDay(iYearMonthDay, newValues);
         }
 
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index 036957f22..cbdb7ca82 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -175,7 +175,7 @@ public DateTime addToCopy(long value) {
     /**
      * Adds to this field, possibly wrapped, in a copy of this DateTime.
      * A wrapped operation only changes this field.
-     * Thus 31st January addWrapped one day goes to the 1st January.
+     * Thus 31st January addWrapField one day goes to the 1st January.
      * <p>
      * The DateTime attached to this property is unchanged by this call.
      * This operation is faster than converting a DateTime to a MutableDateTime
@@ -186,9 +186,9 @@ public DateTime addToCopy(long value) {
      * @return a copy of the DateTime with the field value changed
      * @throws IllegalArgumentException if the value isn't valid
      */
-    public DateTime addWrappedToCopy(int value) {
+    public DateTime addWrapFieldToCopy(int value) {
         DateTime instant = iInstant;
-        return instant.withMillis(iField.addWrapped(instant.getMillis(), value));
+        return instant.withMillis(iField.addWrapField(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
index cafc0e388..1e93d48ff 100644
--- a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
@@ -144,10 +144,10 @@ public void add(long value) {
      * Adds a value, possibly wrapped, to the millis value.
      * 
      * @param value  the value to add
-     * @see DateTimeField#addWrapped
+     * @see DateTimeField#addWrapField
      */
-    public void addWrapped(int value) {
-        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));
+    public void addWrapField(int value) {
+        iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
index 75409d87e..63801c0a3 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
@@ -461,13 +461,13 @@ public void testAddWrapped() throws Exception {
         long[] var = getAllTestPositions();
         for (int i = 0; i < var.length; i++) {
             long millis = var[i];
-            assertEquals(var, i, getAddWrappedResult(millis, 1), field.addWrapped(millis, 1));
-            assertEquals(var, i, getAddWrappedResult(millis, -1), field.addWrapped(millis, -1));
-            assertEquals(var, i, getAddWrappedResult(millis, 0), field.addWrapped(millis, 0));
-            assertEquals(var, i, getAddWrappedResult(millis, 2), field.addWrapped(millis, 2));
-            assertEquals(var, i, getAddWrappedResult(millis, 8), field.addWrapped(millis, 8));
-            assertEquals(var, i, getAddWrappedResult(millis, 9), field.addWrapped(millis, 9));
-            assertEquals(var, i, getAddWrappedResult(millis, -13), field.addWrapped(millis, -13));
+            assertEquals(var, i, getAddWrappedResult(millis, 1), field.addWrapField(millis, 1));
+            assertEquals(var, i, getAddWrappedResult(millis, -1), field.addWrapField(millis, -1));
+            assertEquals(var, i, getAddWrappedResult(millis, 0), field.addWrapField(millis, 0));
+            assertEquals(var, i, getAddWrappedResult(millis, 2), field.addWrapField(millis, 2));
+            assertEquals(var, i, getAddWrappedResult(millis, 8), field.addWrapField(millis, 8));
+            assertEquals(var, i, getAddWrappedResult(millis, 9), field.addWrapField(millis, 9));
+            assertEquals(var, i, getAddWrappedResult(millis, -13), field.addWrapField(millis, -13));
         }
     }
 
diff --git a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
index 902da32e3..9079c1d56 100644
--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
@@ -202,8 +202,8 @@ public void testYear() {
         assertEquals(MILLIS_1971, iChrono.year().add(MILLIS_1970, 1));
         assertEquals(MILLIS_1969, iChrono.year().add(MILLIS_1970, -1));
         
-        assertEquals(MILLIS_1971, iChrono.year().addWrapped(MILLIS_1970, 1));
-        assertEquals(MILLIS_1969, iChrono.year().addWrapped(MILLIS_1970, -1));
+        assertEquals(MILLIS_1971, iChrono.year().addWrapField(MILLIS_1970, 1));
+        assertEquals(MILLIS_1969, iChrono.year().addWrapField(MILLIS_1970, -1));
         
         assertEquals("2513", iChrono.year().getAsShortText(MILLIS_1970));
         assertEquals(9, iChrono.year().getMaximumShortTextLength(null));
@@ -257,7 +257,7 @@ public void testEra() {
         } catch (UnsupportedOperationException ex) {}
         
         try {
-            iChrono.era().addWrapped(SMALL_MILLIS, 1);
+            iChrono.era().addWrapField(SMALL_MILLIS, 1);
             fail();
         } catch (UnsupportedOperationException ex) {}
         
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
index f09d0e675..9392be372 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -248,19 +248,19 @@ public void testPropertyAddYear() {
         } catch (IllegalArgumentException ex) {}
     }
 
-    public void testPropertyAddInFieldYear() {
+    public void testPropertyAddWrapFieldYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
-        DateTime copy = test.year().addWrappedToCopy(9);
+        DateTime copy = test.year().addWrapFieldToCopy(9);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1981-06-09T00:00:00.000+01:00", copy.toString());
         
-        copy = test.year().addWrappedToCopy(0);
+        copy = test.year().addWrapFieldToCopy(0);
         assertEquals(1972, copy.getYear());
         
-        copy = test.year().addWrappedToCopy(292277023 - 1972 + 1);
+        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);
         assertEquals(-292275054, copy.getYear());
         
-        copy = test.year().addWrappedToCopy(-292275054 - 1972 - 1);
+        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);
         assertEquals(292277023, copy.getYear());
     }
 
@@ -355,31 +355,31 @@ public void testPropertyAddMonth() {
         assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
     }
 
-    public void testPropertyAddInFieldMonth() {
+    public void testPropertyAddWrapFieldMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
-        DateTime copy = test.monthOfYear().addWrappedToCopy(4);
+        DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
         
-        copy = test.monthOfYear().addWrappedToCopy(8);
+        copy = test.monthOfYear().addWrapFieldToCopy(8);
         assertEquals("1972-02-09T00:00:00.000Z", copy.toString());
         
-        copy = test.monthOfYear().addWrappedToCopy(-8);
+        copy = test.monthOfYear().addWrapFieldToCopy(-8);
         assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
         
         test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
-        copy = test.monthOfYear().addWrappedToCopy(1);
+        copy = test.monthOfYear().addWrapFieldToCopy(1);
         assertEquals("1972-01-31T00:00:00.000Z", test.toString());
         assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
         
-        copy = test.monthOfYear().addWrappedToCopy(2);
+        copy = test.monthOfYear().addWrapFieldToCopy(2);
         assertEquals("1972-03-31T00:00:00.000+01:00", copy.toString());
         
-        copy = test.monthOfYear().addWrappedToCopy(3);
+        copy = test.monthOfYear().addWrapFieldToCopy(3);
         assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
         
         test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
-        copy = test.monthOfYear().addWrappedToCopy(1);
+        copy = test.monthOfYear().addWrapFieldToCopy(1);
         assertEquals("1971-01-31T00:00:00.000Z", test.toString());
         assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
     }
@@ -515,29 +515,29 @@ public void testPropertyAddDay() {
         assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
     }
 
-    public void testPropertyAddInFieldDay() {
+    public void testPropertyAddWrapFieldDay() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
-        DateTime copy = test.dayOfMonth().addWrappedToCopy(21);
+        DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
         
-        copy = test.dayOfMonth().addWrappedToCopy(22);
+        copy = test.dayOfMonth().addWrapFieldToCopy(22);
         assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
         
-        copy = test.dayOfMonth().addWrappedToCopy(-12);
+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);
         assertEquals("1972-06-27T00:00:00.000+01:00", copy.toString());
         
         test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
-        copy = test.dayOfMonth().addWrappedToCopy(21);
+        copy = test.dayOfMonth().addWrapFieldToCopy(21);
         assertEquals("1972-07-30T00:00:00.000+01:00", copy.toString());
     
-        copy = test.dayOfMonth().addWrappedToCopy(22);
+        copy = test.dayOfMonth().addWrapFieldToCopy(22);
         assertEquals("1972-07-31T00:00:00.000+01:00", copy.toString());
     
-        copy = test.dayOfMonth().addWrappedToCopy(23);
+        copy = test.dayOfMonth().addWrapFieldToCopy(23);
         assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
     
-        copy = test.dayOfMonth().addWrappedToCopy(-12);
+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);
         assertEquals("1972-07-28T00:00:00.000+01:00", copy.toString());
     }
 
diff --git a/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
index 4818f88cb..38f9d7ce9 100644
--- a/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
@@ -280,10 +280,10 @@ private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,
         y = fieldB.add(millis, value);
         testMillis(fieldA, fieldB, "add", millis, x, y);
 
-        // addWrapped test
-        x = fieldA.addWrapped(millis, value);
-        y = fieldB.addWrapped(millis, value);
-        testMillis(fieldA, fieldB, "addWrapped", millis, x, y);
+        // addWrapField test
+        x = fieldA.addWrapField(millis, value);
+        y = fieldB.addWrapField(millis, value);
+        testMillis(fieldA, fieldB, "addWrapField", millis, x, y);
 
         // getDifference test
         x = fieldA.getDifference(millis, millis2);
diff --git a/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
index 4f506161c..be6ea4994 100644
--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java
@@ -64,7 +64,7 @@ public TestJulianWeekyearField(TestJulianChronology chrono) {
         super(chrono);
     }
 
-    public long addWrapped(long millis, int value) {
+    public long addWrapField(long millis, int value) {
         int weekyear = get(millis);
         int wrapped = FieldUtils.getWrappedValue
             (weekyear, value, getMinimumValue(), getMaximumValue());
diff --git a/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
index a9779cfb7..04c16b439 100644
--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java
@@ -64,7 +64,7 @@ public TestJulianYearField(TestJulianChronology chrono) {
         super(chrono);
     }
 
-    public long addWrapped(long millis, int value) {
+    public long addWrapField(long millis, int value) {
         int year = get(millis);
         int wrapped = FieldUtils.getWrappedValue
             (year, value, getMinimumValue(), getMaximumValue());
diff --git a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
index 8835d7b45..f9758a7bf 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java
@@ -836,45 +836,45 @@ public void testPropertyGetMaxMinValuesHour() {
 
     public void testPropertyAddHour() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.hourOfDay().addCopy(9);
+        TimeOfDay copy = test.hourOfDay().addToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 19, 20, 30, 40);
         
-        copy = test.hourOfDay().addCopy(0);
+        copy = test.hourOfDay().addToCopy(0);
         check(copy, 10, 20, 30, 40);
         
-        copy = test.hourOfDay().addCopy(13);
+        copy = test.hourOfDay().addToCopy(13);
         check(copy, 23, 20, 30, 40);
         
         try {
-            test.hourOfDay().addCopy(14);
+            test.hourOfDay().addToCopy(14);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
         
-        copy = test.hourOfDay().addCopy(-10);
+        copy = test.hourOfDay().addToCopy(-10);
         check(copy, 0, 20, 30, 40);
         
         try {
-            test.hourOfDay().addCopy(-11);
+            test.hourOfDay().addToCopy(-11);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
     }
 
-    public void testPropertyAddInFieldHour() {
+    public void testPropertyAddWrapFieldHour() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.hourOfDay().addInFieldCopy(9);
+        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 19, 20, 30, 40);
         
-        copy = test.hourOfDay().addInFieldCopy(0);
+        copy = test.hourOfDay().addWrapFieldToCopy(0);
         check(copy, 10, 20, 30, 40);
         
-        copy = test.hourOfDay().addInFieldCopy(18);
+        copy = test.hourOfDay().addWrapFieldToCopy(18);
         check(copy, 4, 20, 30, 40);
         
-        copy = test.hourOfDay().addInFieldCopy(-15);
+        copy = test.hourOfDay().addWrapFieldToCopy(-15);
         check(copy, 19, 20, 30, 40);
     }
 
@@ -952,60 +952,60 @@ public void testPropertyGetMaxMinValuesMinute() {
 
     public void testPropertyAddMinute() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.minuteOfHour().addCopy(9);
+        TimeOfDay copy = test.minuteOfHour().addToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 29, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(39);
+        copy = test.minuteOfHour().addToCopy(39);
         check(copy, 10, 59, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(40);
+        copy = test.minuteOfHour().addToCopy(40);
         check(copy, 11, 0, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(1 * 60 + 45);
+        copy = test.minuteOfHour().addToCopy(1 * 60 + 45);
         check(copy, 12, 5, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(13 * 60 + 39);
+        copy = test.minuteOfHour().addToCopy(13 * 60 + 39);
         check(copy, 23, 59, 30, 40);
         
         try {
-            test.minuteOfHour().addCopy(13 * 60 + 40);
+            test.minuteOfHour().addToCopy(13 * 60 + 40);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(-9);
+        copy = test.minuteOfHour().addToCopy(-9);
         check(copy, 10, 11, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(-19);
+        copy = test.minuteOfHour().addToCopy(-19);
         check(copy, 10, 1, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(-20);
+        copy = test.minuteOfHour().addToCopy(-20);
         check(copy, 10, 0, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(-21);
+        copy = test.minuteOfHour().addToCopy(-21);
         check(copy, 9, 59, 30, 40);
         
-        copy = test.minuteOfHour().addCopy(-(10 * 60 + 20));
+        copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));
         check(copy, 0, 0, 30, 40);
         
         try {
-            test.minuteOfHour().addCopy(-(10 * 60 + 21));
+            test.minuteOfHour().addToCopy(-(10 * 60 + 21));
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
     }
 
-    public void testPropertyAddInFieldMinute() {
+    public void testPropertyAddWrapFieldMinute() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.minuteOfHour().addInFieldCopy(9);
+        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 29, 30, 40);
         
-        copy = test.minuteOfHour().addInFieldCopy(49);
+        copy = test.minuteOfHour().addWrapFieldToCopy(49);
         check(copy, 10, 9, 30, 40);
         
-        copy = test.minuteOfHour().addInFieldCopy(-47);
+        copy = test.minuteOfHour().addWrapFieldToCopy(-47);
         check(copy, 10, 33, 30, 40);
     }
 
@@ -1083,57 +1083,57 @@ public void testPropertyGetMaxMinValuesSecond() {
 
     public void testPropertyAddSecond() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.secondOfMinute().addCopy(9);
+        TimeOfDay copy = test.secondOfMinute().addToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 39, 40);
         
-        copy = test.secondOfMinute().addCopy(29);
+        copy = test.secondOfMinute().addToCopy(29);
         check(copy, 10, 20, 59, 40);
         
-        copy = test.secondOfMinute().addCopy(30);
+        copy = test.secondOfMinute().addToCopy(30);
         check(copy, 10, 21, 0, 40);
         
-        copy = test.secondOfMinute().addCopy(39 * 60 + 29);
+        copy = test.secondOfMinute().addToCopy(39 * 60 + 29);
         check(copy, 10, 59, 59, 40);
         
-        copy = test.secondOfMinute().addCopy(39 * 60 + 30);
+        copy = test.secondOfMinute().addToCopy(39 * 60 + 30);
         check(copy, 11, 0, 0, 40);
         
         try {
-            test.secondOfMinute().addCopy(13 * 60 * 60 + 39 * 60 + 30);
+            test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
         
-        copy = test.secondOfMinute().addCopy(-9);
+        copy = test.secondOfMinute().addToCopy(-9);
         check(copy, 10, 20, 21, 40);
         
-        copy = test.secondOfMinute().addCopy(-30);
+        copy = test.secondOfMinute().addToCopy(-30);
         check(copy, 10, 20, 0, 40);
         
-        copy = test.secondOfMinute().addCopy(-31);
+        copy = test.secondOfMinute().addToCopy(-31);
         check(copy, 10, 19, 59, 40);
         
-        copy = test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 30));
+        copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));
         check(copy, 0, 0, 0, 40);
         
         try {
-            test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 31));
+            test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
     }
 
-    public void testPropertyAddInFieldSecond() {
+    public void testPropertyAddWrapFieldSecond() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.secondOfMinute().addInFieldCopy(9);
+        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 39, 40);
         
-        copy = test.secondOfMinute().addInFieldCopy(49);
+        copy = test.secondOfMinute().addWrapFieldToCopy(49);
         check(copy, 10, 20, 19, 40);
         
-        copy = test.secondOfMinute().addInFieldCopy(-47);
+        copy = test.secondOfMinute().addWrapFieldToCopy(-47);
         check(copy, 10, 20, 43, 40);
     }
 
@@ -1211,54 +1211,54 @@ public void testPropertyGetMaxMinValuesMilli() {
 
     public void testPropertyAddMilli() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.millisOfSecond().addCopy(9);
+        TimeOfDay copy = test.millisOfSecond().addToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 30, 49);
         
-        copy = test.millisOfSecond().addCopy(959);
+        copy = test.millisOfSecond().addToCopy(959);
         check(copy, 10, 20, 30, 999);
         
-        copy = test.millisOfSecond().addCopy(960);
+        copy = test.millisOfSecond().addToCopy(960);
         check(copy, 10, 20, 31, 0);
         
-        copy = test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);
+        copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);
         check(copy, 23, 59, 59, 999);
         
         try {
-            test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);
+            test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
         
-        copy = test.millisOfSecond().addCopy(-9);
+        copy = test.millisOfSecond().addToCopy(-9);
         check(copy, 10, 20, 30, 31);
         
-        copy = test.millisOfSecond().addCopy(-40);
+        copy = test.millisOfSecond().addToCopy(-40);
         check(copy, 10, 20, 30, 0);
         
-        copy = test.millisOfSecond().addCopy(-41);
+        copy = test.millisOfSecond().addToCopy(-41);
         check(copy, 10, 20, 29, 999);
         
-        copy = test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));
+        copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));
         check(copy, 0, 0, 0, 0);
         
         try {
-            test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));
+            test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 10, 20, 30, 40);
     }
 
-    public void testPropertyAddInFieldMilli() {
+    public void testPropertyAddWrapFieldMilli() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        TimeOfDay copy = test.millisOfSecond().addInFieldCopy(9);
+        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);
         check(test, 10, 20, 30, 40);
         check(copy, 10, 20, 30, 49);
         
-        copy = test.millisOfSecond().addInFieldCopy(995);
+        copy = test.millisOfSecond().addWrapFieldToCopy(995);
         check(copy, 10, 20, 30, 35);
         
-        copy = test.millisOfSecond().addInFieldCopy(-47);
+        copy = test.millisOfSecond().addWrapFieldToCopy(-47);
         check(copy, 10, 20, 30, 993);
     }
 
diff --git a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
index e9fa20cb4..c5bf36050 100644
--- a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java
@@ -634,48 +634,48 @@ public void testPropertyGetMaxMinValuesYear() {
 
     public void testPropertyAddYear() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.year().addCopy(9);
+        YearMonthDay copy = test.year().addToCopy(9);
         check(test, 1972, 6, 9);
         check(copy, 1981, 6, 9);
         
-        copy = test.year().addCopy(0);
+        copy = test.year().addToCopy(0);
         check(copy, 1972, 6, 9);
         
-        copy = test.year().addCopy(292277023 - 1972);
+        copy = test.year().addToCopy(292277023 - 1972);
         check(copy, 292277023, 6, 9);
         
         try {
-            test.year().addCopy(292277023 - 1972 + 1);
+            test.year().addToCopy(292277023 - 1972 + 1);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 1972, 6, 9);
         
-        copy = test.year().addCopy(-1972);
+        copy = test.year().addToCopy(-1972);
         check(copy, 0, 6, 9);
         
-        copy = test.year().addCopy(-1973);
+        copy = test.year().addToCopy(-1973);
         check(copy, -1, 6, 9);
         
         try {
-            test.year().addCopy(-292275054 - 1972 - 1);
+            test.year().addToCopy(-292275054 - 1972 - 1);
             fail();
         } catch (IllegalArgumentException ex) {}
         check(test, 1972, 6, 9);
     }
 
-    public void testPropertyAddInFieldYear() {
+    public void testPropertyAddWrapFieldYear() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.year().addInFieldCopy(9);
+        YearMonthDay copy = test.year().addWrapFieldToCopy(9);
         check(test, 1972, 6, 9);
         check(copy, 1981, 6, 9);
         
-        copy = test.year().addInFieldCopy(0);
+        copy = test.year().addWrapFieldToCopy(0);
         check(copy, 1972, 6, 9);
         
-        copy = test.year().addInFieldCopy(292277023 - 1972 + 1);
+        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);
         check(copy, -292275054, 6, 9);
         
-        copy = test.year().addInFieldCopy(-292275054 - 1972 - 1);
+        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);
         check(copy, 292277023, 6, 9);
     }
 
@@ -747,58 +747,58 @@ public void testPropertyGetMaxMinValuesMonth() {
 
     public void testPropertyAddMonth() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.monthOfYear().addCopy(6);
+        YearMonthDay copy = test.monthOfYear().addToCopy(6);
         check(test, 1972, 6, 9);
         check(copy, 1972, 12, 9);
         
-        copy = test.monthOfYear().addCopy(7);
+        copy = test.monthOfYear().addToCopy(7);
         check(copy, 1973, 1, 9);
         
-        copy = test.monthOfYear().addCopy(-5);
+        copy = test.monthOfYear().addToCopy(-5);
         check(copy, 1972, 1, 9);
         
-        copy = test.monthOfYear().addCopy(-6);
+        copy = test.monthOfYear().addToCopy(-6);
         check(copy, 1971, 12, 9);
         
         test = new YearMonthDay(1972, 1, 31);
-        copy = test.monthOfYear().addCopy(1);
+        copy = test.monthOfYear().addToCopy(1);
         check(copy, 1972, 2, 29);
         
-        copy = test.monthOfYear().addCopy(2);
+        copy = test.monthOfYear().addToCopy(2);
         check(copy, 1972, 3, 31);
         
-        copy = test.monthOfYear().addCopy(3);
+        copy = test.monthOfYear().addToCopy(3);
         check(copy, 1972, 4, 30);
         
         test = new YearMonthDay(1971, 1, 31);
-        copy = test.monthOfYear().addCopy(1);
+        copy = test.monthOfYear().addToCopy(1);
         check(copy, 1971, 2, 28);
     }
 
-    public void testPropertyAddInFieldMonth() {
+    public void testPropertyAddWrapFieldMonth() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.monthOfYear().addInFieldCopy(4);
+        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);
         check(test, 1972, 6, 9);
         check(copy, 1972, 10, 9);
         
-        copy = test.monthOfYear().addInFieldCopy(8);
+        copy = test.monthOfYear().addWrapFieldToCopy(8);
         check(copy, 1972, 2, 9);
         
-        copy = test.monthOfYear().addInFieldCopy(-8);
+        copy = test.monthOfYear().addWrapFieldToCopy(-8);
         check(copy, 1972, 10, 9);
         
         test = new YearMonthDay(1972, 1, 31);
-        copy = test.monthOfYear().addInFieldCopy(1);
+        copy = test.monthOfYear().addWrapFieldToCopy(1);
         check(copy, 1972, 2, 29);
         
-        copy = test.monthOfYear().addInFieldCopy(2);
+        copy = test.monthOfYear().addWrapFieldToCopy(2);
         check(copy, 1972, 3, 31);
         
-        copy = test.monthOfYear().addInFieldCopy(3);
+        copy = test.monthOfYear().addWrapFieldToCopy(3);
         check(copy, 1972, 4, 30);
         
         test = new YearMonthDay(1971, 1, 31);
-        copy = test.monthOfYear().addInFieldCopy(1);
+        copy = test.monthOfYear().addWrapFieldToCopy(1);
         check(copy, 1971, 2, 28);
     }
 
@@ -894,64 +894,64 @@ public void testPropertyGetMaxMinValuesDay() {
 
     public void testPropertyAddDay() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.dayOfMonth().addCopy(9);
+        YearMonthDay copy = test.dayOfMonth().addToCopy(9);
         check(test, 1972, 6, 9);
         check(copy, 1972, 6, 18);
         
-        copy = test.dayOfMonth().addCopy(21);
+        copy = test.dayOfMonth().addToCopy(21);
         check(copy, 1972, 6, 30);
         
-        copy = test.dayOfMonth().addCopy(22);
+        copy = test.dayOfMonth().addToCopy(22);
         check(copy, 1972, 7, 1);
         
-        copy = test.dayOfMonth().addCopy(22 + 30);
+        copy = test.dayOfMonth().addToCopy(22 + 30);
         check(copy, 1972, 7, 31);
         
-        copy = test.dayOfMonth().addCopy(22 + 31);
+        copy = test.dayOfMonth().addToCopy(22 + 31);
         check(copy, 1972, 8, 1);
 
-        copy = test.dayOfMonth().addCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
         check(copy, 1972, 12, 31);
         
-        copy = test.dayOfMonth().addCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+        copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
         check(copy, 1973, 1, 1);
         
-        copy = test.dayOfMonth().addCopy(-8);
+        copy = test.dayOfMonth().addToCopy(-8);
         check(copy, 1972, 6, 1);
         
-        copy = test.dayOfMonth().addCopy(-9);
+        copy = test.dayOfMonth().addToCopy(-9);
         check(copy, 1972, 5, 31);
         
-        copy = test.dayOfMonth().addCopy(-8 - 31 - 30 - 31 - 29 - 31);
+        copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
         check(copy, 1972, 1, 1);
         
-        copy = test.dayOfMonth().addCopy(-9 - 31 - 30 - 31 - 29 - 31);
+        copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
         check(copy, 1971, 12, 31);
     }
 
-    public void testPropertyAddInFieldDay() {
+    public void testPropertyAddWrapFieldDay() {
         YearMonthDay test = new YearMonthDay(1972, 6, 9);
-        YearMonthDay copy = test.dayOfMonth().addInFieldCopy(21);
+        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);
         check(test, 1972, 6, 9);
         check(copy, 1972, 6, 30);
         
-        copy = test.dayOfMonth().addInFieldCopy(22);
+        copy = test.dayOfMonth().addWrapFieldToCopy(22);
         check(copy, 1972, 6, 1);
         
-        copy = test.dayOfMonth().addInFieldCopy(-12);
+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);
         check(copy, 1972, 6, 27);
         
         test = new YearMonthDay(1972, 7, 9);
-        copy = test.dayOfMonth().addInFieldCopy(21);
+        copy = test.dayOfMonth().addWrapFieldToCopy(21);
         check(copy, 1972, 7, 30);
     
-        copy = test.dayOfMonth().addInFieldCopy(22);
+        copy = test.dayOfMonth().addWrapFieldToCopy(22);
         check(copy, 1972, 7, 31);
     
-        copy = test.dayOfMonth().addInFieldCopy(23);
+        copy = test.dayOfMonth().addWrapFieldToCopy(23);
         check(copy, 1972, 7, 1);
     
-        copy = test.dayOfMonth().addInFieldCopy(-12);
+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);
         check(copy, 1972, 7, 28);
     }
 

From 339cf9a991c3e20717e771b7306ecf3d5f384bbe Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jul 2004 02:40:13 +0000
Subject: [PATCH 0116/1934] Fixed javadoc link.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@266 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/field/DecoratedDurationField.java  | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
index d4cc1f888..c6773bb98 100644
--- a/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
@@ -56,13 +56,13 @@
 import org.joda.time.DurationField;
 
 /**
- * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},
+ * <code>DecoratedDurationField</code> extends {@link BaseDurationField},
  * implementing only the minimum required set of methods. These implemented
  * methods delegate to a wrapped field.
  * <p>
  * This design allows new DurationField types to be defined that piggyback on
  * top of another, inheriting all the safe method implementations from
- * AbstractDurationField. Should any method require pure delegation to the
+ * BaseDurationField. Should any method require pure delegation to the
  * wrapped field, simply override and use the provided getWrappedField method.
  * <p>
  * DecoratedDurationField is thread-safe and immutable, and its subclasses must

From ef855fa307361e9c67c834982e00c790f6701063 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jul 2004 02:48:59 +0000
Subject: [PATCH 0117/1934] Fixed javadoc comment.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@267 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java | 2 +-
 JodaTime/src/java/org/joda/time/field/BaseDurationField.java | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
index 38c527b90..7a009b1c8 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
@@ -65,7 +65,7 @@
  * implementations. 
  * <p>
  * This class should generally not be used directly by API users. The
- * DateTimeField interface should be used when different kinds of DateTimeField
+ * DateTimeField class should be used when different kinds of DateTimeField
  * objects are to be referenced.
  * <p>
  * BaseDateTimeField is thread-safe and immutable, and its subclasses must
diff --git a/JodaTime/src/java/org/joda/time/field/BaseDurationField.java b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
index 1299bed16..00a0d2ba2 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
@@ -57,14 +57,14 @@
 import org.joda.time.DurationField;
 
 /**
- * AbstractDurationField provides the common behaviour for DurationField
+ * BaseDurationField provides the common behaviour for DurationField
  * implementations.
  * <p>
  * This class should generally not be used directly by API users. The
  * DurationField interface should be used when different kinds of DurationField
  * objects are to be referenced.
  * <p>
- * AbstractDurationField is thread-safe and immutable, and its subclasses must
+ * BaseDurationField is thread-safe and immutable, and its subclasses must
  * be as well.
  *
  * @author Brian S O'Neill

From d96806215acd52cce68a4974533703ca9311fcb3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jul 2004 02:48:59 +0000
Subject: [PATCH 0118/1934] Fixed javadoc comment.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@268 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field/BaseDurationField.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/field/BaseDurationField.java b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
index 00a0d2ba2..e07947a4e 100644
--- a/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java
@@ -61,7 +61,7 @@
  * implementations.
  * <p>
  * This class should generally not be used directly by API users. The
- * DurationField interface should be used when different kinds of DurationField
+ * DurationField class should be used when different kinds of DurationField
  * objects are to be referenced.
  * <p>
  * BaseDurationField is thread-safe and immutable, and its subclasses must

From d02bfa0d15997cf0189d747ff9ae734fa1247f9c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jul 2004 04:11:00 +0000
Subject: [PATCH 0119/1934] Eliminate production of useless anonymous inner
 class by javac.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@269 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DurationType.java | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 1626064c2..74ae45848 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -538,6 +538,9 @@ public int hashCode() {
     private static final class MillisType extends DurationType {
         static final long serialVersionUID = -4314867016852780422L;
 
+        public MillisType() {
+        }
+
         public boolean isPrecise() {
             return true;
         }

From d577ec4753bfd809e277b2ad5807404b91692d6a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 10 Jul 2004 10:35:46 +0000
Subject: [PATCH 0120/1934] More tests

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@270 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/TestDateTime_Properties.java    | 484 +++++++++++++++++-
 1 file changed, 458 insertions(+), 26 deletions(-)

diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
index 9392be372..ff2037563 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -64,6 +64,10 @@
  * @author Stephen Colebourne
  */
 public class TestDateTime_Properties extends TestCase {
+    // Summer time:
+    // 1968-02-18 to 1971-10-31 - +01:00 all year round!
+    // 1972  UK  Mar 19 - Oct 29
+    // 1973  UK  Mar 18 - Oct 28
 
     private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
@@ -209,16 +213,23 @@ public void testPropertyGetYear() {
         assertEquals(null, test.year().getRangeDurationField());
         assertEquals(9, test.year().getMaximumTextLength(null));
         assertEquals(9, test.year().getMaximumShortTextLength(null));
-    }
-
-    public void testPropertyGetMaxMinValuesYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         assertEquals(-292275054, test.year().getMinimumValue());
         assertEquals(-292275054, test.year().getMinimumValueOverall());
         assertEquals(292277023, test.year().getMaximumValue());
         assertEquals(292277023, test.year().getMaximumValueOverall());
     }
 
+    public void testPropertyLeapYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(true, test.year().isLeap());
+        assertEquals(1, test.year().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());
+        test = new DateTime(1971, 6, 9, 0, 0, 0, 0);
+        assertEquals(false, test.year().isLeap());
+        assertEquals(0, test.year().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());
+    }
+
     public void testPropertyAddYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.year().addToCopy(9);
@@ -291,7 +302,7 @@ public void testPropertyCompareToYear() {
     }
 
     //-----------------------------------------------------------------------
-    public void testPropertyGetMonth() {
+    public void testPropertyGetMonthOfYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
         assertEquals("monthOfYear", test.monthOfYear().getName());
@@ -314,17 +325,35 @@ public void testPropertyGetMonth() {
         assertEquals(1, test.monthOfYear().getMinimumValueOverall());
         assertEquals(12, test.monthOfYear().getMaximumValue());
         assertEquals(12, test.monthOfYear().getMaximumValueOverall());
-    }
-
-    public void testPropertyGetMaxMinValuesMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         assertEquals(1, test.monthOfYear().getMinimumValue());
         assertEquals(1, test.monthOfYear().getMinimumValueOverall());
         assertEquals(12, test.monthOfYear().getMaximumValue());
         assertEquals(12, test.monthOfYear().getMaximumValueOverall());
     }
 
-    public void testPropertyAddMonth() {
+    public void testPropertyLeapMonthOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(false, test.monthOfYear().isLeap());
+        assertEquals(0, test.monthOfYear().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
+        
+        test = new DateTime(1972, 2, 9, 0, 0, 0, 0);
+        assertEquals(true, test.monthOfYear().isLeap());
+        assertEquals(1, test.monthOfYear().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
+        
+        test = new DateTime(1971, 6, 9, 0, 0, 0, 0);
+        assertEquals(false, test.monthOfYear().isLeap());
+        assertEquals(0, test.monthOfYear().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
+        
+        test = new DateTime(1971, 2, 9, 0, 0, 0, 0);
+        assertEquals(false, test.monthOfYear().isLeap());
+        assertEquals(0, test.monthOfYear().getLeapAmount());
+        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
+    }
+
+    public void testPropertyAddMonthOfYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().addToCopy(6);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -345,17 +374,17 @@ public void testPropertyAddMonth() {
         assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addToCopy(2);
-        assertEquals("1972-03-31T00:00:00.000Z", copy.toString());
+        assertEquals("1972-03-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.monthOfYear().addToCopy(3);
         assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
         
         test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addToCopy(1);
-        assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
+        assertEquals("1971-02-28T00:00:00.000+01:00", copy.toString());
     }
 
-    public void testPropertyAddWrapFieldMonth() {
+    public void testPropertyAddWrapFieldMonthOfYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -378,13 +407,13 @@ public void testPropertyAddWrapFieldMonth() {
         copy = test.monthOfYear().addWrapFieldToCopy(3);
         assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(1973, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addWrapFieldToCopy(1);
-        assertEquals("1971-01-31T00:00:00.000Z", test.toString());
-        assertEquals("1971-02-28T00:00:00.000Z", copy.toString());
+        assertEquals("1973-01-31T00:00:00.000Z", test.toString());
+        assertEquals("1973-02-28T00:00:00.000Z", copy.toString());
     }
 
-    public void testPropertySetMonth() {
+    public void testPropertySetMonthOfYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().setCopy(12);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -404,7 +433,7 @@ public void testPropertySetMonth() {
         } catch (IllegalArgumentException ex) {}
     }
 
-    public void testPropertySetTextMonth() {
+    public void testPropertySetTextMonthOfYear() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().setCopy("12");
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -419,7 +448,7 @@ public void testPropertySetTextMonth() {
         assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
     }
 
-    public void testPropertyCompareToMonth() {
+    public void testPropertyCompareToMonthOfYear() {
         DateTime test1 = new DateTime(TEST_TIME1);
         DateTime test2 = new DateTime(TEST_TIME2);
         assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);
@@ -442,7 +471,7 @@ public void testPropertyCompareToMonth() {
     }
 
     //-----------------------------------------------------------------------
-    public void testPropertyGetDay() {
+    public void testPropertyGetDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
         assertEquals("dayOfMonth", test.dayOfMonth().getName());
@@ -462,9 +491,12 @@ public void testPropertyGetDay() {
         assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
         assertEquals(30, test.dayOfMonth().getMaximumValue());
         assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
+        assertEquals(false, test.dayOfMonth().isLeap());
+        assertEquals(0, test.dayOfMonth().getLeapAmount());
+        assertEquals(null, test.dayOfMonth().getLeapDurationField());
     }
 
-    public void testPropertyGetMaxMinValuesDay() {
+    public void testPropertyGetMaxMinValuesDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         assertEquals(1, test.dayOfMonth().getMinimumValue());
         assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
@@ -478,7 +510,7 @@ public void testPropertyGetMaxMinValuesDay() {
         assertEquals(28, test.dayOfMonth().getMaximumValue());
     }
 
-    public void testPropertyAddDay() {
+    public void testPropertyAddDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().addToCopy(9);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -515,7 +547,7 @@ public void testPropertyAddDay() {
         assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
     }
 
-    public void testPropertyAddWrapFieldDay() {
+    public void testPropertyAddWrapFieldDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -541,7 +573,7 @@ public void testPropertyAddWrapFieldDay() {
         assertEquals("1972-07-28T00:00:00.000+01:00", copy.toString());
     }
 
-    public void testPropertySetDay() {
+    public void testPropertySetDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().setCopy(12);
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
@@ -557,14 +589,14 @@ public void testPropertySetDay() {
         } catch (IllegalArgumentException ex) {}
     }
 
-    public void testPropertySetTextDay() {
+    public void testPropertySetTextDayOfMonth() {
         DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().setCopy("12");
         assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
     }
 
-    public void testPropertyCompareToDay() {
+    public void testPropertyCompareToDayOfMonth() {
         DateTime test1 = new DateTime(TEST_TIME1);
         DateTime test2 = new DateTime(TEST_TIME2);
         assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);
@@ -586,4 +618,404 @@ public void testPropertyCompareToDay() {
         } catch (IllegalArgumentException ex) {}
     }
 
+    //-----------------------------------------------------------------------
+    public void testPropertyGetDayOfYear() {
+        // 31+29+31+30+31+9 = 161
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());
+        assertEquals("dayOfYear", test.dayOfYear().getName());
+        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());
+        assertSame(test, test.dayOfYear().getReadableInstant());
+        assertSame(test, test.dayOfYear().getDateTime());
+        assertEquals(161, test.dayOfYear().get());
+        assertEquals("161", test.dayOfYear().getAsText());
+        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));
+        assertEquals("161", test.dayOfYear().getAsShortText());
+        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());
+        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());
+        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));
+        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));
+        assertEquals(false, test.dayOfYear().isLeap());
+        assertEquals(0, test.dayOfYear().getLeapAmount());
+        assertEquals(null, test.dayOfYear().getLeapDurationField());
+    }
+
+    public void testPropertyGetMaxMinValuesDayOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(1, test.dayOfYear().getMinimumValue());
+        assertEquals(1, test.dayOfYear().getMinimumValueOverall());
+        assertEquals(366, test.dayOfYear().getMaximumValue());
+        assertEquals(366, test.dayOfYear().getMaximumValueOverall());
+        test = new DateTime(1970, 6, 9, 0, 0, 0, 0);
+        assertEquals(365, test.dayOfYear().getMaximumValue());
+        assertEquals(366, test.dayOfYear().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddDayOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfYear().addToCopy(9);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-18T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(21);
+        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(22);
+        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(-8);
+        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(-9);
+        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyAddWrapFieldDayOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfYear().addWrapFieldToCopy(21);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(22);
+        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(-12);
+        assertEquals("1972-05-28T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(205);
+        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(206);
+        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(-160);
+        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfYear().addWrapFieldToCopy(-161);
+        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertySetDayOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfYear().setCopy(12);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-01-12T00:00:00.000Z", copy.toString());
+        
+        try {
+            test.dayOfYear().setCopy(367);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.dayOfYear().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextDayOfYear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfYear().setCopy("12");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-01-12T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyCompareToDayOfYear() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfYear().compareTo(test2) < 0);
+        assertEquals(true, test2.dayOfYear().compareTo(test1) > 0);
+        assertEquals(true, test1.dayOfYear().compareTo(test1) == 0);
+        try {
+            test1.dayOfYear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfYear().compareTo(dt2) < 0);
+        assertEquals(true, test2.dayOfYear().compareTo(dt1) > 0);
+        assertEquals(true, test1.dayOfYear().compareTo(dt1) == 0);
+        try {
+            test1.dayOfYear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetWeekOfWeekyear() {
+        // 1970-01-01 = Thu
+        // 1970-12-31 = Thu (+364 days)
+        // 1971-12-30 = Thu (+364 days)
+        // 1972-01-03 = Mon             W1
+        // 1972-01-31 = Mon (+28 days)  W5
+        // 1972-02-28 = Mon (+28 days)  W9
+        // 1972-03-27 = Mon (+28 days)  W13
+        // 1972-04-24 = Mon (+28 days)  W17
+        // 1972-05-23 = Mon (+28 days)  W21
+        // 1972-06-05 = Mon (+14 days)  W23
+        // 1972-06-09 = Fri
+        // 1972-12-25 = Mon             W52
+        // 1973-01-01 = Mon             W1
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());
+        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());
+        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());
+        assertSame(test, test.weekOfWeekyear().getReadableInstant());
+        assertSame(test, test.weekOfWeekyear().getDateTime());
+        assertEquals(23, test.weekOfWeekyear().get());
+        assertEquals("23", test.weekOfWeekyear().getAsText());
+        assertEquals("23", test.weekOfWeekyear().getAsText(Locale.FRENCH));
+        assertEquals("23", test.weekOfWeekyear().getAsShortText());
+        assertEquals("23", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());
+        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());
+        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));
+        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));
+        assertEquals(false, test.weekOfWeekyear().isLeap());
+        assertEquals(0, test.weekOfWeekyear().getLeapAmount());
+        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());
+    }
+
+    public void testPropertyGetMaxMinValuesWeekOfWeekyear() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertEquals(1, test.weekOfWeekyear().getMinimumValue());
+        assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall());
+        assertEquals(52, test.weekOfWeekyear().getMaximumValue());
+        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());
+        test = new DateTime(1970, 6, 9, 0, 0, 0, 0);
+        assertEquals(53, test.weekOfWeekyear().getMaximumValue());
+        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());
+    }
+
+    public void testPropertyAddWeekOfWeekyear() {
+        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime copy = test.weekOfWeekyear().addToCopy(1);
+        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.weekOfWeekyear().addToCopy(29);
+        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+        
+        copy = test.weekOfWeekyear().addToCopy(30);
+        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.weekOfWeekyear().addToCopy(-22);
+        assertEquals("1972-01-03T00:00:00.000Z", copy.toString());
+        
+        copy = test.weekOfWeekyear().addToCopy(-23);
+        assertEquals("1971-12-27T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyAddWrapFieldWeekOfWeekyear() {
+        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1);
+        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.weekOfWeekyear().addWrapFieldToCopy(29);
+        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+        
+        copy = test.weekOfWeekyear().addWrapFieldToCopy(30);
+        assertEquals("1972-01-03T00:00:00.000Z", copy.toString());
+        
+        copy = test.weekOfWeekyear().addWrapFieldToCopy(-23);
+        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertySetWeekOfWeekyear() {
+        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime copy = test.weekOfWeekyear().setCopy(4);
+        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-01-24T00:00:00.000Z", copy.toString());
+        
+        try {
+            test.weekOfWeekyear().setCopy(53);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.weekOfWeekyear().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextWeekOfWeekyear() {
+        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime copy = test.weekOfWeekyear().setCopy("4");
+        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-01-24T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyCompareToWeekOfWeekyear() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.weekOfWeekyear().compareTo(test2) < 0);
+        assertEquals(true, test2.weekOfWeekyear().compareTo(test1) > 0);
+        assertEquals(true, test1.weekOfWeekyear().compareTo(test1) == 0);
+        try {
+            test1.weekOfWeekyear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.weekOfWeekyear().compareTo(dt2) < 0);
+        assertEquals(true, test2.weekOfWeekyear().compareTo(dt1) > 0);
+        assertEquals(true, test1.weekOfWeekyear().compareTo(dt1) == 0);
+        try {
+            test1.weekOfWeekyear().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    //-----------------------------------------------------------------------
+    public void testPropertyGetDayOfWeek() {
+        // 1970-01-01 = Thu
+        // 1970-12-31 = Thu (+364 days)
+        // 1971-12-30 = Thu (+364 days)
+        // 1972-01-03 = Mon
+        // 1972-01-31 = Mon (+28 days)
+        // 1972-02-28 = Mon (+28 days)
+        // 1972-03-27 = Mon (+28 days)
+        // 1972-04-24 = Mon (+28 days)
+        // 1972-05-23 = Mon (+28 days)
+        // 1972-06-05 = Mon (+14 days)
+        // 1972-06-09 = Fri
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());
+        assertEquals("dayOfWeek", test.dayOfWeek().getName());
+        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());
+        assertSame(test, test.dayOfWeek().getReadableInstant());
+        assertSame(test, test.dayOfWeek().getDateTime());
+        assertEquals(5, test.dayOfWeek().get());
+        assertEquals("Friday", test.dayOfWeek().getAsText());
+        assertEquals("vendredi", test.dayOfWeek().getAsText(Locale.FRENCH));
+        assertEquals("Fri", test.dayOfWeek().getAsShortText());
+        assertEquals("ven.", test.dayOfWeek().getAsShortText(Locale.FRENCH));
+        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());
+        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());
+        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));
+        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));
+        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));
+        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));
+        assertEquals(1, test.dayOfWeek().getMinimumValue());
+        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());
+        assertEquals(7, test.dayOfWeek().getMaximumValue());
+        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());
+        assertEquals(false, test.dayOfWeek().isLeap());
+        assertEquals(0, test.dayOfWeek().getLeapAmount());
+        assertEquals(null, test.dayOfWeek().getLeapDurationField());
+    }
+
+    public void testPropertyAddDayOfWeek() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfWeek().addToCopy(1);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-10T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(21);
+        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(22);
+        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
+        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(-8);
+        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(-9);
+        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        
+        copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
+        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+    }
+
+    public void testPropertyAddWrapFieldDayOfWeek() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-10T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addWrapFieldToCopy(3);
+        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+        
+        copy = test.dayOfWeek().addWrapFieldToCopy(-12);
+        assertEquals("1972-06-11T00:00:00.000+01:00", copy.toString());
+        
+        test = new DateTime(1972, 6, 2, 0, 0, 0, 0);
+        copy = test.dayOfWeek().addWrapFieldToCopy(3);
+        assertEquals("1972-06-02T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-05-29T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertySetDayOfWeek() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfWeek().setCopy(4);
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-08T00:00:00.000+01:00", copy.toString());
+        
+        try {
+            test.dayOfWeek().setCopy(8);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            test.dayOfWeek().setCopy(0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    public void testPropertySetTextDayOfWeek() {
+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime copy = test.dayOfWeek().setCopy("4");
+        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("1972-06-08T00:00:00.000+01:00", copy.toString());
+        copy = test.dayOfWeek().setCopy("Mon");
+        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+        copy = test.dayOfWeek().setCopy("Tuesday");
+        assertEquals("1972-06-06T00:00:00.000+01:00", copy.toString());
+        copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH);
+        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+    }
+
+    public void testPropertyCompareToDayOfWeek() {
+        DateTime test1 = new DateTime(TEST_TIME1);
+        DateTime test2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfWeek().compareTo(test2) < 0);
+        assertEquals(true, test2.dayOfWeek().compareTo(test1) > 0);
+        assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0);
+        try {
+            test1.dayOfWeek().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        
+        DateTime dt1 = new DateTime(TEST_TIME1);
+        DateTime dt2 = new DateTime(TEST_TIME2);
+        assertEquals(true, test1.dayOfWeek().compareTo(dt2) < 0);
+        assertEquals(true, test2.dayOfWeek().compareTo(dt1) > 0);
+        assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0);
+        try {
+            test1.dayOfWeek().compareTo((ReadableInstant) null);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
 }

From 0516796ccff66a429bc86149096eb29807a84f3f Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 10 Jul 2004 10:58:21 +0000
Subject: [PATCH 0121/1934] Remove inaccurate javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@271 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTime.java | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index 14ca57b71..556fe1a34 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -486,8 +486,6 @@ public final DateTimeFieldProperty dayOfYear() {
 
     /**
      * Get the day of month property.
-     * <p>
-     * The values for day of month are defined in {@link DateTimeConstants}.
      * 
      * @return the day of month property
      */
@@ -497,8 +495,6 @@ public final DateTimeFieldProperty dayOfMonth() {
 
     /**
      * Get the day of week property.
-     * <p>
-     * The values for day of week are defined in {@link DateTimeConstants}.
      * 
      * @return the day of week property
      */

From 908174b05ca8032a7e474fccc51b95d71ada211d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jul 2004 15:46:32 +0000
Subject: [PATCH 0122/1934] Fixed comment typo.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@272 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
index 38f9d7ce9..229b2c128 100644
--- a/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
+++ b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
@@ -81,7 +81,7 @@
  * <p>
  * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for
  * proleptic julian. To override the default random number generator seed, pass
- * in a thrid argument which accepts a long signed integer.
+ * in a third argument which accepts a long signed integer.
  *
  * @author Brian S O'Neill
  */

From e75973001c589ceaa48c7d23ae394d7ed2a05178 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 11 Jul 2004 14:55:21 +0000
Subject: [PATCH 0123/1934] No longer needed

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@273 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/.cvsignore | 1 -
 1 file changed, 1 deletion(-)
 delete mode 100644 JodaTime/src/.cvsignore

diff --git a/JodaTime/src/.cvsignore b/JodaTime/src/.cvsignore
deleted file mode 100644
index 0883ff070..000000000
--- a/JodaTime/src/.cvsignore
+++ /dev/null
@@ -1 +0,0 @@
-tzdata

From c9fe9c8e37c2945ae45c0adf6a475f35c0e1e5dc Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 11 Jul 2004 21:01:52 +0000
Subject: [PATCH 0124/1934] Change to test in 2002-2004 where time zone is
 predictable

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@274 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/TestDateTime_Basics.java    |  90 +--
 .../joda/time/TestDateTime_Constructors.java  |  84 +--
 .../joda/time/TestDateTime_Properties.java    | 531 +++++++++---------
 .../org/joda/time/TestInstant_Basics.java     |  54 +-
 4 files changed, 410 insertions(+), 349 deletions(-)

diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
index 3575c959c..6f486d00e 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
@@ -75,26 +75,37 @@
  * @author Stephen Colebourne
  */
 public class TestDateTime_Basics extends TestCase {
+    // Test in 2002/03 as time zones are more well known
+    // (before the late 90's they were all over the place)
 
     private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
     
-    // 1970-06-09
+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365;
+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365 + 365;
+    
+    // 2002-06-09
     private long TEST_TIME_NOW =
-            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
             
-    // 1970-04-05
+    // 2002-04-05
     private long TEST_TIME1 =
-        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 12L * DateTimeConstants.MILLIS_PER_HOUR
-        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 12L * DateTimeConstants.MILLIS_PER_HOUR
+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
         
-    // 1971-05-06
+    // 2003-05-06
     private long TEST_TIME2 =
-        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 14L * DateTimeConstants.MILLIS_PER_HOUR
-        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
-        
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 14L * DateTimeConstants.MILLIS_PER_HOUR
+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+    
     private DateTimeZone zone = null;
     private Locale locale = null;
 
@@ -125,19 +136,26 @@ protected void tearDown() throws Exception {
         zone = null;
     }
 
+    //-----------------------------------------------------------------------
+    public void testTest() {
+        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());
+        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());
+        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testGet() {
         DateTime test = new DateTime();
         assertEquals(1, test.get(ISOChronology.getInstance().era()));
-        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));
-        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().year()));
+        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));
+        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().year()));
         assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));
         assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));
-        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));
-        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));
+        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));
+        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));
         assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));
         assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));
         assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));
@@ -164,15 +182,15 @@ public void testGetMethods() {
         assertEquals(TEST_TIME_NOW, test.getMillis());
         
         assertEquals(1, test.getEra());
-        assertEquals(19, test.getCenturyOfEra());
-        assertEquals(70, test.getYearOfCentury());
-        assertEquals(1970, test.getYearOfEra());
-        assertEquals(1970, test.getYear());
+        assertEquals(20, test.getCenturyOfEra());
+        assertEquals(2, test.getYearOfCentury());
+        assertEquals(2002, test.getYearOfEra());
+        assertEquals(2002, test.getYear());
         assertEquals(6, test.getMonthOfYear());
         assertEquals(9, test.getDayOfMonth());
-        assertEquals(1970, test.getWeekyear());
-        assertEquals(24, test.getWeekOfWeekyear());
-        assertEquals(2, test.getDayOfWeek());
+        assertEquals(2002, test.getWeekyear());
+        assertEquals(23, test.getWeekOfWeekyear());
+        assertEquals(7, test.getDayOfWeek());
         assertEquals(160, test.getDayOfYear());
         assertEquals(1, test.getHourOfDay());
         assertEquals(0, test.getMinuteOfHour());
@@ -336,25 +354,25 @@ public void testSerialization() throws Exception {
     //-----------------------------------------------------------------------
     public void testToString() {
         DateTime test = new DateTime(TEST_TIME_NOW);
-        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString());
+        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());
         
         test = new DateTime(TEST_TIME_NOW, PARIS);
-        assertEquals("1970-06-09T02:00:00.000+02:00", test.toString());
+        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());
     }
 
     public void testToString_String() {
         DateTime test = new DateTime(TEST_TIME_NOW);
-        assertEquals("1970 01", test.toString("yyyy HH"));
-        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null));
+        assertEquals("2002 01", test.toString("yyyy HH"));
+        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null));
     }
 
     public void testToString_String_String() {
         DateTime test = new DateTime(TEST_TIME_NOW);
-        assertEquals("Tue 9/6", test.toString("EEE d/M", Locale.ENGLISH));
-        assertEquals("mar. 9/6", test.toString("EEE d/M", Locale.FRENCH));
-        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));
-        assertEquals("Tue 9/6", test.toString("EEE d/M", null));
-        assertEquals("1970-06-09T01:00:00.000+01:00", test.toString(null, null));
+        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));
+        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));
+        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));
+        assertEquals("Sun 9/6", test.toString("EEE d/M", null));
+        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));
     }
 
     //-----------------------------------------------------------------------
@@ -608,12 +626,12 @@ public void testWithZone_DateTimeZone() {
     public void testWithZoneRetainFields_DateTimeZone() {
         DateTime test = new DateTime(TEST_TIME1);
         DateTime result = test.withZoneRetainFields(PARIS);
-        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());
+        assertEquals(test.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());
         assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
         
         test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));
         result = test.withZoneRetainFields(null);
-        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());
+        assertEquals(test.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());
         assertEquals(GregorianChronology.getInstance(), result.getChronology());
     }
     
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java b/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
index 66af2e17d..21065ffab 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
@@ -70,25 +70,36 @@
  * @author Stephen Colebourne
  */
 public class TestDateTime_Constructors extends TestCase {
+    // Test in 2002/03 as time zones are more well known
+    // (before the late 90's they were all over the place)
 
     private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
     
-    // 1970-06-09
+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365;
+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365 + 365;
+    
+    // 2002-06-09
     private long TEST_TIME_NOW =
-            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
             
-    // 1970-04-05
+    // 2002-04-05
     private long TEST_TIME1 =
-        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 12L * DateTimeConstants.MILLIS_PER_HOUR
-        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 12L * DateTimeConstants.MILLIS_PER_HOUR
+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
         
-    // 1971-05-06
+    // 2003-05-06
     private long TEST_TIME2 =
-        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 14L * DateTimeConstants.MILLIS_PER_HOUR
-        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 14L * DateTimeConstants.MILLIS_PER_HOUR
+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
         
     private DateTimeZone zone = null;
     private Locale locale = null;
@@ -120,6 +131,13 @@ protected void tearDown() throws Exception {
         zone = null;
     }
 
+    //-----------------------------------------------------------------------
+    public void testTest() {
+        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());
+        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());
+        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Test constructor ()
@@ -412,7 +430,7 @@ public void testConstructor_badconverterObject_Chronology() throws Throwable {
      * Test constructor (int, int, int)
      */
     public void testConstructor_int_int_int_int_int_int_int() throws Throwable {
-        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0);  // +01:00
+        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00
         assertEquals(ISOChronology.getInstance(), test.getChronology());
         assertEquals(LONDON, test.getZone());
         assertEquals(TEST_TIME_NOW, test.getMillis());
@@ -425,24 +443,24 @@ public void testConstructor_int_int_int_int_int_int_int() throws Throwable {
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 0, 9, 0, 0, 0, 0);
+            new DateTime(2002, 0, 9, 0, 0, 0, 0);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 13, 9, 0, 0, 0, 0);
+            new DateTime(2002, 13, 9, 0, 0, 0, 0);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 0, 0, 0, 0, 0);
+            new DateTime(2002, 6, 0, 0, 0, 0, 0);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 31, 0, 0, 0, 0);
+            new DateTime(2002, 6, 31, 0, 0, 0, 0);
             fail();
         } catch (IllegalArgumentException ex) {}
-        new DateTime(1970, 7, 31, 0, 0, 0, 0);
+        new DateTime(2002, 7, 31, 0, 0, 0, 0);
         try {
-            new DateTime(1970, 7, 32, 0, 0, 0, 0);
+            new DateTime(2002, 7, 32, 0, 0, 0, 0);
             fail();
         } catch (IllegalArgumentException ex) {}
     }
@@ -451,7 +469,7 @@ public void testConstructor_int_int_int_int_int_int_int() throws Throwable {
      * Test constructor (int, int, int, DateTimeZone)
      */
     public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {
-        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, PARIS);  // +01:00
+        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00
         assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
         assertEquals(TEST_TIME_NOW, test.getMillis());
         try {
@@ -463,24 +481,24 @@ public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Th
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 0, 9, 0, 0, 0, 0, PARIS);
+            new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 13, 9, 0, 0, 0, 0, PARIS);
+            new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 0, 0, 0, 0, 0, PARIS);
+            new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 31, 0, 0, 0, 0, PARIS);
+            new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);
             fail();
         } catch (IllegalArgumentException ex) {}
-        new DateTime(1970, 7, 31, 0, 0, 0, 0, PARIS);
+        new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);
         try {
-            new DateTime(1970, 7, 32, 0, 0, 0, 0, PARIS);
+            new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);
             fail();
         } catch (IllegalArgumentException ex) {}
     }
@@ -489,7 +507,7 @@ public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Th
      * Test constructor (int, int, int, DateTimeZone=null)
      */
     public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {
-        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00
+        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00
         assertEquals(ISOChronology.getInstance(), test.getChronology());
         assertEquals(TEST_TIME_NOW, test.getMillis());
     }
@@ -498,7 +516,7 @@ public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throw
      * Test constructor (int, int, int, Chronology)
      */
     public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {
-        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00
+        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00
         assertEquals(GregorianChronology.getInstance(), test.getChronology());
         assertEquals(TEST_TIME_NOW, test.getMillis());
         try {
@@ -510,24 +528,24 @@ public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Thro
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
+            new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());
+            new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
-            new DateTime(1970, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
+            new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
             fail();
         } catch (IllegalArgumentException ex) {}
-        new DateTime(1970, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
+        new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());
         try {
-            new DateTime(1970, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());
+            new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());
             fail();
         } catch (IllegalArgumentException ex) {}
     }
@@ -536,7 +554,7 @@ public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Thro
      * Test constructor (int, int, int, Chronology=null)
      */
     public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {
-        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00
+        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00
         assertEquals(ISOChronology.getInstance(), test.getChronology());
         assertEquals(TEST_TIME_NOW, test.getMillis());
     }
diff --git a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
index ff2037563..7ce77bb3f 100644
--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java
@@ -64,29 +64,40 @@
  * @author Stephen Colebourne
  */
 public class TestDateTime_Properties extends TestCase {
-    // Summer time:
-    // 1968-02-18 to 1971-10-31 - +01:00 all year round!
-    // 1972  UK  Mar 19 - Oct 29
-    // 1973  UK  Mar 18 - Oct 28
+//    // Summer time:
+//    // 1968-02-18 to 1971-10-31 - +01:00 all year round!
+//    // 1972  UK  Mar 19 - Oct 29
+//    // 1973  UK  Mar 18 - Oct 28
+    // Test in 2002/03 as time zones are more well known
+    // (before the late 90's they were all over the place)
 
     private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
     
-    // 1970-06-09
+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365;
+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365 + 365;
+    
+    // 2002-06-09
     private long TEST_TIME_NOW =
-            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
             
-    // 1970-04-05
+    // 2002-04-05 Fri
     private long TEST_TIME1 =
-        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 12L * DateTimeConstants.MILLIS_PER_HOUR
-        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 12L * DateTimeConstants.MILLIS_PER_HOUR
+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
         
-    // 1971-05-06
+    // 2003-05-06 Tue
     private long TEST_TIME2 =
-        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 14L * DateTimeConstants.MILLIS_PER_HOUR
-        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 14L * DateTimeConstants.MILLIS_PER_HOUR
+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
         
     private DateTimeZone zone = null;
     private Locale locale = null;
@@ -118,9 +129,16 @@ protected void tearDown() throws Exception {
         zone = null;
     }
 
+    //-----------------------------------------------------------------------
+    public void testTest() {
+        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());
+        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());
+        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testPropertyGetEra() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().era(), test.era().getField());
         assertEquals("era", test.era().getName());
         assertEquals("Property[era]", test.era().toString());
@@ -141,17 +159,17 @@ public void testPropertyGetEra() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetYearOfEra() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());
         assertEquals("yearOfEra", test.yearOfEra().getName());
         assertEquals("Property[yearOfEra]", test.yearOfEra().toString());
         assertSame(test, test.yearOfEra().getReadableInstant());
         assertSame(test, test.yearOfEra().getDateTime());
-        assertEquals(1972, test.yearOfEra().get());
-        assertEquals("1972", test.yearOfEra().getAsText());
-        assertEquals("1972", test.yearOfEra().getAsText(Locale.FRENCH));
-        assertEquals("1972", test.yearOfEra().getAsShortText());
-        assertEquals("1972", test.yearOfEra().getAsShortText(Locale.FRENCH));
+        assertEquals(2004, test.yearOfEra().get());
+        assertEquals("2004", test.yearOfEra().getAsText());
+        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));
+        assertEquals("2004", test.yearOfEra().getAsShortText());
+        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
         assertEquals(null, test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
@@ -160,17 +178,17 @@ public void testPropertyGetYearOfEra() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetCenturyOfEra() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());
         assertEquals("centuryOfEra", test.centuryOfEra().getName());
         assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());
         assertSame(test, test.centuryOfEra().getReadableInstant());
         assertSame(test, test.centuryOfEra().getDateTime());
-        assertEquals(19, test.centuryOfEra().get());
-        assertEquals("19", test.centuryOfEra().getAsText());
-        assertEquals("19", test.centuryOfEra().getAsText(Locale.FRENCH));
-        assertEquals("19", test.centuryOfEra().getAsShortText());
-        assertEquals("19", test.centuryOfEra().getAsShortText(Locale.FRENCH));
+        assertEquals(20, test.centuryOfEra().get());
+        assertEquals("20", test.centuryOfEra().getAsText());
+        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));
+        assertEquals("20", test.centuryOfEra().getAsShortText());
+        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
         assertEquals(null, test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
@@ -179,17 +197,17 @@ public void testPropertyGetCenturyOfEra() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetYearOfCentury() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());
         assertEquals("yearOfCentury", test.yearOfCentury().getName());
         assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());
         assertSame(test, test.yearOfCentury().getReadableInstant());
         assertSame(test, test.yearOfCentury().getDateTime());
-        assertEquals(72, test.yearOfCentury().get());
-        assertEquals("72", test.yearOfCentury().getAsText());
-        assertEquals("72", test.yearOfCentury().getAsText(Locale.FRENCH));
-        assertEquals("72", test.yearOfCentury().getAsShortText());
-        assertEquals("72", test.yearOfCentury().getAsShortText(Locale.FRENCH));
+        assertEquals(4, test.yearOfCentury().get());
+        assertEquals("4", test.yearOfCentury().getAsText());
+        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));
+        assertEquals("4", test.yearOfCentury().getAsShortText());
+        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());
         assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());
         assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));
@@ -198,17 +216,17 @@ public void testPropertyGetYearOfCentury() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().year(), test.year().getField());
         assertEquals("year", test.year().getName());
         assertEquals("Property[year]", test.year().toString());
         assertSame(test, test.year().getReadableInstant());
         assertSame(test, test.year().getDateTime());
-        assertEquals(1972, test.year().get());
-        assertEquals("1972", test.year().getAsText());
-        assertEquals("1972", test.year().getAsText(Locale.FRENCH));
-        assertEquals("1972", test.year().getAsShortText());
-        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));
+        assertEquals(2004, test.year().get());
+        assertEquals("2004", test.year().getAsText());
+        assertEquals("2004", test.year().getAsText(Locale.FRENCH));
+        assertEquals("2004", test.year().getAsShortText());
+        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.year().getDurationField());
         assertEquals(null, test.year().getRangeDurationField());
         assertEquals(9, test.year().getMaximumTextLength(null));
@@ -220,72 +238,72 @@ public void testPropertyGetYear() {
     }
 
     public void testPropertyLeapYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertEquals(true, test.year().isLeap());
         assertEquals(1, test.year().getLeapAmount());
         assertEquals(test.getChronology().days(), test.year().getLeapDurationField());
-        test = new DateTime(1971, 6, 9, 0, 0, 0, 0);
+        test = new DateTime(2003, 6, 9, 0, 0, 0, 0);
         assertEquals(false, test.year().isLeap());
         assertEquals(0, test.year().getLeapAmount());
         assertEquals(test.getChronology().days(), test.year().getLeapDurationField());
     }
 
     public void testPropertyAddYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.year().addToCopy(9);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1981-06-09T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());
         
         copy = test.year().addToCopy(0);
-        assertEquals("1972-06-09T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", copy.toString());
         
-        copy = test.year().addToCopy(292277023 - 1972);
+        copy = test.year().addToCopy(292277023 - 2004);
         assertEquals(292277023, copy.getYear());
         
         try {
-            test.year().addToCopy(292277023 - 1972 + 1);
+            test.year().addToCopy(292277023 - 2004 + 1);
             fail();
         } catch (IllegalArgumentException ex) {}
         
-        copy = test.year().addToCopy(-1972);
+        copy = test.year().addToCopy(-2004);
         assertEquals(0, copy.getYear());
         
-        copy = test.year().addToCopy(-1973);
+        copy = test.year().addToCopy(-2005);
         assertEquals(-1, copy.getYear());
         
         try {
-            test.year().addToCopy(-292275054 - 1972 - 1);
+            test.year().addToCopy(-292275054 - 2004 - 1);
             fail();
         } catch (IllegalArgumentException ex) {}
     }
 
     public void testPropertyAddWrapFieldYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.year().addWrapFieldToCopy(9);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1981-06-09T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());
         
         copy = test.year().addWrapFieldToCopy(0);
-        assertEquals(1972, copy.getYear());
+        assertEquals(2004, copy.getYear());
         
-        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);
+        copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);
         assertEquals(-292275054, copy.getYear());
         
-        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);
+        copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1);
         assertEquals(292277023, copy.getYear());
     }
 
     public void testPropertySetYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.year().setCopy(1960);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());
     }
 
     public void testPropertySetTextYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.year().setCopy("1960");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
         assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());
     }
 
@@ -303,7 +321,7 @@ public void testPropertyCompareToYear() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());
         assertEquals("monthOfYear", test.monthOfYear().getName());
         assertEquals("Property[monthOfYear]", test.monthOfYear().toString());
@@ -318,7 +336,7 @@ public void testPropertyGetMonthOfYear() {
         assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
         assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
         assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
-        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);
         assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
         assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));
         assertEquals(1, test.monthOfYear().getMinimumValue());
@@ -332,96 +350,96 @@ public void testPropertyGetMonthOfYear() {
     }
 
     public void testPropertyLeapMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertEquals(false, test.monthOfYear().isLeap());
         assertEquals(0, test.monthOfYear().getLeapAmount());
         assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
         
-        test = new DateTime(1972, 2, 9, 0, 0, 0, 0);
+        test = new DateTime(2004, 2, 9, 0, 0, 0, 0);
         assertEquals(true, test.monthOfYear().isLeap());
         assertEquals(1, test.monthOfYear().getLeapAmount());
         assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
         
-        test = new DateTime(1971, 6, 9, 0, 0, 0, 0);
+        test = new DateTime(2003, 6, 9, 0, 0, 0, 0);
         assertEquals(false, test.monthOfYear().isLeap());
         assertEquals(0, test.monthOfYear().getLeapAmount());
         assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
         
-        test = new DateTime(1971, 2, 9, 0, 0, 0, 0);
+        test = new DateTime(2003, 2, 9, 0, 0, 0, 0);
         assertEquals(false, test.monthOfYear().isLeap());
         assertEquals(0, test.monthOfYear().getLeapAmount());
         assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());
     }
 
     public void testPropertyAddMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().addToCopy(6);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addToCopy(7);
-        assertEquals("1973-01-09T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addToCopy(-5);
-        assertEquals("1972-01-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addToCopy(-6);
-        assertEquals("1971-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-09T00:00:00.000Z", copy.toString());
         
-        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(2004, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addToCopy(1);
-        assertEquals("1972-01-31T00:00:00.000Z", test.toString());
-        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-31T00:00:00.000Z", test.toString());
+        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addToCopy(2);
-        assertEquals("1972-03-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.monthOfYear().addToCopy(3);
-        assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1971, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(2003, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addToCopy(1);
-        assertEquals("1971-02-28T00:00:00.000+01:00", copy.toString());
+        assertEquals("2003-02-28T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyAddWrapFieldMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());
         
         copy = test.monthOfYear().addWrapFieldToCopy(8);
-        assertEquals("1972-02-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-02-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addWrapFieldToCopy(-8);
-        assertEquals("1972-10-09T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(2004, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addWrapFieldToCopy(1);
-        assertEquals("1972-01-31T00:00:00.000Z", test.toString());
-        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-31T00:00:00.000Z", test.toString());
+        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().addWrapFieldToCopy(2);
-        assertEquals("1972-03-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.monthOfYear().addWrapFieldToCopy(3);
-        assertEquals("1972-04-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1973, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(2005, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().addWrapFieldToCopy(1);
-        assertEquals("1973-01-31T00:00:00.000Z", test.toString());
-        assertEquals("1973-02-28T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-31T00:00:00.000Z", test.toString());
+        assertEquals("2005-02-28T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertySetMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().setCopy(12);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());
         
-        test = new DateTime(1972, 1, 31, 0, 0, 0, 0);
+        test = new DateTime(2004, 1, 31, 0, 0, 0, 0);
         copy = test.monthOfYear().setCopy(2);
-        assertEquals("1972-02-29T00:00:00.000Z", copy.toString());
+        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());
         
         try {
             test.monthOfYear().setCopy(13);
@@ -434,18 +452,18 @@ public void testPropertySetMonthOfYear() {
     }
 
     public void testPropertySetTextMonthOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.monthOfYear().setCopy("12");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().setCopy("December");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());
         
         copy = test.monthOfYear().setCopy("Dec");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-12-09T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyCompareToMonthOfYear() {
@@ -472,7 +490,7 @@ public void testPropertyCompareToMonthOfYear() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());
         assertEquals("dayOfMonth", test.dayOfMonth().getName());
         assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());
@@ -497,87 +515,87 @@ public void testPropertyGetDayOfMonth() {
     }
 
     public void testPropertyGetMaxMinValuesDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertEquals(1, test.dayOfMonth().getMinimumValue());
         assertEquals(1, test.dayOfMonth().getMinimumValueOverall());
         assertEquals(30, test.dayOfMonth().getMaximumValue());
         assertEquals(31, test.dayOfMonth().getMaximumValueOverall());
-        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);
         assertEquals(31, test.dayOfMonth().getMaximumValue());
-        test = new DateTime(1972, 2, 9, 0, 0, 0, 0);
+        test = new DateTime(2004, 2, 9, 0, 0, 0, 0);
         assertEquals(29, test.dayOfMonth().getMaximumValue());
-        test = new DateTime(1971, 2, 9, 0, 0, 0, 0);
+        test = new DateTime(2003, 2, 9, 0, 0, 0, 0);
         assertEquals(28, test.dayOfMonth().getMaximumValue());
     }
 
     public void testPropertyAddDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().addToCopy(9);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-18T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(21);
-        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(22);
-        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(22 + 30);
-        assertEquals("1972-07-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(22 + 31);
-        assertEquals("1972-08-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-08-01T00:00:00.000+01:00", copy.toString());
 
         copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(-8);
-        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(-9);
-        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyAddWrapFieldDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addWrapFieldToCopy(22);
-        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfMonth().addWrapFieldToCopy(-12);
-        assertEquals("1972-06-27T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-27T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1972, 7, 9, 0, 0, 0, 0);
+        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);
         copy = test.dayOfMonth().addWrapFieldToCopy(21);
-        assertEquals("1972-07-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-30T00:00:00.000+01:00", copy.toString());
     
         copy = test.dayOfMonth().addWrapFieldToCopy(22);
-        assertEquals("1972-07-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());
     
         copy = test.dayOfMonth().addWrapFieldToCopy(23);
-        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());
     
         copy = test.dayOfMonth().addWrapFieldToCopy(-12);
-        assertEquals("1972-07-28T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-28T00:00:00.000+01:00", copy.toString());
     }
 
     public void testPropertySetDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().setCopy(12);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());
         
         try {
             test.dayOfMonth().setCopy(31);
@@ -590,10 +608,10 @@ public void testPropertySetDayOfMonth() {
     }
 
     public void testPropertySetTextDayOfMonth() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfMonth().setCopy("12");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());
     }
 
     public void testPropertyCompareToDayOfMonth() {
@@ -621,7 +639,7 @@ public void testPropertyCompareToDayOfMonth() {
     //-----------------------------------------------------------------------
     public void testPropertyGetDayOfYear() {
         // 31+29+31+30+31+9 = 161
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());
         assertEquals("dayOfYear", test.dayOfYear().getName());
         assertEquals("Property[dayOfYear]", test.dayOfYear().toString());
@@ -642,77 +660,77 @@ public void testPropertyGetDayOfYear() {
     }
 
     public void testPropertyGetMaxMinValuesDayOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertEquals(1, test.dayOfYear().getMinimumValue());
         assertEquals(1, test.dayOfYear().getMinimumValueOverall());
         assertEquals(366, test.dayOfYear().getMaximumValue());
         assertEquals(366, test.dayOfYear().getMaximumValueOverall());
-        test = new DateTime(1970, 6, 9, 0, 0, 0, 0);
+        test = new DateTime(2002, 6, 9, 0, 0, 0, 0);
         assertEquals(365, test.dayOfYear().getMaximumValue());
         assertEquals(366, test.dayOfYear().getMaximumValueOverall());
     }
 
     public void testPropertyAddDayOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfYear().addToCopy(9);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-18T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addToCopy(21);
-        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addToCopy(22);
-        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addToCopy(-8);
-        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addToCopy(-9);
-        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyAddWrapFieldDayOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfYear().addWrapFieldToCopy(21);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(22);
-        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(-12);
-        assertEquals("1972-05-28T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-05-28T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(205);
-        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(206);
-        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(-160);
-        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfYear().addWrapFieldToCopy(-161);
-        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertySetDayOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfYear().setCopy(12);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-01-12T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());
         
         try {
             test.dayOfYear().setCopy(367);
@@ -725,10 +743,10 @@ public void testPropertySetDayOfYear() {
     }
 
     public void testPropertySetTextDayOfYear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfYear().setCopy("12");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-01-12T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyCompareToDayOfYear() {
@@ -755,30 +773,30 @@ public void testPropertyCompareToDayOfYear() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetWeekOfWeekyear() {
-        // 1970-01-01 = Thu
-        // 1970-12-31 = Thu (+364 days)
-        // 1971-12-30 = Thu (+364 days)
-        // 1972-01-03 = Mon             W1
-        // 1972-01-31 = Mon (+28 days)  W5
-        // 1972-02-28 = Mon (+28 days)  W9
-        // 1972-03-27 = Mon (+28 days)  W13
-        // 1972-04-24 = Mon (+28 days)  W17
-        // 1972-05-23 = Mon (+28 days)  W21
-        // 1972-06-05 = Mon (+14 days)  W23
-        // 1972-06-09 = Fri
-        // 1972-12-25 = Mon             W52
-        // 1973-01-01 = Mon             W1
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        // 2002-01-01 = Thu
+        // 2002-12-31 = Thu (+364 days)
+        // 2003-12-30 = Thu (+364 days)
+        // 2004-01-03 = Mon             W1
+        // 2004-01-31 = Mon (+28 days)  W5
+        // 2004-02-28 = Mon (+28 days)  W9
+        // 2004-03-27 = Mon (+28 days)  W13
+        // 2004-04-24 = Mon (+28 days)  W17
+        // 2004-05-23 = Mon (+28 days)  W21
+        // 2004-06-05 = Mon (+14 days)  W23
+        // 2004-06-09 = Fri
+        // 2004-12-25 = Mon             W52
+        // 2005-01-01 = Mon             W1
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());
         assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());
         assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());
         assertSame(test, test.weekOfWeekyear().getReadableInstant());
         assertSame(test, test.weekOfWeekyear().getDateTime());
-        assertEquals(23, test.weekOfWeekyear().get());
-        assertEquals("23", test.weekOfWeekyear().getAsText());
-        assertEquals("23", test.weekOfWeekyear().getAsText(Locale.FRENCH));
-        assertEquals("23", test.weekOfWeekyear().getAsShortText());
-        assertEquals("23", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));
+        assertEquals(24, test.weekOfWeekyear().get());
+        assertEquals("24", test.weekOfWeekyear().getAsText());
+        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));
+        assertEquals("24", test.weekOfWeekyear().getAsShortText());
+        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());
         assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());
         assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));
@@ -789,59 +807,59 @@ public void testPropertyGetWeekOfWeekyear() {
     }
 
     public void testPropertyGetMaxMinValuesWeekOfWeekyear() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertEquals(1, test.weekOfWeekyear().getMinimumValue());
         assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall());
-        assertEquals(52, test.weekOfWeekyear().getMaximumValue());
-        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());
-        test = new DateTime(1970, 6, 9, 0, 0, 0, 0);
         assertEquals(53, test.weekOfWeekyear().getMaximumValue());
         assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());
+        test = new DateTime(2005, 6, 9, 0, 0, 0, 0);
+        assertEquals(52, test.weekOfWeekyear().getMaximumValue());
+        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());
     }
 
     public void testPropertyAddWeekOfWeekyear() {
-        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);
         DateTime copy = test.weekOfWeekyear().addToCopy(1);
-        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());
         
         copy = test.weekOfWeekyear().addToCopy(29);
-        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());
         
         copy = test.weekOfWeekyear().addToCopy(30);
-        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-03T00:00:00.000Z", copy.toString());
         
         copy = test.weekOfWeekyear().addToCopy(-22);
-        assertEquals("1972-01-03T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-05T00:00:00.000Z", copy.toString());
         
         copy = test.weekOfWeekyear().addToCopy(-23);
-        assertEquals("1971-12-27T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyAddWrapFieldWeekOfWeekyear() {
-        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);
         DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1);
-        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-12T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());
         
         copy = test.weekOfWeekyear().addWrapFieldToCopy(29);
-        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());
         
         copy = test.weekOfWeekyear().addWrapFieldToCopy(30);
-        assertEquals("1972-01-03T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());
         
         copy = test.weekOfWeekyear().addWrapFieldToCopy(-23);
-        assertEquals("1972-12-25T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertySetWeekOfWeekyear() {
-        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);
         DateTime copy = test.weekOfWeekyear().setCopy(4);
-        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-01-24T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());
         
         try {
-            test.weekOfWeekyear().setCopy(53);
+            test.weekOfWeekyear().setCopy(54);
             fail();
         } catch (IllegalArgumentException ex) {}
         try {
@@ -851,10 +869,10 @@ public void testPropertySetWeekOfWeekyear() {
     }
 
     public void testPropertySetTextWeekOfWeekyear() {
-        DateTime test = new DateTime(1972, 6, 5, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);
         DateTime copy = test.weekOfWeekyear().setCopy("4");
-        assertEquals("1972-06-05T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-01-24T00:00:00.000Z", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyCompareToWeekOfWeekyear() {
@@ -881,28 +899,17 @@ public void testPropertyCompareToWeekOfWeekyear() {
 
     //-----------------------------------------------------------------------
     public void testPropertyGetDayOfWeek() {
-        // 1970-01-01 = Thu
-        // 1970-12-31 = Thu (+364 days)
-        // 1971-12-30 = Thu (+364 days)
-        // 1972-01-03 = Mon
-        // 1972-01-31 = Mon (+28 days)
-        // 1972-02-28 = Mon (+28 days)
-        // 1972-03-27 = Mon (+28 days)
-        // 1972-04-24 = Mon (+28 days)
-        // 1972-05-23 = Mon (+28 days)
-        // 1972-06-05 = Mon (+14 days)
-        // 1972-06-09 = Fri
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());
         assertEquals("dayOfWeek", test.dayOfWeek().getName());
         assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());
         assertSame(test, test.dayOfWeek().getReadableInstant());
         assertSame(test, test.dayOfWeek().getDateTime());
-        assertEquals(5, test.dayOfWeek().get());
-        assertEquals("Friday", test.dayOfWeek().getAsText());
-        assertEquals("vendredi", test.dayOfWeek().getAsText(Locale.FRENCH));
-        assertEquals("Fri", test.dayOfWeek().getAsShortText());
-        assertEquals("ven.", test.dayOfWeek().getAsShortText(Locale.FRENCH));
+        assertEquals(3, test.dayOfWeek().get());
+        assertEquals("Wednesday", test.dayOfWeek().getAsText());
+        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));
+        assertEquals("Wed", test.dayOfWeek().getAsShortText());
+        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());
         assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());
         assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));
@@ -919,59 +926,59 @@ public void testPropertyGetDayOfWeek() {
     }
 
     public void testPropertyAddDayOfWeek() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfWeek().addToCopy(1);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-10T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(21);
-        assertEquals("1972-06-30T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(22);
-        assertEquals("1972-07-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1972-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);
-        assertEquals("1973-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(-8);
-        assertEquals("1972-06-01T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(-9);
-        assertEquals("1972-05-31T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1972-01-01T00:00:00.000Z", copy.toString());
+        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());
         
         copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);
-        assertEquals("1971-12-31T00:00:00.000Z", copy.toString());
+        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());
     }
 
     public void testPropertyAddWrapFieldDayOfWeek() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed
         DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-10T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());
         
-        copy = test.dayOfWeek().addWrapFieldToCopy(3);
-        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+        copy = test.dayOfWeek().addWrapFieldToCopy(5);
+        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());
         
-        copy = test.dayOfWeek().addWrapFieldToCopy(-12);
-        assertEquals("1972-06-11T00:00:00.000+01:00", copy.toString());
+        copy = test.dayOfWeek().addWrapFieldToCopy(-10);
+        assertEquals("2004-06-13T00:00:00.000+01:00", copy.toString());
         
-        test = new DateTime(1972, 6, 2, 0, 0, 0, 0);
-        copy = test.dayOfWeek().addWrapFieldToCopy(3);
-        assertEquals("1972-06-02T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-05-29T00:00:00.000+01:00", copy.toString());
+        test = new DateTime(2004, 6, 2, 0, 0, 0, 0);
+        copy = test.dayOfWeek().addWrapFieldToCopy(5);
+        assertEquals("2004-06-02T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());
     }
 
     public void testPropertySetDayOfWeek() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfWeek().setCopy(4);
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-08T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());
         
         try {
             test.dayOfWeek().setCopy(8);
@@ -984,23 +991,23 @@ public void testPropertySetDayOfWeek() {
     }
 
     public void testPropertySetTextDayOfWeek() {
-        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);
+        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);
         DateTime copy = test.dayOfWeek().setCopy("4");
-        assertEquals("1972-06-09T00:00:00.000+01:00", test.toString());
-        assertEquals("1972-06-08T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());
+        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());
         copy = test.dayOfWeek().setCopy("Mon");
-        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());
         copy = test.dayOfWeek().setCopy("Tuesday");
-        assertEquals("1972-06-06T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-08T00:00:00.000+01:00", copy.toString());
         copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH);
-        assertEquals("1972-06-05T00:00:00.000+01:00", copy.toString());
+        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());
     }
 
     public void testPropertyCompareToDayOfWeek() {
         DateTime test1 = new DateTime(TEST_TIME1);
         DateTime test2 = new DateTime(TEST_TIME2);
-        assertEquals(true, test1.dayOfWeek().compareTo(test2) < 0);
-        assertEquals(true, test2.dayOfWeek().compareTo(test1) > 0);
+        assertEquals(true, test2.dayOfWeek().compareTo(test1) < 0);
+        assertEquals(true, test1.dayOfWeek().compareTo(test2) > 0);
         assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0);
         try {
             test1.dayOfWeek().compareTo((ReadableInstant) null);
@@ -1009,8 +1016,8 @@ public void testPropertyCompareToDayOfWeek() {
         
         DateTime dt1 = new DateTime(TEST_TIME1);
         DateTime dt2 = new DateTime(TEST_TIME2);
-        assertEquals(true, test1.dayOfWeek().compareTo(dt2) < 0);
-        assertEquals(true, test2.dayOfWeek().compareTo(dt1) > 0);
+        assertEquals(true, test2.dayOfWeek().compareTo(dt1) < 0);
+        assertEquals(true, test1.dayOfWeek().compareTo(dt2) > 0);
         assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0);
         try {
             test1.dayOfWeek().compareTo((ReadableInstant) null);
diff --git a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java
index c847878fc..e667acd37 100644
--- a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java
+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java
@@ -76,25 +76,36 @@
  * @author Stephen Colebourne
  */
 public class TestInstant_Basics extends TestCase {
+    // Test in 2002/03 as time zones are more well known
+    // (before the late 90's they were all over the place)
 
     private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
     
-    // 1970-06-09
+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365;
+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365 + 365;
+    
+    // 2002-06-09
     private long TEST_TIME_NOW =
-            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
             
-    // 1970-04-05
+    // 2002-04-05
     private long TEST_TIME1 =
-        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 12L * DateTimeConstants.MILLIS_PER_HOUR
-        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 12L * DateTimeConstants.MILLIS_PER_HOUR
+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
         
-    // 1971-05-06
+    // 2003-05-06
     private long TEST_TIME2 =
-        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY
-        + 14L * DateTimeConstants.MILLIS_PER_HOUR
-        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 14L * DateTimeConstants.MILLIS_PER_HOUR
+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
         
     private DateTimeZone zone = null;
     private Locale locale = null;
@@ -126,19 +137,26 @@ protected void tearDown() throws Exception {
         zone = null;
     }
 
+    //-----------------------------------------------------------------------
+    public void testTest() {
+        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());
+        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());
+        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testGet() {
         Instant test = new Instant();
         assertEquals(1, test.get(ISOChronology.getInstance().era()));
-        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));
-        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().year()));
+        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));
+        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().year()));
         assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));
         assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));
-        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));
-        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));
-        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));
+        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));
+        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));
+        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));
         assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));
         assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));
         assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));
@@ -318,7 +336,7 @@ public void testSerialization() throws Exception {
     //-----------------------------------------------------------------------
     public void testToString() {
         Instant test = new Instant(TEST_TIME_NOW);
-        assertEquals("1970-06-09T00:00:00.000Z", test.toString());
+        assertEquals("2002-06-09T00:00:00.000Z", test.toString());
     }
 
     //-----------------------------------------------------------------------

From 193ca61debf67cc917e81b7d855e27f0539ce38a Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 11 Jul 2004 21:02:18 +0000
Subject: [PATCH 0125/1934] Add DateMidnight

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@275 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDateTime.java  |  58 +-
 .../src/java/org/joda/time/DateMidnight.java  | 749 ++++++++++++++++++
 JodaTime/src/test/org/joda/time/TestAll.java  |   8 +-
 .../time/TestDateMidnight_Constructors.java   | 596 ++++++++++++++
 4 files changed, 1380 insertions(+), 31 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/DateMidnight.java
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateMidnight_Constructors.java

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index be6bdad34..838f3ae08 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -105,9 +105,7 @@ private static Chronology selectChronology(Chronology chrono) {
      * using <code>ISOChronology</code> in the default time zone.
      */
     protected AbstractDateTime() {
-        super();
-        iChronology = ISOChronology.getInstance();
-        iMillis = DateTimeUtils.currentTimeMillis();
+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());
     }
 
     /**
@@ -119,9 +117,7 @@ protected AbstractDateTime() {
      * @param zone  the time zone, null means default zone
      */
     protected AbstractDateTime(final DateTimeZone zone) {
-        super();
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = DateTimeUtils.currentTimeMillis();
+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));
     }
 
     /**
@@ -134,9 +130,7 @@ protected AbstractDateTime(final DateTimeZone zone) {
      * @param chronology  the chronology, null means ISOChronology in default zone
      */
     protected AbstractDateTime(final Chronology chronology) {
-        super();
-        iChronology = selectChronology(chronology);
-        iMillis = DateTimeUtils.currentTimeMillis();
+        this(DateTimeUtils.currentTimeMillis(), chronology);
     }
 
     //-----------------------------------------------------------------------
@@ -147,9 +141,7 @@ protected AbstractDateTime(final Chronology chronology) {
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
     protected AbstractDateTime(final long instant) {
-        super();
-        iChronology = ISOChronology.getInstance();
-        iMillis = instant;
+        this(instant, ISOChronology.getInstance());
     }
 
     /**
@@ -162,9 +154,7 @@ protected AbstractDateTime(final long instant) {
      * @param zone  the time zone, null means default zone
      */
     protected AbstractDateTime(final long instant, final DateTimeZone zone) {
-        super();
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = instant;
+        this(instant, ISOChronology.getInstance(zone));
     }
 
     /**
@@ -180,7 +170,7 @@ protected AbstractDateTime(final long instant, final DateTimeZone zone) {
     protected AbstractDateTime(final long instant, final Chronology chronology) {
         super();
         iChronology = selectChronology(chronology);
-        iMillis = instant;
+        iMillis = round(instant, iChronology);
     }
 
     //-----------------------------------------------------------------------
@@ -200,7 +190,7 @@ protected AbstractDateTime(final Object instant) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
         iChronology = selectChronology(converter.getChronology(instant));
-        iMillis = converter.getInstantMillis(instant);
+        iMillis = round(converter.getInstantMillis(instant), iChronology);
     }
 
     /**
@@ -221,7 +211,7 @@ protected AbstractDateTime(final Object instant, final DateTimeZone zone) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
         iChronology = selectChronology(converter.getChronology(instant, zone));
-        iMillis = converter.getInstantMillis(instant, zone);
+        iMillis = round(converter.getInstantMillis(instant, zone), iChronology);
     }
 
     /**
@@ -241,7 +231,7 @@ protected AbstractDateTime(final Object instant, final Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
         iChronology = selectChronology(converter.getChronology(instant, chronology));
-        iMillis = converter.getInstantMillis(instant, chronology);
+        iMillis = round(converter.getInstantMillis(instant, chronology), iChronology);
     }
 
     //-----------------------------------------------------------------------
@@ -265,10 +255,8 @@ protected AbstractDateTime(
             final int minuteOfHour,
             final int secondOfMinute,
             final int millisOfSecond) {
-        super();
-        iChronology = ISOChronology.getInstance();
-        iMillis = iChronology.getDateTimeMillis(
-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        this(year, monthOfYear, dayOfMonth, hourOfDay,
+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance());
     }
 
     /**
@@ -295,10 +283,8 @@ protected AbstractDateTime(
             final int secondOfMinute,
             final int millisOfSecond,
             final DateTimeZone zone) {
-        super();
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = iChronology.getDateTimeMillis(
-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        this(year, monthOfYear, dayOfMonth, hourOfDay,
+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));
     }
 
     /**
@@ -328,8 +314,22 @@ protected AbstractDateTime(
             final Chronology chronology) {
         super();
         iChronology = selectChronology(chronology);
-        iMillis = iChronology.getDateTimeMillis(
-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        iMillis = round(instant, iChronology);
+    }
+
+    /**
+     * Rounds the specified instant as required by the subclass.
+     * This method must not access instance variables.
+     * <p>
+     * This implementation performs no rounding and returns the instant.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param chronology  the chronology to use, not null
+     */
+    protected long round(long instant, Chronology chronology) {
+        return instant;
     }
 
     // Accessors
diff --git a/JodaTime/src/java/org/joda/time/DateMidnight.java b/JodaTime/src/java/org/joda/time/DateMidnight.java
new file mode 100644
index 000000000..1a0377f5c
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java
@@ -0,0 +1,749 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.AbstractReadableInstantFieldProperty;
+
+/**
+ * DateMidnight defines a date where the time component is fixed at midnight.
+ * The class uses a time zone, if supplied, so midnight is local unless a UTC
+ * time zone is used.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
+ *
+ * <p>Each individual field can be queried in two ways:
+ * <ul>
+ * <li><code>getDayOfMonth()</code>
+ * <li><code>dayOfMonth().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>numeric value
+ * <li>text value
+ * <li>short text value
+ * <li>maximum/minimum values
+ * <li>add/subtract
+ * <li>set
+ * <li>rounding
+ * </ul>
+ *
+ * <p>
+ * DateMidnight is thread-safe and immutable, provided that the Chronology is as well.
+ * All standard Chronology classes supplied are thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public class DateMidnight extends AbstractDateTime
+        implements ReadableDateTime, Serializable {
+    
+    /** Serialization lock */
+    private static final long serialVersionUID = 156371964018738L;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the default time zone.
+     * The constructed object will have a local time of midnight.
+     */
+    public DateMidnight() {
+        super();
+    }
+
+    /**
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the specified time zone.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    public DateMidnight(DateTimeZone zone) {
+        super(zone);
+    }
+
+    /**
+     * Constructs an instance set to the current system millisecond time
+     * using the specified chronology.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public DateMidnight(Chronology chronology) {
+        super(chronology);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the default time zone.
+     * The constructed object will have a local time of midnight.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public DateMidnight(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the specified time zone.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param zone  the time zone, null means default zone
+     */
+    public DateMidnight(long instant, DateTimeZone zone) {
+        super(instant, zone);
+    }
+
+    /**
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using the specified chronology.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public DateMidnight(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs an instance from an Object that represents a datetime.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code>
+     * in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, null means now
+     * @throws IllegalArgumentException if the instant is invalid
+     */
+    public DateMidnight(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a datetime,
+     * forcing the time zone to that specified.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code> is used.
+     * If the specified time zone is null, the default zone is used.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, null means now
+     * @param zone  the time zone, null means default time zone
+     * @throws IllegalArgumentException if the instant is invalid
+     */
+    public DateMidnight(Object instant, DateTimeZone zone) {
+        super(instant, zone);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a datetime,
+     * using the specified chronology.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the chronology is null, ISOChronology in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in
+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, null means now
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the instant is invalid
+     */
+    public DateMidnight(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the default time zone.
+     * The constructed object will have a local time of midnight.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     */
+    public DateMidnight(int year, int monthOfYear, int dayOfMonth) {
+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);
+    }
+
+    /**
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the specified time zone.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param zone  the time zone, null means default time zone
+     */
+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {
+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);
+    }
+
+    /**
+     * Constructs an instance from datetime field values
+     * using the specified chronology.
+     * The constructed object will have a local time of midnight.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {
+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);
+    }
+
+    /**
+     * Rounds the specified instant as required by the subclass.
+     * This method must not access instance variables.
+     * <p>
+     * This implementation performs no rounding and returns the instant.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param chronology  the chronology to use, not null
+     */
+    protected long round(long instant, Chronology chronology) {
+        return chronology.dayOfMonth().roundFloor(instant);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a copy of this instant with different millis.
+     * The returned object will have a local time of midnight.
+     * <p>
+     * Only the millis will change, the chronology and time zone are kept.
+     * The returned object will be either be a new instance or <code>this</code>.
+     *
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public final DateMidnight withMillis(long newMillis) {
+        Chronology chrono = getChronology();
+        newMillis = round(newMillis, chrono);
+        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));
+    }
+
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * The returned object will have a local time of midnight in the new chronology.
+     * <p>
+     * The returned object will be either be a new instance or <code>this</code>.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
+     */
+    public final DateMidnight withChronology(Chronology newChronology) {
+        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));
+    }
+
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * millisecond instant.
+     * The returned object will have a local time of midnight.
+     * <p>
+     * This method is useful for finding the local time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London, the result
+     * from this method with Europe/Paris would be 13:30.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method changes alters the time zone, and does not change the
+     * millisecond instant, with the effect that the field values usually change.
+     * The returned object will be either be a new instance or <code>this</code>.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withZoneRetainFields
+     */
+    public final DateMidnight withZone(DateTimeZone newDateTimeZone) {
+        return withChronology(getChronology().withZone(newDateTimeZone));
+    }
+
+    /**
+     * Gets a copy of this instant with a different time zone, preserving the
+     * field values.
+     * The returned object will have a local time of midnight.
+     * <p>
+     * This method is useful for finding the millisecond time in another timezone.
+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),
+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * This method alters the time zone and the millisecond instant to keep
+     * the field values the same.
+     * The returned object will be either be a new instance or <code>this</code>.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     * @see #withZone
+     */
+    public final DateMidnight withZoneRetainFields(DateTimeZone newDateTimeZone) {
+        final long originalMillis = getMillis();
+        final Chronology originalChrono = getChronology();
+        final DateTimeZone originalZone;
+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {
+            // Without an original chronology or time zone, no new time zone
+            // can be set. Call withMillis to let it decide if a clone should
+            // be made or not.
+            return withMillis(originalMillis);
+        }
+
+        DateMidnight newInstant = withChronology(originalChrono.withZone(newDateTimeZone));
+        newDateTimeZone = newInstant.getZone();
+
+        if (newDateTimeZone == null || newDateTimeZone == originalZone) {
+            // New time zone didn't stick or didn't change. Skip millis adjustment.
+            return newInstant;
+        }
+
+        long newMillis = originalMillis + originalZone.getOffset(originalMillis);
+        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);
+
+        return newInstant.withMillis(newMillis);
+    }
+
+    // Date properties
+    //-----------------------------------------------------------------------
+    /**
+     * Get the era property.
+     * 
+     * @return the era property
+     */
+    public final Property era() {
+        return new Property(this, getChronology().era());
+    }
+
+    /**
+     * Get the century of era property.
+     * 
+     * @return the year of era property
+     */
+    public final Property centuryOfEra() {
+        return new Property(this, getChronology().centuryOfEra());
+    }
+
+    /**
+     * Get the year of century property.
+     * 
+     * @return the year of era property
+     */
+    public final Property yearOfCentury() {
+        return new Property(this, getChronology().yearOfCentury());
+    }
+
+    /**
+     * Get the year of era property.
+     * 
+     * @return the year of era property
+     */
+    public final Property yearOfEra() {
+        return new Property(this, getChronology().yearOfEra());
+    }
+
+    /**
+     * Get the year property.
+     * 
+     * @return the year property
+     */
+    public final Property year() {
+        return new Property(this, getChronology().year());
+    }
+
+    /**
+     * Get the year of a week based year property.
+     * 
+     * @return the year of a week based year property
+     */
+    public final Property weekyear() {
+        return new Property(this, getChronology().weekyear());
+    }
+
+    /**
+     * Get the month of year property.
+     * 
+     * @return the month of year property
+     */
+    public final Property monthOfYear() {
+        return new Property(this, getChronology().monthOfYear());
+    }
+
+    /**
+     * Get the week of a week based year property.
+     * 
+     * @return the week of a week based year property
+     */
+    public final Property weekOfWeekyear() {
+        return new Property(this, getChronology().weekOfWeekyear());
+    }
+
+    /**
+     * Get the day of year property.
+     * 
+     * @return the day of year property
+     */
+    public final Property dayOfYear() {
+        return new Property(this, getChronology().dayOfYear());
+    }
+
+    /**
+     * Get the day of month property.
+     * 
+     * @return the day of month property
+     */
+    public final Property dayOfMonth() {
+        return new Property(this, getChronology().dayOfMonth());
+    }
+
+    /**
+     * Get the day of week property.
+     * 
+     * @return the day of week property
+     */
+    public final Property dayOfWeek() {
+        return new Property(this, getChronology().dayOfWeek());
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Output the date time in ISO8601 format (yyyy-MM-dd'T'00:00:00.000Z).
+     * 
+     * @return ISO8601 time formatted string.
+     */
+    public final String toString() {
+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMillis(long millis) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setChronology(Chronology chronology) {
+    }
+
+    /**
+     * DateTimeFieldProperty binds a DateMidnight to a DateTimeField allowing powerful
+     * datetime functionality to be easily accessed.
+     * <p>
+     * The simplest use of this class is as an alternative get method, here used to
+     * get the year '1972' (as an int) and the month 'December' (as a String).
+     * <pre>
+     * DateMidnight dt = new DateMidnight(1972, 12, 3);
+     * int year = dt.year().get();
+     * String monthStr = dt.monthOfYear().getAsText();
+     * </pre>
+     * <p>
+     * Methods are also provided that allow date modification. These return new instances
+     * of DateMidnight - they do not modify the original. The example below yields two
+     * independent immutable date objects 20 years apart.
+     * <pre>
+     * DateMidnight dt = new DateMidnight(1972, 12, 3);
+     * DateMidnight dt20 = dt.year().addToCopy(20);
+     * </pre>
+     * Serious modification of dates (ie. more than just changing one or two fields)
+     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.
+     * <p>
+     * DateMidnight.Property itself is thread-safe and immutable.
+     *
+     * @author Stephen Colebourne
+     * @author Brian S O'Neill
+     * @since 1.0
+     */
+    public static class Property extends AbstractReadableInstantFieldProperty {
+    
+        /** Serialization lock */
+        private static final long serialVersionUID = 257629620L;
+        
+        /** The instant this property is working against */
+        private final DateMidnight iInstant;
+        /** The field this property is working against */
+        private final DateTimeField iField;
+
+        /**
+         * Constructor.
+         * 
+         * @param instant  the instant to set
+         * @param field  the field to use
+         */
+        public Property(DateMidnight instant, DateTimeField field) {
+            super();
+            iInstant = instant;
+            iField = field;
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Gets the field being used.
+         * 
+         * @return the field
+         */
+        public DateTimeField getField() {
+            return iField;
+        }
+
+        /**
+         * Gets the instant being used.
+         * 
+         * @return the instant
+         */
+        public ReadableInstant getReadableInstant() {
+            return iInstant;
+        }
+
+        /**
+         * Gets the datetime being used.
+         * 
+         * @return the datetime
+         */
+        public DateMidnight getDateMidnight() {
+            return iInstant;
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Adds to this field in a copy of this DateMidnight.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param value  the value to add to the field in the copy
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DateMidnight addToCopy(int value) {
+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));
+        }
+
+        /**
+         * Adds to this field in a copy of this DateMidnight.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param value  the value to add to the field in the copy
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DateMidnight addToCopy(long value) {
+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));
+        }
+
+        /**
+         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.
+         * A wrapped operation only changes this field.
+         * Thus 31st January addWrapField one day goes to the 1st January.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param value  the value to add to the field in the copy
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DateMidnight addWrapFieldToCopy(int value) {
+            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Sets this field in a copy of the DateMidnight.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param value  the value to set the field in the copy to
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the value isn't valid
+         */
+        public DateMidnight setCopy(int value) {
+            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));
+        }
+    
+        /**
+         * Sets this field in a copy of the DateMidnight to a parsed text value.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param text  the text value to set
+         * @param locale  optional locale to use for selecting a text symbol
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public DateMidnight setCopy(String text, Locale locale) {
+            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));
+        }
+
+        /**
+         * Sets this field in a copy of the DateMidnight to a parsed text value.
+         * <p>
+         * The DateMidnight attached to this property is unchanged by this call.
+         * This operation is faster than converting a DateMidnight to a MutableDateTime
+         * and back again when setting one field. When setting multiple fields,
+         * it is generally quicker to make the conversion to MutableDateTime.
+         * 
+         * @param text  the text value to set
+         * @return a copy of the DateMidnight with the field value changed
+         * @throws IllegalArgumentException if the text value isn't valid
+         */
+        public final DateMidnight setCopy(String text) {
+            return setCopy(text, null);
+        }
+
+        //-----------------------------------------------------------------------
+        /**
+         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.
+         *
+         * @return a copy of the DateMidnight with the field value changed
+         */
+        public DateMidnight roundFloorCopy() {
+            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));
+        }
+
+        /**
+         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.
+         *
+         * @return a copy of the DateMidnight with the field value changed
+         */
+        public DateMidnight roundCeilingCopy() {
+            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));
+        }
+
+        /**
+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,
+         * favoring the floor if halfway.
+         *
+         * @return a copy of the DateMidnight with the field value changed
+         */
+        public DateMidnight roundHalfFloorCopy() {
+            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));
+        }
+
+        /**
+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,
+         * favoring the ceiling if halfway.
+         *
+         * @return a copy of the DateMidnight with the field value changed
+         */
+        public DateMidnight roundHalfCeilingCopy() {
+            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));
+        }
+
+        /**
+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.
+         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+         *
+         * @return a copy of the DateMidnight with the field value changed
+         */
+        public DateMidnight roundHalfEvenCopy() {
+            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));
+        }
+
+    }
+}
diff --git a/JodaTime/src/test/org/joda/time/TestAll.java b/JodaTime/src/test/org/joda/time/TestAll.java
index 1b139c11a..4f8fa9e98 100644
--- a/JodaTime/src/test/org/joda/time/TestAll.java
+++ b/JodaTime/src/test/org/joda/time/TestAll.java
@@ -72,13 +72,17 @@ public TestAll(String testName) {
 
     public static Test suite() {
         TestSuite suite = new TestSuite();
+        suite.addTest(TestInstant_Constructors.suite());
+        suite.addTest(TestInstant_Basics.suite());
+        
         suite.addTest(TestDateTime_Constructors.suite());
         suite.addTest(TestDateTime_Basics.suite());
         suite.addTest(TestDateTime_Properties.suite());
+        
+        suite.addTest(TestDateMidnight_Constructors.suite());
+        
         suite.addTest(TestDateTimeComparator.suite());
         suite.addTest(TestDateTimeConstants.suite());
-        suite.addTest(TestInstant_Constructors.suite());
-        suite.addTest(TestInstant_Basics.suite());
 //        suite.addTest(TestParseISO.suite());
         return suite;
     }
diff --git a/JodaTime/src/test/org/joda/time/TestDateMidnight_Constructors.java b/JodaTime/src/test/org/joda/time/TestDateMidnight_Constructors.java
new file mode 100644
index 000000000..a7264a156
--- /dev/null
+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Constructors.java
@@ -0,0 +1,596 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.util.Date;
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.MockZeroNullIntegerConverter;
+
+/**
+ * This class is a Junit unit test for DateMidnight.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestDateMidnight_Constructors extends TestCase {
+    // Test in 2002/03 as time zones are more well known
+    // (before the late 90's they were all over the place)
+
+    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");
+    
+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365;
+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +
+                     366 + 365 + 365;
+    
+    // 2002-06-09
+    private long TEST_TIME_NOW_UTC =
+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
+    private long TEST_TIME_NOW_LONDON =
+            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;
+    private long TEST_TIME_NOW_PARIS =
+            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;
+    
+    // 2002-04-05
+    private long TEST_TIME1_UTC =
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 12L * DateTimeConstants.MILLIS_PER_HOUR
+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;
+    private long TEST_TIME1_LONDON =
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            - DateTimeConstants.MILLIS_PER_HOUR;
+    private long TEST_TIME1_PARIS =
+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            - 2*DateTimeConstants.MILLIS_PER_HOUR;
+    
+    // 2003-05-06
+    private long TEST_TIME2_UTC =
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+            + 14L * DateTimeConstants.MILLIS_PER_HOUR
+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;
+    private long TEST_TIME2_LONDON =
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+             - DateTimeConstants.MILLIS_PER_HOUR;
+    private long TEST_TIME2_PARIS =
+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+             - 2*DateTimeConstants.MILLIS_PER_HOUR;
+    
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateMidnight_Constructors.class);
+    }
+
+    public TestDateMidnight_Constructors(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeUtils.setCurrentMillisSystem();
+        DateTimeZone.setDefault(zone);
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    public void testTest() {
+        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());
+        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());
+        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor ()
+     */
+    public void testConstructor() throws Throwable {
+        DateMidnight test = new DateMidnight();
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (DateTimeZone)
+     */
+    public void testConstructor_DateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());
+    }
+
+    /**
+     * Test constructor (DateTimeZone=null)
+     */
+    public void testConstructor_nullDateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight((DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Chronology)
+     */
+    public void testConstructor_Chronology() throws Throwable {
+        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Chronology=null)
+     */
+    public void testConstructor_nullChronology() throws Throwable {
+        DateMidnight test = new DateMidnight((Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long1() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long2() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME2_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone)
+     */
+    public void testConstructor_long1_DateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME1_PARIS, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone)
+     */
+    public void testConstructor_long2_DateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME2_PARIS, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, DateTimeZone=null)
+     */
+    public void testConstructor_long_nullDateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long1_Chronology() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology)
+     */
+    public void testConstructor_long2_Chronology() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME2_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (long, Chronology=null)
+     */
+    public void testConstructor_long_nullChronology() throws Throwable {
+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_Object() throws Throwable {
+        Date date = new Date(TEST_TIME1_UTC);
+        DateMidnight test = new DateMidnight(date);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object)
+     */
+    public void testConstructor_invalidObject() throws Throwable {
+        try {
+            new DateMidnight(new Object());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_nullObject() throws Throwable {
+        DateMidnight test = new DateMidnight((Object) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null)
+     */
+    public void testConstructor_badconverterObject() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateMidnight test = new DateMidnight(new Integer(0));
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_Object_DateTimeZone() throws Throwable {
+        Date date = new Date(TEST_TIME1_UTC);
+        DateMidnight test = new DateMidnight(date, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME1_PARIS, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {
+        try {
+            new DateMidnight(new Object(), PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null, DateTimeZone)
+     */
+    public void testConstructor_nullObject_DateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight((Object) null, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone=null)
+     */
+    public void testConstructor_Object_nullDateTimeZone() throws Throwable {
+        Date date = new Date(TEST_TIME1_UTC);
+        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null, DateTimeZone=null)
+     */
+    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, DateTimeZone)
+     */
+    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_Object_Chronology() throws Throwable {
+        Date date = new Date(TEST_TIME1_UTC);
+        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_invalidObject_Chronology() throws Throwable {
+        try {
+            new DateMidnight(new Object(), GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology)
+     */
+    public void testConstructor_nullObject_Chronology() throws Throwable {
+        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology=null)
+     */
+    public void testConstructor_Object_nullChronology() throws Throwable {
+        Date date = new Date(TEST_TIME1_UTC);
+        DateMidnight test = new DateMidnight(date, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME1_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object=null, Chronology=null)
+     */
+    public void testConstructor_nullObject_nullChronology() throws Throwable {
+        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+    }
+
+    /**
+     * Test constructor (Object, Chronology)
+     */
+    public void testConstructor_badconverterObject_Chronology() throws Throwable {
+        try {
+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());
+            assertEquals(ISOChronology.getInstance(), test.getChronology());
+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());
+        } finally {
+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test constructor (int, int, int)
+     */
+    public void testConstructor_int_int_int() throws Throwable {
+        DateMidnight test = new DateMidnight(2002, 6, 9);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(LONDON, test.getZone());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        try {
+            new DateMidnight(Integer.MIN_VALUE, 6, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(Integer.MAX_VALUE, 6, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 0, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 13, 9);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 0);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 31);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateMidnight(2002, 7, 31);
+        try {
+            new DateMidnight(2002, 7, 32);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, DateTimeZone)
+     */
+    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);
+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());
+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        try {
+            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 0, 9, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 13, 9, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 0, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 31, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateMidnight(2002, 7, 31, PARIS);
+        try {
+            new DateMidnight(2002, 7, 32, PARIS);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, DateTimeZone=null)
+     */
+    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {
+        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology)
+     */
+    public void testConstructor_int_int_int_Chronology() throws Throwable {
+        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());
+        assertEquals(GregorianChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+        try {
+            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        try {
+            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());
+        try {
+            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());
+            fail();
+        } catch (IllegalArgumentException ex) {}
+    }
+
+    /**
+     * Test constructor (int, int, int, Chronology=null)
+     */
+    public void testConstructor_int_int_int_nullChronology() throws Throwable {
+        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());
+        assertEquals(2002, test.getYear());
+        assertEquals(6, test.getMonthOfYear());
+        assertEquals(9, test.getDayOfMonth());
+    }
+
+}

From 08a925a314f7f3acd2246501952dcde59f9263df Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 11 Jul 2004 22:37:47 +0000
Subject: [PATCH 0126/1934] Add DateMidnight tests

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@276 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateMidnight.java  |  78 +-
 JodaTime/src/test/org/joda/time/TestAll.java  |   1 +
 .../joda/time/TestDateMidnight_Basics.java    | 710 ++++++++++++++++++
 3 files changed, 741 insertions(+), 48 deletions(-)
 create mode 100644 JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java

diff --git a/JodaTime/src/java/org/joda/time/DateMidnight.java b/JodaTime/src/java/org/joda/time/DateMidnight.java
index 1a0377f5c..34e12b205 100644
--- a/JodaTime/src/java/org/joda/time/DateMidnight.java
+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java
@@ -61,8 +61,15 @@
 
 /**
  * DateMidnight defines a date where the time component is fixed at midnight.
- * The class uses a time zone, if supplied, so midnight is local unless a UTC
- * time zone is used.
+ * The class uses a time zone, thus midnight is local unless a UTC time zone is used.
+ * <p>
+ * It is important to emphasise that this class represents the time of midnight on
+ * any given day.
+ * Note that midnight is defined as 00:00, which is at the very start of a day.
+ * <p>
+ * This class does not represent a day, but the millisecond instant at midnight.
+ * If you need a class that represnts the whole day, then an {@link Interval} or
+ * a {@link YearMonthDay} may be more suitable.
  * <p>
  * This class uses a Chronology internally. The Chronology determines how the
  * millisecond instant value is converted into the date time fields.
@@ -314,10 +321,22 @@ public final DateMidnight withMillis(long newMillis) {
     }
 
     /**
-     * Gets a copy of this instant with a different chronology.
-     * The returned object will have a local time of midnight in the new chronology.
+     * Gets a copy of this instant with a different chronology, potentially
+     * changing the day in unexpected ways.
      * <p>
-     * The returned object will be either be a new instance or <code>this</code>.
+     * This method creates a new DateMidnight using the midnight millisecond value
+     * and the new chronology. If the same or similar chronology is specified, but
+     * with a different time zone, the day may change. This occurs because the new
+     * DateMidnight rounds down the millisecond value to get to midnight, and the
+     * time zone change may result in a rounding down to a different day.
+     * <p>
+     * For example, changing time zone from London (+00:00) to Paris (+01:00) will
+     * retain the same day, but changing from Paris to London will change the day.
+     * (When its midnight in London its the same day in Paris, but when its midnight
+     * in Paris its still the previous day in London)
+     * <p>
+     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}
+     * to change time zones.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
@@ -327,44 +346,12 @@ public final DateMidnight withChronology(Chronology newChronology) {
     }
 
     /**
-     * Gets a copy of this instant with a different time zone, p